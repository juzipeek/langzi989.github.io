
<!DOCTYPE html>
<html lang="zh-CN">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="魏传柳">
    <title>魏传柳</title>
    <meta name="author" content="魏传柳(2824759538@qq.com)">
    
        <meta name="keywords" content="hexo,javascript,">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="魏传柳">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="魏传柳">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="魏传柳">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/avar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-nuvue6sithwirecbhvw3dkaobiojqvtadsnhguwi7k04xklybw5djl1smadp.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">魏传柳</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avar.jpg"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avar.jpg"/>
            </a>
            <span class="sidebar-profile-name">魏传柳(2824759538@qq.com)</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">categories</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">archives</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">search</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">about</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/langzi989" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://blog.csdn.net/u014630623" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-csdn"></i>
                    <span class="sidebar-button-desc">CSDN</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/04/cgi原理/">
                            cgi原理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-04T20:36:55+08:00">
	
		    5月 04, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="CGI原理"><a href="#CGI原理" class="headerlink" title="CGI原理"></a>CGI原理</h1><p>CGI（Common Gateway Interface）通用网关接口，CGI描述了服务器和请求处理程序之间传输数据局的一种标准。在理解的过程中我们需要区分CGI和CGI程序，CGI是一种数据传输的标准，而CGI程序是实际处理业务的一个程序。webserver每请求一次，CGI程序就会fork出一个子进程进行处理。CGI程序的参数通过环境变量和标准输入获得，它的相应通过标准输出传递给webServer。</p>
<h2 id="CGI的工作原理是："><a href="#CGI的工作原理是：" class="headerlink" title="CGI的工作原理是："></a>CGI的工作原理是：</h2><ul>
<li>客户端通过http将请求发送到web服务器</li>
<li>web服务器接收并收集用户请求，然后交给CGI程序进行处理</li>
<li>CGI程序把处理后的结果发送给服务器</li>
<li>服务器将结果传送给浏览器</li>
</ul>
<p>其中上述第二步web服务器通过环境变量或标准输入将请求发送给CGI程序，第三步CGI通过标准输出将结果发送给webServer</p>
<h2 id="CGI接口标准：标准输入-环境变量以及标准输出"><a href="#CGI接口标准：标准输入-环境变量以及标准输出" class="headerlink" title="CGI接口标准：标准输入,环境变量以及标准输出"></a>CGI接口标准：标准输入,环境变量以及标准输出</h2><table>
<thead>
<tr>
<th style="text-align:left">借口标准</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">标准输入</td>
<td>CGI程序像其他可执行程序一样,可通过标准输入(stdin)从Web服务器得到输入信息,如Form中的数据,这就是所谓的向CGI程序传递数据的POST方法。这意味着在操作系统命令行状态可执行CGI程序,对CGI程序进行调试。POST方法是常用的方法。</td>
</tr>
<tr>
<td style="text-align:left">环境变量</td>
<td>操作系统提供了许多环境变量,它们定义了程序的执行环境,应用程序可以存取它们。Web服务器和CGI接口又另外设置了自己的一些环境变量,用来向CGI程序传递一些重要的参数。CGI的GET方法还通过环境变量QUERY-STRING向CGI程序传递Form中的数据。</td>
</tr>
<tr>
<td style="text-align:left">标准输出</td>
<td>CGI程序通过标准输出(stdout)将输出信息传送给Web服务器。传送给Web服务器的信息可以用各种格式,通常是以纯文本或者HTML文本的形式,这样我们就可以在命令行状态调试CGI程序,并且得到它们的输出。</td>
</tr>
</tbody>
</table>
<p>###常用的环境变量<br>Linux中的环境变量是一系列的键值对集合，它们的值可以通过shell设置，也可以被其他进程或程序设置和访问，它们是web服务器传递给CGI程序的一种最简单的方式，之所以叫做环境变量是因为它们是全局变量，任何程序都可以存取它们。</p>
<table>
<thead>
<tr>
<th style="text-align:center">key</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SERVER_NAME</td>
<td>CGI脚本运行时的主机名和IP地址</td>
</tr>
<tr>
<td style="text-align:center">SERVER_SOFTWARE</td>
<td>你的服务器的类型如： CERN/3.0 或 NCSA/1.3.</td>
</tr>
<tr>
<td style="text-align:center">GATEWAY_INTERFACE</td>
<td>运行的CGI版本. 对于UNIX服务器, 这是CGI/1.1</td>
</tr>
<tr>
<td style="text-align:center">SERVER_PROTOCOL</td>
<td>服务器运行的HTTP协议. 这里当是HTTP/1.0.</td>
</tr>
<tr>
<td style="text-align:center">SERVER_PORT</td>
<td>服务器运行的TCP口，通常Web服务器是80.</td>
</tr>
<tr>
<td style="text-align:center">REQUEST_METHOD</td>
<td>POST 或 GET, 取决于你的表单是怎样递交的</td>
</tr>
<tr>
<td style="text-align:center">HTTP_ACCEPT</td>
<td>浏览器能直接接收的Content-types, 可以有HTTP Accept header定义.</td>
</tr>
<tr>
<td style="text-align:center">HTTP_USER_AGENT</td>
<td>递交表单的浏览器的名称、版本 和其他平台性的附加信息。</td>
</tr>
<tr>
<td style="text-align:center">HTTP_REFERER</td>
<td>递交表单的文本的 URL，不是所有的浏览器都发出这个信息，不要依赖它</td>
</tr>
<tr>
<td style="text-align:center">PATH_INFO</td>
<td>附加的路径信息, 由浏览器通过GET方法发出.</td>
</tr>
<tr>
<td style="text-align:center">PATH_TRANSLATED</td>
<td>在PATH_INFO中系统规定的路径信息.</td>
</tr>
<tr>
<td style="text-align:center">SCRIPT_NAME</td>
<td>指向这个CGI脚本的路径, 是在URL中显示的(如, /cgi-bin/thescript).</td>
</tr>
<tr>
<td style="text-align:center"><strong>QUERY_STRING</strong></td>
<td><strong>脚本参数或者表单输入项(如果是用GET递交). QUERY_STRING包含URL中问号后面的参数</strong></td>
</tr>
<tr>
<td style="text-align:center">REMOTE_HOST</td>
<td>递交脚本的主机名，这个值不能被设置.</td>
</tr>
<tr>
<td style="text-align:center">REMOTE_ADDR</td>
<td>递交脚本的主机IP地址.</td>
</tr>
<tr>
<td style="text-align:center">REMOTE_USER</td>
<td>递交脚本的用户名. 如果服务器的authentication被激活，这个值可以设置。</td>
</tr>
<tr>
<td style="text-align:center">REMOTE_IDENT</td>
<td>如果Web服务器是在ident (一种确认用户连接你的协议)运行, 递交表单的系统也在运行ident, 这个变量就含有ident返回值.</td>
</tr>
<tr>
<td style="text-align:center">CONTENT_TYPE</td>
<td>如果表单是用POST递交, 这个值将是 application/x-www-form-urlencoded. 在上载文件的表单中, content-type 是个 multipart/form-data.</td>
</tr>
<tr>
<td style="text-align:center"><strong>CONTENT_LENGTH</strong></td>
<td><strong>对于用POST递交的表单,标准输入口的字节数.</strong></td>
</tr>
</tbody>
</table>
<h2 id="CGI的工作原理图"><a href="#CGI的工作原理图" class="headerlink" title="CGI的工作原理图"></a>CGI的工作原理图</h2><p><img src="/images/CGI" alt=""></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/04/cgi原理/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/04/Wait函数详解/">
                            Wait函数详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-04T15:40:48+08:00">
	
		    5月 04, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Wait函数详解"><a href="#Wait函数详解" class="headerlink" title="Wait函数详解"></a>Wait函数详解</h1><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>sys/types.h<br>signal.h</p>
<h2 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h2><p>注意此函数的功能是向指定进程发送信号。而不是杀死某个进程.名字为kill的原因是早期的Unix系统对信号的默认处理方式大部分是终止进程。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>int kill(pid_t pid, int sig);</p>
<p>返回值：执行成功返回0，执行失败返回-1。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>pid为进程ID,sig标识要发送的信号。</p>
<p>kill()函数的作用是用来向指定的进程或进程组发送信号。其中pid有一下<br>几种类型:</p>
<ul>
<li>pid &gt; 0： 发送信号给<strong>进程</strong>标识为pid的进程</li>
<li>pid = 0： 发送信号给当前进程<strong>相同进程组</strong>的所有进程</li>
<li>pid = -1：发送信号给<strong>系统内除了1号进程以外</strong>的所有进程</li>
<li>pid &lt; -1：发送信号给<strong>进程组</strong>标识为-pid的进程。</li>
</ul>
<p><strong>当sig=0时没有信号发出，但是系统会执行错误检查，通常会利用sig值为0来检查某个进程是否在执行。</strong></p>
<ul>
<li>若进程不存在,errno为ESRCH</li>
<li>若errno为EPERM(无权向目标进程发送信号，但是存在)或调用成功，表示进程存在。</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>相关知识：WIFSIGNALED和WIFEXITED两个宏是用来判断当前程序的子进程的退出方式，是接收到信号异常退出<br>还是正常调用exit()或return退出。</p>
<ul>
<li>WIFEXITED: 调用exit()或return退出</li>
<li>WIFSIGNALED:接收到信号异常退出 此时可以使用WTERMSIG(status)获取其接受信号的内容。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line">main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line">    <span class="keyword">int</span> status;</div><div class="line">    <span class="keyword">if</span>(!(pid= fork()))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Hi I am child process!\n"</span>);</div><div class="line">        sleep(<span class="number">10</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"send signal to child process (%d) \n"</span>, pid);</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        kill(pid, SIGABRT);</div><div class="line">        wait(&amp;status);</div><div class="line">        <span class="keyword">if</span>(WIFSIGNALED(status))</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"chile process receive signal %d\n"</span>, WTERMSIG(status));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="raise和killpg函数"><a href="#raise和killpg函数" class="headerlink" title="raise和killpg函数"></a>raise和killpg函数</h2><p>除了kill函数可以向进程发送信号外,还可以通过raise和killpg函数发送信号。</p>
<h2 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h2><p>int raise(int sig);<br>int killpg(pid_t pgrpid, int sig);</p>
<h2 id="函数功能-1"><a href="#函数功能-1" class="headerlink" title="函数功能"></a>函数功能</h2><p>raise函数的功能是向进程自身发送信号.在单线程程序中，调用raise函数相当于调用kill(getpid(), sig).<br>对于支持线程的系统，一般将raise实现为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pthread_kill(pthread_self(), sig);</div></pre></td></tr></table></figure></p>
<p>此时信号只发送给当前进程的当前线程。而不影响其他线程。</p>
<p>killpg函数的作用是向同组的所有进程发送信号。相当于:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kill(-pgrpid, sig);</div></pre></td></tr></table></figure></p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>raise函数的错误返回值只有一个,即EINVAL，表示信号无效。其他时候返回都为成功。<br>而killpg的返回值与kill类似。</p>
<h2 id="wait-与waitpid"><a href="#wait-与waitpid" class="headerlink" title="wait()与waitpid()"></a>wait()与waitpid()</h2><h3 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h3><p>sys/wait.h</p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span>* status);</div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* status, <span class="keyword">int</span> options);</div></pre></td></tr></table></figure>
<h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>父进程创建子进程之后，父进程使用wait和waitpid具有监视子进程的运行状态的能力。这两个函数用于<strong>等待子进程的状态发生变化回调并且获取状态发生变化的信息</strong>，所能获取的状态变化包括：<strong>子进程运行结束,子进程被信号量暂停，子进程被信号量回复运行</strong>。</p>
<p>父进程执行wait函数之后，父进程会被阻塞在此处，如果子进程状态发生变化，则wait函数会立即返回结果；否则wait函数会一直阻塞直到子进程状态发生变化。</p>
<p>通常意义上，，如果子进程状态发生了变化，但是还是未被其父进程或者其他系统回调执行wait函数，此时的子进程被称为可等待的。</p>
<p>子进程运行结束后父进程执行wait函数可以推动系统释放与子进程相关的资源；否则子进程将会被维持在<strong>僵尸进程</strong>（子进程已结束，而父进程还在运行）的状态下一直存在。</p>
<h3 id="返回值说明"><a href="#返回值说明" class="headerlink" title="返回值说明"></a>返回值说明</h3><p>上述函数的返回值有-1,0,&gt;0三种情况。分别对应于以下三种情况返回。</p>
<ul>
<li>-1:调用出错,此时出错信息在errno中</li>
<li>0:若waitpid的options设置了WNOHANG，且调用中没有子进程退出，立即返回0</li>
<li>>0:若大于0,返回退出进程的pid。</li>
</ul>
<h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li>pid：要监听的进程的ID(&lt;-1, =-1, =0, &gt; 0)</li>
<li>status: 用于存储出发状态变化时的信号值和exit(code)中的code值。</li>
<li>options 提供一些额外的选项控制waitpid,目前linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数宏，可以使用|连接使用.</li>
</ul>
<p><strong>pid详细说明</strong>:</p>
<ul>
<li>pid &lt; -1 : 监听范围为进程组为-pid的所有子进程</li>
<li>pid = -1 : 监听范围为调用wait/waitpid的所有子进程</li>
<li>pid = 0: 监听范围为子进程的进程组ID（与父进程相等）</li>
<li>pid &gt; 0: 监听特定pid的进程</li>
</ul>
<p><strong>status详细说明</strong></p>
<p>status用于保存出发wait的信号值或者退出时exit(code)中的code值</p>
<p><strong>options详细说明</strong></p>
<ul>
<li>WNOHANG : 使用此参数调用waitpid,即使子进程没有退出，他也会立即返回，而不是像wait一直等下去</li>
<li>WUNTRACED : 用于调试，极少用</li>
</ul>
<p>一般情况下使用值为0即可。</p>
<h3 id="wait与waitpid关系"><a href="#wait与waitpid关系" class="headerlink" title="wait与waitpid关系"></a>wait与waitpid关系</h3><p>wait实质上是waitpid中pid=-1,options=0时封装，即</p>
<p>wait(&amp;status)与waitpid(-1, &amp;status, 0)完全相同</p>
<h3 id="相关宏"><a href="#相关宏" class="headerlink" title="相关宏"></a>相关宏</h3><p>wait.h中定义了一些宏用于解析status的值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WIFEXITED(status)</td>
<td>子进程正常退出返回true否则false</td>
</tr>
<tr>
<td style="text-align:center">WEXITSTATUS(status)</td>
<td>当正常退出时，返回exit(code)中的code</td>
</tr>
<tr>
<td style="text-align:center">WIFSIGNALED</td>
<td>子进程接受信号退出时返回true，否则false</td>
</tr>
<tr>
<td style="text-align:center">WTERMSIG</td>
<td>被信号量杀死时，返回信号量的值</td>
</tr>
<tr>
<td style="text-align:center">WIFSTOPED(status)</td>
<td>当子进程被信号量暂停时返回true</td>
</tr>
<tr>
<td style="text-align:center">WSTOPSIG(status)</td>
<td>被信号量暂停时信号量的值</td>
</tr>
</tbody>
</table>
<p><strong>options值</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WNOHANG</td>
<td>调用wait时制定pid仍未返回，wait立即返回0，用于判断子进程有没有结束</td>
</tr>
<tr>
<td style="text-align:center">WUNTRACED</td>
<td>当子进程被暂停时，则wait立即返回子进程的pid</td>
</tr>
<tr>
<td style="text-align:center">WCONTINUED</td>
<td>当被暂停的子进程又被信号量恢复后，则wait立即返回子进程的pid。Linux 2.6.10及以后生效。在Mac 0S X 10.9.5上未生效。</td>
</tr>
</tbody>
</table>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/04/Wait函数详解/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/01/Unix文件IO的数据结构及fcntl函数详解/">
                            Unix文件IO的数据结构及fcntl函数详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-01T23:31:31+08:00">
	
		    5月 01, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Linux用于I-O的数据结构及fcntl函数详解"><a href="#Linux用于I-O的数据结构及fcntl函数详解" class="headerlink" title="Linux用于I/O的数据结构及fcntl函数详解"></a>Linux用于I/O的数据结构及fcntl函数详解</h1><h2 id="Linux内核用于IO的数据结构"><a href="#Linux内核用于IO的数据结构" class="headerlink" title="Linux内核用于IO的数据结构"></a>Linux内核用于IO的数据结构</h2><p>内核使用<strong>三种数据结构</strong>表示打开的文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响.</p>
<ul>
<li>进程表项 每个进程在记录表中都有一个记录项，记录项中包含一张打开的文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：<ul>
<li>文件描述符标志(close_on_exec,close_on_exec是一个进程所有文件描述符的标记位图，每个比特位代表一个打开的文件描述符，用于确定在系统调用execve()时需要关闭的文件句柄)。</li>
<li>指向一个文件表项的指针</li>
</ul>
</li>
<li>文件表项 内核为所有打开文件维护一张文件表（<strong>不同进程打开相同文件将有两条记录</strong>），每个文件表项中包括：<ul>
<li>文件状态标志(read,write,append,async,nonblock等)</li>
<li>当前文件偏移量</li>
<li>指向该文件v(i)节点表项的指针</li>
</ul>
</li>
<li>节点表项。每个打开的文件都有一个v-node结构，v-node中包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，V-node中还包含了文件inode节点信息，这些信息是打开文件时从磁盘上读入内存的，所以文件所有信息都是随时可用的。<ul>
<li>v节点的信息</li>
<li>当前文件的长度</li>
<li>i节点的信息</li>
</ul>
</li>
</ul>
<blockquote>
<p>close_on_exec是一个进程所有文件描述符（文件句柄）的位图标志，<strong>每个bit代表一个打开的文件描述符，用于<br>确定在系统调用execve()时是否需要关闭文件句柄。</strong>当一个进程fork出一个子进程时，通常会在子进程中调用execve()函数<br>加载执行另一个新程序。此时子进程将完全被新程序替换掉，并在子进程中执行新程序。若一个文件描述符在close_on_exec中对应的<br>bit被设置，那么在执行execve()时该文件描述符将被关闭，否则该文件描述符将始终处于打开状态。<br>当打开一个文件的时候，默认情况下文件句柄在子进程中也处于打开状态。<br>注意文件描述符和文件描述符标志的区别，文件描述符是文件进程打开文件时的文件句柄，文件描述符标志为close_on_exec。</p>
</blockquote>
<p>下图显示了一个进程打开两个不同文件时三张表对应的关系：</p>
<p><img src="/images/singleProcessmultifile.png" alt=""></p>
<p>如果两个独立的进程同时打开同一个文件，三张表之间的对应关系如下：</p>
<p><img src="/images/multiProcesssinglefile.png" alt=""><br>从上面可以看出，不同进程打开相同的文件时每个进程将获得各自的文件表项，这是因为不同的进程都有各自的文件偏移量。<br>当我们对文件进行操作的时候，上面三种表项之间的变化关系如下：</p>
<ul>
<li>当对文件进行写操作时（write），在文件表项中的文件偏移量将增加写入的字节数。如果此时文件偏移量超过了文件长度，更新文件长度为当前的文件偏移量</li>
<li>当用O_APPEND标志打开一个文件，则相应的标志也被设置到文件表项的文件标志状态中。每次对这种具有追加标志的文件进行写操作时，<strong>首先将当前文件偏移量设置为文件文件长度</strong>，这就使得每次增加的内容都会写到文件末尾。</li>
<li>若使用lseek定位到文件末尾，则文件表项中偏移量被设置为文件长度</li>
<li>lseek函数只修改文件表项中的偏移量，不进行任何IO操作。</li>
</ul>
<p><strong>注意问题：</strong></p>
<ul>
<li>可能有多个文件描述符指向同一个文件表项，如在fork的时候就有可能发生</li>
<li>注意文件描述符和文件状态标志在作用范围方面的区别。前者只用于一个进程的描述符，而后者则应用于指向该给定文件表项的任何进程中的所有描述符。</li>
</ul>
<h2 id="函数fcntl功能及用法"><a href="#函数fcntl功能及用法" class="headerlink" title="函数fcntl功能及用法"></a>函数fcntl功能及用法</h2><p><strong>函数原型</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/*int args or lock args*/</span>)</span></span>;</div></pre></td></tr></table></figure>
<p><strong>函数功能</strong>:<br>fcntl的作用是改变已经打开的文件属性。</p>
<p><strong>参数说明</strong>:</p>
<ul>
<li>fd 为file descriptor,即文件打开之后的文件描述符</li>
<li>cmd为命令，即需要对fd操作的命令,一般为几个宏定义中的其中一个</li>
<li>args 参数，此参数为执行cmd命令所需要的参数</li>
</ul>
<p><strong>cmd参数命令及功能</strong>:</p>
<p>fcntl的功能可以分为5种:</p>
<ul>
<li>复制一个已有的文件描述符<ul>
<li>cmd = F_DUPFD，此功能<em>*返回一个文件描述符，新的描述符的值为大于或等于args的可用的（尚未打开）文件描述符的最小值，新描述符与fd共用一个文件表项</em>。但是新的文件描述符有它自己的一套文件描述符标志.</li>
<li>cmd = F_DUPFD_CLOEXEC.与上述功能一致，唯一不同的是使用此命令会设置CLOSE_ON_EXEC，<br>即当执行execve的时候，文件描述符将被关闭。</li>
</ul>
</li>
<li>获取或设置文件描述符标志<ul>
<li>cmd = F_GETFD <strong>返回与fd关联的close_on_exec标志</strong>，第三个参数被忽略。</li>
<li>cnd = F_SETFD <strong>将文件描述符标志close_on_exec设置为第三个参数</strong>。</li>
</ul>
</li>
<li>获取或设置文件状态标志<ul>
<li>cmd = F_GETFL <strong>获取fd对应的文件的状态标志（存储于文件表项）</strong></li>
<li>cmd = F_SETFL <strong>设置fd对应文件的状态标志</strong></li>
</ul>
</li>
<li>获取或设置异步IO所有权<ul>
<li>cmd = F_GETOWN 获取当前接受SIGIO和SIGURG信号的进程IO或者进程组ID。</li>
<li>cmd = F_SETOWN 设置接受SIGIO和SIGURG信号的进程ID或进程组ID。返回值为正则为进程，返回值为负数即为进程组。</li>
</ul>
</li>
<li>获取或记录锁（cmd=F_GETLK、F_SETLK、F_SETLKW），此处不详解</li>
</ul>
<p><strong>文件状态标志说明</strong>：</p>
<p>文件状态标志存储与文件表项中，它用于说明进程对当前文件的可操作权限。文件的<br>操作权限说明如下图表所示，权限设置可使用|或者&amp;进行设置.</p>
<table>
<thead>
<tr>
<th style="text-align:center">文件状态标志</th>
<th style="text-align:left">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">O_RDONLY</td>
<td style="text-align:left">只读权限</td>
</tr>
<tr>
<td style="text-align:center">O_WRONLY</td>
<td style="text-align:left">只写权限</td>
</tr>
<tr>
<td style="text-align:center">O_RDWR</td>
<td style="text-align:left">读写权限</td>
</tr>
<tr>
<td style="text-align:center">O_EXEC</td>
<td style="text-align:left">可执行权限</td>
</tr>
<tr>
<td style="text-align:center">O_SEARCH</td>
<td style="text-align:left">只搜索打开权限</td>
</tr>
<tr>
<td style="text-align:center">O_APPEND</td>
<td style="text-align:left">追加写</td>
</tr>
<tr>
<td style="text-align:center">O_NONBLOCK</td>
<td style="text-align:left">非阻塞模式</td>
</tr>
<tr>
<td style="text-align:center">O_SYNC</td>
<td style="text-align:left">等待写完成（数据和属性）</td>
</tr>
<tr>
<td style="text-align:center">O_DSYNC</td>
<td style="text-align:left">等待写完成（仅数据）</td>
</tr>
<tr>
<td style="text-align:center">O_RSYNC</td>
<td style="text-align:left">同步读写</td>
</tr>
<tr>
<td style="text-align:center">O_FSYNC</td>
<td style="text-align:left">等待写完成</td>
</tr>
<tr>
<td style="text-align:center">O_ASYNC</td>
<td style="text-align:left">异步IO</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意O_RDONLY、O_WRONLY、O_RDWR、O_EXEC、O_SEARCH这个五个标志并不各占<br>一位，一个文件的访问方式只能取这五个里面的一个。因此检查当前文件的是这<br>五个标志中的哪一个需要使用屏蔽字O_ACCMODE取得当问方式位，在于这五个标志<br>进行对比。</p>
</blockquote>
<p><strong>代码示例说明</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> test;</div><div class="line">  <span class="comment">//返回结果：test = 10，返回大于等于第三个参数可用的fd(10)。</span></div><div class="line">  test = fcntl(STDIN_FILENO, F_DUPFD, <span class="number">10</span>);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"result of fcntl(STDIN_FILENO, F_DUPFD, 10) is:%d\n"</span>, test);</div><div class="line"></div><div class="line">  <span class="comment">//返回结果：test=11,与上一个函数功能相同</span></div><div class="line">  <span class="comment">//不同之处在于其设置了close_on_exec,当执行exec时关闭响应的文件描述符</span></div><div class="line">  <span class="comment">//注意有一些版本的系统上没有定义这个宏</span></div><div class="line">  <span class="comment">//test = fcntl(STDIN_FILENO, F_DUPFD_CLOEXEC, 10);</span></div><div class="line"></div><div class="line">  <span class="comment">//返回结果 test = 0. 标准输入的文件描述符标志(即关闭标志)为0，</span></div><div class="line">  <span class="comment">//意思是执行exec时关联的文件描述符不关闭</span></div><div class="line">  test = fcntl(STDIN_FILENO, F_GETFD);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"the result of fcntl(STDIN_FILENO, F_GETFD) is:%d\n"</span>, test);</div><div class="line"></div><div class="line">  <span class="comment">//将文件描述符标志设置为0</span></div><div class="line">  fcntl(STDIN_FILENO, F_SETFD, <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="comment">//返回结果 test = 32270</span></div><div class="line">  test = fcntl(STDIN_FILENO, F_GETFL);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"the result of fcntl(STDIN_FILENO, F_GETFL) is:%d\n"</span>, test);</div><div class="line"></div><div class="line">  <span class="comment">//给STDIN_FILENO对应的IO添加非阻塞权限</span></div><div class="line">  test |= O_NONBLOCK;</div><div class="line">  fcntl(STDIN_FILENO, F_SETFL, test);</div><div class="line"></div><div class="line">  test = fcntl(STDIN_FILENO, F_GETFL);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"the result of fcntl(STDIN_FILENO, F_GETFL) is:%d\n"</span>, test);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="STDIN-FILENO，STDOUT-FILENO以及STDERR-FILENO"><a href="#STDIN-FILENO，STDOUT-FILENO以及STDERR-FILENO" class="headerlink" title="STDIN_FILENO，STDOUT_FILENO以及STDERR_FILENO"></a>STDIN_FILENO，STDOUT_FILENO以及STDERR_FILENO</h2><p>STDIN_FILENO等是系统API接口库中<unistd.h>的宏定义，它是一个int类型的值，是打开文件的句柄，<br>对应的主要函数有open,read,write和close等。<br>STDIN_FILENO的含义是标准输入（键盘）的文件描述符，STDOUT_FILENO是标准输出流的文件描述符，STDERR_FILENO<br>是标准错误流的文件描述符。</unistd.h></p>
<h3 id="STDIN-FILENO与stdin的区别"><a href="#STDIN-FILENO与stdin的区别" class="headerlink" title="STDIN_FILENO与stdin的区别"></a>STDIN_FILENO与stdin的区别</h3><ul>
<li>数据类型不同 stdin的数据类型为FILE*，STDIN_NO的数据类型为int</li>
<li>可用的函数不同 stdin主要用的函数有fread,fwrite,fclose，STDIN_FILENO可用的函数为write，read和close</li>
<li>stdin属于标准IO，高级的输入输出函数，在stdio.h中定义;STDIN_FILENO是文件描述符，一般定义为0,1,2,属于没有buffer的IO,直接调用系统调用，定义在unistd.h中</li>
<li>层次不同，stdin属于标注库处理的输入流，其声明为FILE*型，对应的函数前面都有f开头；而STDIN_FILENO属于系统API接口，对用的函数是一些系统级的调用</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/01/Unix文件IO的数据结构及fcntl函数详解/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/04/07/free如何知道要free多大的空间/">
                            C语言free如何知道要free多大的空间
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-04-07T10:50:31+08:00">
	
		    4月 07, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/C-学习/">C++学习</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <p>在C语言中，当向一个函数传递指针的时候，它的长度信息往往会被截断（如果是数组名），传入函数的只是一个指针，而无法标示数组的长度，在函数中我们也无法获取它的长度信息，除非显示的传递一个长度参数。但是使用free函数的过程中，我们只是向free中传递了一个指针，并没有标示它的大小，那free是如何知道将要被free掉的内存的大小呢？下面将详细解答这一问题。</p>
<p>malloc函数的实现是以块分配内存，在被分配的块中包括两部分。<strong>第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量；第二部分中存储实际用户数据</strong>。而使用malloc分配内存返回的是第二部分用户数据的地址。而块的两个部分在内存中的存储取决有编译器的实现，一般有两种情况，第一种是最常见的，即元数据和用户数据是连续的，存储在连续空间位置。第二种是两部分分开存储。</p>
<p>对于第一种情况，malloc分配内存的空间图如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">____ The allocated block ____</div><div class="line">/                             \</div><div class="line">+--------+--------------------+</div><div class="line">| Header | Your data area ... |</div><div class="line">+--------+--------------------+</div><div class="line">         ^</div><div class="line">         |</div><div class="line">         +-- The address you are given</div></pre></td></tr></table></figure>
<p>对于上述情况，malloc中内存转换实现方式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* The corresponding word size */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ                (sizeof(INTERNAL_SIZE_T))</span></div><div class="line">...</div><div class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></div></pre></td></tr></table></figure></p>
<p>如上源码我们可以看出来，chunk2mem将原始指针转换为user_data的指针，mem2chunk做了相反的转换。这个时候free的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* mem)</span> </span>&#123;</div><div class="line">  p = mem2chunk(mem);</div><div class="line">  <span class="comment">// Now that you know how large is chunk "p", go ahead and free the chunk.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时，我们通过实验可以推测，标准库对void*的operator=做了重载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">  int *a = (int*)malloc(sizeof(int));</div><div class="line">  int *b = (int*)malloc(sizeof(int));</div><div class="line">  short *c = (short*)malloc(sizeof(short));</div><div class="line">  std::cout &lt;&lt; a &lt;&lt; std::endl</div><div class="line">            &lt;&lt; b &lt;&lt; std::endl</div><div class="line">            &lt;&lt; c &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; b - a &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; reinterpret_cast&lt;size_t&gt;(b) - reinterpret_cast&lt;size_t&gt;(a) &lt;&lt; std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x10b5c20</div><div class="line">0x10b5c40</div><div class="line">0x10b5c60</div><div class="line">8</div><div class="line">32</div></pre></td></tr></table></figure></p>
<p>参考:</p>
<p><a href="https://www.quora.com/How-does-free-function-in-C-knows-how-much-memory-to-be-released-deallocate" target="_blank" rel="external">https://www.quora.com/How-does-free-function-in-C-knows-how-much-memory-to-be-released-deallocate</a></p>
<p><a href="http://stackoverflow.com/questions/1518711/how-does-free-know-how-much-to-free" target="_blank" rel="external">http://stackoverflow.com/questions/1518711/how-does-free-know-how-much-to-free</a></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/04/07/free如何知道要free多大的空间/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/03/21/why-assigment-operator-can-not-be-frined-function/">
                            why assigment operator can not be frined function
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-03-21T14:30:41+08:00">
	
		    3月 21, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/C-problems/">C++ problems</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="why-assigment-operator-can-not-be-frined"><a href="#why-assigment-operator-can-not-be-frined" class="headerlink" title="why assigment operator can not be frined"></a>why assigment operator can not be frined</h1><blockquote>
<p>this is a problem in my work and I have find th solution on stackoverflow,so recorder here</p>
</blockquote>
<h2 id="problem-description"><a href="#problem-description" class="headerlink" title="problem description"></a>problem description</h2><p>When I refactor my object, I have a problem which need to change the return value<br>of and function std::string to a struct data, but I don’t want to change my code<br>where the function be used, so I want to overload the assignment operator which<br>will assign a struct to string.The code is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_struct</span>&#123;</span></div><div class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">operator</span> = (<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s, data_struct&amp; d);</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">bool</span> success&#123;<span class="literal">false</span>&#125;;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> message&#123;<span class="string">""</span>&#125;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  data_struct(<span class="keyword">bool</span> t_success, <span class="built_in">std</span>::<span class="built_in">string</span> t_message):</div><div class="line">            success(t_success), message(t_message) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">operator</span> = (<span class="built_in">std</span>::<span class="built_in">string</span>&amp; s, data_struct&amp; d) &#123;</div><div class="line">  s = d.s;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="function">data_struct <span class="title">d</span><span class="params">(<span class="literal">false</span>,<span class="string">"haha"</span>)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s = d;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>when I compile this file , this is an error follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">main.cpp:3:64: error: ‘std::__cxx11::string operator=(std::__cxx11::string&amp;, data_struct&amp;)’ must be a nonstatic member <span class="keyword">function</span></div><div class="line">   friend std::string operator = (std::string&amp; s, data_struct&amp; d);</div><div class="line">                                                                ^</div><div class="line">main.cpp:12:13: error: expected initializer before ‘operator’</div><div class="line"> std::string operator = (std::string&amp; s, data_struct&amp; d) &#123;</div><div class="line">             ^</div><div class="line">main.cpp: In <span class="keyword">function</span> ‘int main()’:</div><div class="line">main.cpp:19:19: error: conversion from ‘data_struct’ to non-scalar <span class="built_in">type</span> ‘std::__cxx11::string &#123;aka std::__cxx11::basic_string&lt;char&gt;&#125;’ requested</div><div class="line">   std::string s = d;</div></pre></td></tr></table></figure>
<h2 id="why-does-this-happen"><a href="#why-does-this-happen" class="headerlink" title="why does this happen?"></a>why does this happen?</h2><p>Firstly, it should be noted that this has nothing to do with the operator being implemented as a friend specifically. It is really about implementing the copy-assignment as a member function or as a non-member (standalone) function. Whether that standalone function is going to be a friend or not is completely irrelevant: it might be, it might not be, depending on what it wants to access inside the class.</p>
<p>Now, the answer to this question is given in D&amp;E book (The Design and Evolution of C++). The reason for this is that the compiler always declares/defines a member copy-assignment operator for the class (if you don’t declare your own member copy-assignment operator).</p>
<p>If the language also allowed declaring copy-assignment operator as a standalone (non-member) function, you could end up with the following</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Class definition</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></div><div class="line">  <span class="comment">// No copy-assignment operator declared here</span></div><div class="line">  <span class="comment">// so the compiler declares its own implicitly</span></div><div class="line">  ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">SomeClass a, b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">  a = b;</div><div class="line">  <span class="comment">// The code here will use the compiler-declared copy-assignment for `SomeClass`</span></div><div class="line">  <span class="comment">// because it doesn't know anything about any other copy-assignment operators</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Your standalone assignment operator</span></div><div class="line">SomeClass&amp; <span class="keyword">operator</span> =(SomeClass&amp; lhs, <span class="keyword">const</span> SomeClass&amp; rhs);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</div><div class="line">  a = b;</div><div class="line">  <span class="comment">// The code here will use your standalone copy-assigment for `SomeClass`</span></div><div class="line">  <span class="comment">// and not the compiler-declared one</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>As seen in the above example, the semantics of the copy-assignment would change in the middle of the translation unit - before the declaration of your standalone operator the compiler’s version is used. After the declaration your version is used. The behavior of the program will change depending on where you put the declaration of your standalone copy-assignment operator.</p>
<p>This was considered unacceptably dangerous (and it is), so C++ doesn’t allow copy-assignment operator to be declared as a standalone function.</p>
<p>It is true that in your particular example, which happens to use a friend function specifically, the operator is declared very early, inside the class definition (since that’s how friends are declared). So, in your case the compiler will, of course, know about the existence of your operator right away. However, from the point of view of C++ language the general issue is not related to friend functions in any way. From the point of view of C++ language it is about member functions vs. non-member functions, and non-member overloading of copy-assignment is just prohibited entirely for the reasons described above.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>due to the solution above is not proper.So I overWrite the orignal function, and<br>invoke different version in their needed place.</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/03/21/why-assigment-operator-can-not-be-frined-function/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/09/工厂类模式家族之简单工厂模式/">
                            工厂类模式家族之简单工厂模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-09T16:57:04+08:00">
	
		    1月 09, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/设计模式之路/">设计模式之路</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="工厂类模式家族之简单工厂模式"><a href="#工厂类模式家族之简单工厂模式" class="headerlink" title="工厂类模式家族之简单工厂模式"></a>工厂类模式家族之简单工厂模式</h1><p>在面向对象编程的领域，设计模式给我们提供了适合特定场景的软件设计思想，不过大多设计模式都可以通过一般的设计进行替代，但我们为什么还有费工夫去遵循设计模式呢？这就要说到设计模式的精髓了，我们通过对软件系统进行良好的设计，不但可以提高代码的可重用性，增强系统的可扩展性，给客户提供良好的接口，还可以减少编码过程中因代码组织太乱扩展过程中需要修改旧代码而带来的一连串的错误，降低维护成本。软件设计过程我们应该尽量追求符合软件设计的开闭原则。</p>
<blockquote>
<p> 开闭原则:在面向对象编程领域中，开闭原则规定“软件中的对象(类，模块，函数)应该<strong>对于扩展是开放的，但是对于修改是封闭的</strong>”。该特性在产品化的环境中是特别有价值的，在这种环境中我们认为一旦类完成，我们可以对它进行扩展改变其行为，但是不允许修改类。也就是说一个<strong>类的实现只应该因错误而修改</strong>。－－by wiki</p>
</blockquote>
<p>工厂模式家族包括三种重要的模式，分别是简单工厂模式，工厂模式以及抽象工厂模式。他们都属于类的创建型模式。创建型模式包括两种，分别是<strong>类的创建型模式</strong>和<strong>对象的创建型模式</strong>。类的创建型模式通常<strong>使用继承关系</strong>，将类的创建交由其具体的子类完成，这样就向外界隐藏了如何得到具体类的实现细节，以及这个类的实例是如何被创建或者组织在一起的。；对象创建型模式通常<strong>把一个类的创建委托给另一个对象完成</strong>，可以根据语境动态地决定生成哪个具体类的实例。</p>
<p>本节我们来讲解工厂模式中的简单工厂模式。主要包括以下几个部分：</p>
<ul>
<li>简单工厂模式的实质</li>
<li>简单工厂模式的适用性</li>
<li>简单工厂模式的结构</li>
<li>简单工厂模式的参与者</li>
<li>简单工厂模式各成分之间的交互</li>
<li>实际应用</li>
<li>简单工厂模式的优缺点</li>
<li>简单工厂模式实例代码</li>
</ul>
<h2 id="简单工厂模式的实质"><a href="#简单工厂模式的实质" class="headerlink" title="简单工厂模式的实质"></a>简单工厂模式的实质</h2><p>简单工厂模式又称为静态工厂模式。 <strong>它的实质是根据客户传递的信息，工厂类通过该信息制造出相应的产品的实例返回给客户。这样我们就做到了客户只是产品的消费者，而真正的创建者是工厂类。</strong> 在简单工厂模式中，待被创建的产品通常继承自同一个类。而这个类中包含了具体产品的所有的公共成员和方法。</p>
<h2 id="简单工厂模式的适用性"><a href="#简单工厂模式的适用性" class="headerlink" title="简单工厂模式的适用性"></a>简单工厂模式的适用性</h2><p>简单工厂模式将对象的创建和对象本身的业务分离开来，降低了系统的耦合度，当维护期间需要对客户代码或者产品代码进行修改的时候，修改其中之一不会影响另一个。</p>
<h2 id="简单工厂模式的结构"><a href="#简单工厂模式的结构" class="headerlink" title="简单工厂模式的结构"></a>简单工厂模式的结构</h2><p><img src="/images/simpleFactoryclassDiagram.png" alt=""></p>
<h2 id="简单工厂模式的参与者"><a href="#简单工厂模式的参与者" class="headerlink" title="简单工厂模式的参与者"></a>简单工厂模式的参与者</h2><p>简单工厂模式中一般有以下几个部分:</p>
<ul>
<li>工厂类：简单工厂模式的核心，它的作用是根据客户提供的信息创建相应的具体产品</li>
<li>抽象产品：所有具体产品的父类，其中主要包含所有具体产品共有的方法或对象</li>
<li>具体产品：工厂类创建的具体实例。</li>
</ul>
<h2 id="简单工厂模式各成分之间的交互"><a href="#简单工厂模式各成分之间的交互" class="headerlink" title="简单工厂模式各成分之间的交互"></a>简单工厂模式各成分之间的交互</h2><p><img src="/images/simplefactorysequence.png" alt=""></p>
<ul>
<li>客户首先创建factory类(一般为单例模式)，</li>
<li>factory类创建成功后，客户调用其createProduct方法，并传入相关信息，</li>
<li>具体产品实例被创建并返回给client,开始进行使用concreteProduct</li>
</ul>
<h2 id="简单工厂模式的实际应用"><a href="#简单工厂模式的实际应用" class="headerlink" title="简单工厂模式的实际应用"></a>简单工厂模式的实际应用</h2><p>在实际开发中使用简单工厂模式中，我们可以进行变通的使用。</p>
<p>在实际情况种可能会出现比较复杂的抽象产品和和具体产品之间的关系，这个时候我们依然也可以使用抽象工厂模式:</p>
<p><img src="/images/simplefactory2.png" alt=""></p>
<h2 id="简单工厂模式的优缺点"><a href="#简单工厂模式的优缺点" class="headerlink" title="简单工厂模式的优缺点"></a>简单工厂模式的优缺点</h2><p>简单工厂模式的优点: 通过在中间添加一个工厂类，降低产品类和客户代码之间的耦合度；客户在获取产品的时候无需记住所有产品的构造方法，只需要通过同意的工厂类接口进行创建产品，大大提高了效率准确率。</p>
<p>简单工厂模式的缺点：所有的产品实例化的逻辑都在工厂类的一个创建方法中，当需要添加新产品的时候，不得不进行修改factory类，这样就违背了设计的开闭原则(对扩展开放，对修改封闭)；另外当产品类别过多的时候，会出现这个函数冗杂的问题，增加维护成本。最重要的是这个工厂类是所有产品的入口，当它不能工作的时候，所有的产品将陷入瘫痪状态。</p>
<h2 id="简单工厂的实例"><a href="#简单工厂的实例" class="headerlink" title="简单工厂的实例"></a>简单工厂的实例</h2><p>下面通过形状shape,circle以及rectangle来实现一个简单的简单工厂模式(如有问题，欢迎指正)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//factory.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FACTORY_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FACTORY_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rectangle.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Factory() &#123;&#125;</div><div class="line">  Factory(<span class="keyword">const</span> Factory &amp;) = <span class="keyword">delete</span>;</div><div class="line">  Factory &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Factory &amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Factory&gt; m_factory;</div><div class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Factory&gt; getInstance();</div><div class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Shape&gt; getShape(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;flag);</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//factory.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"factory.hpp"</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Factory&gt; Factory::m_factory = <span class="literal">nullptr</span>;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Factory&gt; Factory::getInstance() &#123;</div><div class="line">  <span class="keyword">if</span> (m_factory == <span class="literal">nullptr</span>) &#123;</div><div class="line">    m_factory = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Factory&gt;(<span class="keyword">new</span> Factory());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> m_factory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Shape&gt; Factory::getShape(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;flag) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="number">0</span> == flag.compare(<span class="string">"circle"</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Shape&gt;(<span class="keyword">new</span> Circle());</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == flag.compare(<span class="string">"rectangle"</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Shape&gt;(<span class="keyword">new</span> Rectangle());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//shape.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHAPE_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SHAPE_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//circle.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CIRCLE_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CIRCLE_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shape.hpp"</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Circle(<span class="keyword">double</span> t_radius = <span class="number">0</span>) : m_radius(t_radius) &#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is a circle, the radius is : "</span> &lt;&lt; m_radius &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  &#125;;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_radius * m_radius * <span class="number">3.14</span>; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">double</span> m_radius;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//rectangle.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RECTANGLE_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RECTANGLE_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shape.hpp"</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Rectangle(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) : m_height(a), m_width(b) &#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is a rectangle\n height: "</span> &lt;&lt; m_height</div><div class="line">              &lt;&lt; <span class="string">"\nwidth:"</span> &lt;&lt; m_width &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_height * m_width; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">int</span> m_height;</div><div class="line">  <span class="keyword">int</span> m_width;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"factory.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"rectangle.hpp"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Factory&gt; t = Factory::getInstance();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Shape&gt; c = t-&gt;getShape(<span class="string">"circle"</span>);</div><div class="line">  c-&gt;draw();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the area is: "</span> &lt;&lt; c-&gt;getArea() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Shape&gt; r = t-&gt;getShape(<span class="string">"rectangle"</span>);</div><div class="line">  r-&gt;draw();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"the area is :"</span> &lt;&lt; r-&gt;getArea() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/09/工厂类模式家族之简单工厂模式/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/08/GRASP设计原则（职责分配原则）/">
                            GRASP设计原则（职责分配原则）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-08T19:45:46+08:00">
	
		    1月 08, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/设计模式之路/">设计模式之路</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="GRASP设计原则（职责分配原则）"><a href="#GRASP设计原则（职责分配原则）" class="headerlink" title="GRASP设计原则（职责分配原则）"></a>GRASP设计原则（职责分配原则）</h1><p>GRASP(General responsibility assignment software Principle)设计原则是设计模式的基础,在GOF的23中设计模式中处处可以体现其中的一个或多个设计原则，所以在掌握设计模式之前需要对GRASP原则有一定的了解，本节我在这里总结一下grasp原则。</p>
<p>本文共分为以下几个内容：</p>
<ul>
<li>GRASP的九个原则</li>
<li>GRASP原则详解</li>
<li>GRASP原则在23中设计模式中的体现</li>
</ul>
<h2 id="GRASP的九个原则"><a href="#GRASP的九个原则" class="headerlink" title="GRASP的九个原则"></a>GRASP的九个原则</h2><ul>
<li>信息专家原则(information)</li>
<li>创造者原则(creator)</li>
<li>低耦合原则(low coupling)</li>
<li>高内聚原则(high cohesion)</li>
<li>控制器原则(controller)</li>
<li>多态原则(polymorphism)</li>
<li>纯虚构(pure Fabrication)</li>
<li>中介原则(indirect)</li>
<li>受保护变量原则(protected Variations)</li>
</ul>
<h2 id="Grasp原则详解"><a href="#Grasp原则详解" class="headerlink" title="Grasp原则详解"></a>Grasp原则详解</h2><h3 id="信息专家原则-information-expert"><a href="#信息专家原则-information-expert" class="headerlink" title="信息专家原则(information expert)"></a>信息专家原则(information expert)</h3><p>信息专家模式的本质指的是我们应该将<strong>职责委托给哪一个对象</strong>，这个职责可以是一个方法，也可以是一个算法或者其他内容。它是面向过程设计过程中最基本的原则。</p>
<p><strong>委托原则</strong>:我们在设计对象的时候，如果某个对象拥有完成某个职责所需要的所有信息，那么这个职责就分配给这个对象实现。这个时候，这个类就是相对于这个职责的信息专家。</p>
<p>示例：我们在设计购物网站的时候，为避免重复，一种商品只能在购物车中出现一次，如果多次出现，则需要将其数量增加。这个时候我们在将物品放入购物车的时候，要首先判断当前物品是否在购物车中，判断两个物品是否为同一个物品的方法这个职责应该委托给谁呢？显而易见，商品类中有唯一标识，所以这个职责由商品类实现，而不是购物车。</p>
<h3 id="创造者原则-creator"><a href="#创造者原则-creator" class="headerlink" title="创造者原则(creator)"></a>创造者原则(creator)</h3><p>creator原则的本质是创建类对象职责应该委托给那个对象，也就是谁应该负责产生某个类的实例。</p>
<p>解决方案:　如果符合下面的一个或者多个条件，则可以将创建A的实例的职责分配给B;</p>
<ul>
<li>B包含A</li>
<li>B聚合A</li>
<li>B拥有初始化A的数据并在创建A的实例时将数据传递给A</li>
<li>B记录A的实例</li>
<li>B频发使用A</li>
</ul>
<p>满足上述一种或者多种情况的时候，我们应该奖创建A的实例的职责分配给B。</p>
<p>合理的creator原则带来的<strong>优点</strong>：如果职责分配合理，设计就能降低耦合，提高设计的清晰度，封装性和重用性。</p>
<p>示例:例如订单和商品的关系是聚合关系，这个时候我们将在订单中创建商品。</p>
<h3 id="低耦合-Low-coupling"><a href="#低耦合-Low-coupling" class="headerlink" title="低耦合(Low coupling)"></a>低耦合(Low coupling)</h3><p><strong>耦合是评价一个系统中各个元素之间连接或者依赖关系强弱的尺度。</strong>低耦合的原则是我们在设计系统的时候尽量降低系统中各个元素之间的耦合度，这样对于系统的理解和维护都有很大的益处。</p>
<p>耦合性高的系统会带来的坏处:</p>
<ul>
<li>一个类的修改导致其他类产生较大的影响；</li>
<li>系统难以维护和理解；</li>
<li>系统的重用性差，在重用一个高耦合类的时候，不得不重用它所依赖的所有类。</li>
</ul>
<p>两个类具有以下特性中的其中一个，我们就说这两个类是耦合的：</p>
<ul>
<li>A具有一个类型为B的属性；</li>
<li>A调用B的方法</li>
<li>A的方法包含对B的引用(参数或者返回值的方式)</li>
<li>A是B的直接或者间接的子类</li>
<li>A是接口B的一种实现</li>
</ul>
<p>低耦合系统的<strong>设计方法</strong>：</p>
<ul>
<li>在类的划分上，尽量创建松耦合的类，类之间的耦合性越低，越有利于复用，修改一个类不会影响其他类。</li>
<li>在类的设计上，尽量降低类中成员和方法的访问权限。</li>
<li>在类的设计上，尽量将类设计为不变类</li>
<li>在类的引用上，将一个对象对另一个对象的引用降低到最小</li>
</ul>
<h3 id="高内聚-high-cohesion"><a href="#高内聚-high-cohesion" class="headerlink" title="高内聚(high cohesion)"></a>高内聚(high cohesion)</h3><p><strong>内聚是评价一个对象的职责被关联的尺度或者强弱，也可以说是功能性内聚的职责。</strong>也就是功能性紧密的相关职责应该放在同一个类中，并共同完成有限的功能。这样做更加有利于对类的理解和重用，也可以降低类的维护成本。</p>
<p>往往低内聚的系统设计会导致类的混乱，当对功能进行扩展或者改进的时候带来不必要的麻烦，低内聚的类也不利于重用，因为他们的职责如此之混乱。</p>
<p>为了达到高内聚，我们需要对类的职责进行分解，使分解出来的类具有独立的职责，满足单一职责原则。<strong>将一些需要在多个类中使用到的方法封装到一个类中，其他的类只负责他们需要负责的相关功能</strong>，这样我们可以提高类的内聚程度。</p>
<h3 id="控制器原则-controller"><a href="#控制器原则-controller" class="headerlink" title="控制器原则(controller)"></a>控制器原则(controller)</h3><p>控制器模式的实质是将一些<strong>系统事件的接受和处理</strong>委托给一个的对象controller，这个对象可以是一个<strong>类，系统或者子系统</strong>，它不与UI进行交互，它只负责系统信息的接收和处理。</p>
<p>一般情况下，控制器是一个系统，这个系统中包括多个处理器，分别对应处理不同的事务。通常情况下，一个控制器应当把要完成的功能委托给其他对象，而它只负责任务的协调控制和分配。</p>
<p>控制器原则与MVC模式相对应，MVC模式是一种比设计模式更高的架构模式。</p>
<h3 id="多态原则-polymorphism"><a href="#多态原则-polymorphism" class="headerlink" title="多态原则(polymorphism)"></a>多态原则(polymorphism)</h3><p>多态原则与面向对象设计原则中的多态概念类似，这里不再详细赘述。</p>
<h3 id="纯虚构-pure-Fabrication"><a href="#纯虚构-pure-Fabrication" class="headerlink" title="纯虚构(pure Fabrication)"></a>纯虚构(pure Fabrication)</h3><p>纯虚构原则与我们所说的纯虚函数类似。</p>
<p>　　纯虚构的作用是用来解决高内聚和低耦合之间的矛盾的。高内聚低耦合是我们系统设计的终极目标，高内聚意味着我们要将类拆分成多个功能集中的类，但是拆分的多个类之间需要进行协作才能正常工作，这样又增加了类之间的耦合性。</p>
<p>　　纯虚构原则是用来解决上述问题的方案。它要求将一部分类的职责转移到纯虚构类中，在理想的情况下，分配给这种虚构类的职责是为了达到高内聚低耦合的效果。在实际的操作过程中，纯虚构类的实现又很多种方式，例如将数据库中操作的方法从数据库实体中分离出来，形成专门的数据访问类；通过对类的分解来实现类的重用，新增加的数据访问类对应于数据的持久化存储，这是软件开发过程中为了方便虚构出来的一个概念。一般情况下，<strong>纯虚构模式通常基于功能进行划分的。</strong></p>
<h3 id="中介模式-indirect"><a href="#中介模式-indirect" class="headerlink" title="中介模式(indirect)"></a>中介模式(indirect)</h3><p>中介模式的目的是为了避免两个对象之间产生直接耦合，降低对象之间的耦合度。</p>
<p>解决方案是建立中间对象来协调两个对象之间的交互，避免耦合性过高。</p>
<h3 id="受保护模式-protected-variations"><a href="#受保护模式-protected-variations" class="headerlink" title="受保护模式(protected variations)"></a>受保护模式(protected variations)</h3><p>受保护模式的实质与OCP(开放闭合原则)类似，我们首先找到系统中不稳定的变化点，使用统一的接口封装起来，如果未来发生变化的时候，可以通过扩展接口来扩展新的功能，而不需要改变旧的代码。这样达到易于扩展的目的。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/08/GRASP设计原则（职责分配原则）/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/08/创建型设计模式之build模式/">
                            创建型设计模式之build模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-08T01:36:19+08:00">
	
		    1月 08, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/设计模式之路/">设计模式之路</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="创建型设计模式之build模式"><a href="#创建型设计模式之build模式" class="headerlink" title="创建型设计模式之build模式"></a>创建型设计模式之build模式</h1><p>最近在读《设计模式-可复用面向对象软件设计的基础》一书，在阅读的过程中我会结合书中的相关知识和实例以及在网络上的博客对相关的模式的理解进行总结，并在此基础上加入自己的一些理解，总结模式中需要注意的一些点，记录在此博客，以供大家交流分享，同时防止自己对内容遗忘，如有不正确指出，欢迎批评指正。</p>
<p>本节的主要内容是设计模式中的创建型模式之一:builder模式</p>
<p>要用好builder模式，必须对其机制了解透彻，将该模式用在合适的软件中才能显出它真正的威力，第五部分中实例将为您展示它的真正威力。</p>
<p>本文内容分为以下几个方面:</p>
<ul>
<li>builder模式的意图</li>
<li>builder模式的适用性</li>
<li>builder模式的结构(通用UML类图)及详解</li>
<li>builder模式中的参与者</li>
<li>builder模式中各个成分之间的交互</li>
<li>builder模式比较好的一个实例</li>
<li>builder模式使用过程中注意的点</li>
<li>KFC套餐实例代码</li>
</ul>
<p><strong>builder模式的精髓都隐藏于builder模式的意图和实用性中，让你真正理解这两个方面，可以说你已经掌握了builder模式（以下意图和模式都摘自《设计模式》书中）</strong></p>
<h2 id="builder模式的意图"><a href="#builder模式的意图" class="headerlink" title="builder模式的意图"></a>builder模式的意图</h2><p>builder模式的意图是将一个<strong>复杂对象的构建</strong>与它的<strong>表示</strong>分离，使得同样的构建过程可以创建不同的表示。</p>
<h2 id="builder模式的适用性"><a href="#builder模式的适用性" class="headerlink" title="builder模式的适用性"></a>builder模式的适用性</h2><ul>
<li>当<strong>创建复杂对象的算法</strong>应该独立于<strong>该对象的组成部分</strong>以及<strong>它们的装配方式</strong>时。</li>
<li>当构造过程必须<strong>允许被构造的对象有不同的表示</strong>时。</li>
</ul>
<p>提前记录一下:装配的工作是由导向器(director)完成的，复杂对象的创建是由具体的建造器完成(concreteBuilder)，这里不明白没问题，等你看完全文再过来看这里你就理解了。</p>
<blockquote>
<p> 当且仅当上面两个条件均满足的情况下我们要使用builder模式（完全理解这两条不一件重要的事情，但是不要着急,当你读完这篇文章的时候就会拨开它的庐山真面目了）</p>
</blockquote>
<h2 id="builder模式的结构-UML类图-及详解"><a href="#builder模式的结构-UML类图-及详解" class="headerlink" title="builder模式的结构(UML类图)及详解"></a>builder模式的结构(UML类图)及详解</h2><p>builder模式的UML类图关系如下:</p>
<p><img src="/images/build_diagram.png" alt=""></p>
<p>注意的问题:</p>
<ul>
<li>在builder中一般不声明纯虚函数，而是把它们定义为空方法，这使客户只重定义他们感兴趣的操作。</li>
<li>在director中，注意我们不是把所有的buildPart都去执行一次，而是根据需要的客户的需求，进行定制的去buildPart部分构建，可以构建一次，也可以构建多次。</li>
<li>一般将m_product声明为protected成员，因为这样既保证了封装性，又能使得concreteBuilder能够正常操作product；</li>
</ul>
<h2 id="builder模式种的参与者"><a href="#builder模式种的参与者" class="headerlink" title="builder模式种的参与者"></a>builder模式种的参与者</h2><p>从上面的类图中我们也可以看出,在builder模式中的参与者有以下四种,以及他们的职责分别是:(此处为个人理解，与书中内容可能不一致,如果有问题欢迎指正)</p>
<ul>
<li>Director: 负责装配product的各个部件，使用Builder的类方法进行实现。它的作用是隔离了客户与product的具体生产过程；并负责控制product的生产过程。</li>
<li>Builder: 为创建一个product对象的各个部件指定抽象接口。一般情况下默认builderPart的操作默认为空。</li>
<li>concreteBuilder: 具体实现每一个部件的具体的复杂生产过程，如buildPartA()的具体实现，并提供一个检索产品的接口。</li>
<li>Product: 这个争议不大，即为被构造的复杂对象。此类对象会有不同的表示。</li>
</ul>
<h2 id="builder模式各个成分之间的交互方式"><a href="#builder模式各个成分之间的交互方式" class="headerlink" title="builder模式各个成分之间的交互方式"></a>builder模式各个成分之间的交互方式</h2><p>先上一张时序图:</p>
<p><img src="/images/builder_sequence.png" alt=""></p>
<p>从上面的时序图可以分析出，各个成分之间的交互方式如下:</p>
<ul>
<li>客户首先创建一个concreteBuilder对象,然后创建一个Director,</li>
<li>创建结束之后，使用concreteBuilder修饰对象Director,</li>
<li>然后调用Director的construct()方法，进行构造Product,</li>
<li>最后客户通过concreteBuilder的getResult()方法取回生成的Product</li>
</ul>
<h2 id="builder模式中一个较好的实例"><a href="#builder模式中一个较好的实例" class="headerlink" title="builder模式中一个较好的实例"></a>builder模式中一个较好的实例</h2><p>两个实例来自网络对两本书籍实例的纠正,改编</p>
<p>上面这篇文章深刻的分析了builder模式的本质以及诸多误区的分析，收益颇多，在此感谢博主分享。</p>
<p>在本例中,设备(Equipment)是一个复杂对象，由一个machine和一个或多个输入端口(InputPort)或者输出端口(outputPort)组成；其中输入或输出端口可能有不同的类型(ordinary和super)。现在要你设计一个生成不同型号的产品，要求产品可能包含一进一出(普通或super)，一进两出(普通或super)。</p>
<p>　　在设计中,我们首先定义一个LCDFactory对象充当director，一个设备生成器(EQPBuilder),相当于Builder。</p>
<p>​    首先ordinary和super是port的内部实现方式不同，所以我们需要定义两个具体类，即 ordinaryEQPBuilder和superEQPBuilder。</p>
<p>​    在EQPbuilder中，我们将定义四个函数，分别是:buildMachine(), addInputPort(), addOutputPort()和getEQP()。两个concrete类继承EQPBuilder。</p>
<p>​    当我们需要获取不同数目的port的设备，这属于组装方面的范畴，所以我们将在LCDFactory中的createEQP中做。其UML类图如下:</p>
<p><img src="/images/BuilderEquipment_thumb.jpg" alt=""></p>
<h2 id="builder模式在使用的过程中需要注意的问题"><a href="#builder模式在使用的过程中需要注意的问题" class="headerlink" title="builder模式在使用的过程中需要注意的问题"></a>builder模式在使用的过程中需要注意的问题</h2><p>这里所说的注意的问题可能上面已经提到了，但是这里还是要着重强调一下，因为我们稍不注意，就可能将模式滥用，导致系统设计的失败。</p>
<ul>
<li>在builder模式中Builder一定不要定义纯虚函数成员函数，而是定义为空方法的虚函数，这样就可以使得客户可以只定义他们感兴趣的操作。</li>
<li>Director负责<strong>装配产品</strong>，concreteBuilder负责实现<strong>复杂产品部件的具体实现</strong></li>
<li>在Director中调用Builder的buildPart函数的时候，并不是每个函数都被调用，而是根据要生成的product对其选择性调用，可能调用零次，也可能调用多次。</li>
<li>Builder中的m_product声明为protected,即保证对象的封装性，又能让具体类方便的使用。(这是我在写代码的时候的解决方法，如果有更好的将m_product声明为private的解决方法欢迎交流2824759538@qq.com)</li>
</ul>
<h2 id="KFC套餐实例代码"><a href="#KFC套餐实例代码" class="headerlink" title="KFC套餐实例代码"></a>KFC套餐实例代码</h2><p>这是本人使用KFC服务员生成套餐时的一种模拟，其实实际情况中并不需要使用builder模式，但是这里为了练手强行写成了builder模式，希望大家不要吐槽。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//KFCWaiter.hpp 注意此处water相当于Director的作用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KFCWAITER_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KFCWAITER_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilder.hpp"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCWaiter</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setMealBuilder</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt; t_builder)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt; m_builder;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//KFCWaiter.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KFCWaiter.hpp"</span></span></div><div class="line"><span class="keyword">void</span> KFCWaiter::setMealBuilder(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt; t_builder) &#123;</div><div class="line">  m_builder = t_builder;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> KFCWaiter::construct() &#123;</div><div class="line">  m_builder-&gt;buildFood();</div><div class="line">  m_builder-&gt;buildDrink();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Meal.hpp Meal相当于Product</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MEAL_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MEAL_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Meal(<span class="built_in">std</span>::<span class="built_in">string</span> t_food = <span class="string">"hanbao"</span>, <span class="built_in">std</span>::<span class="built_in">string</span> t_drink = <span class="string">"kele"</span>);</div><div class="line">  ~Meal();</div><div class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getFood</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getDrink</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getMeal</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">buildFood</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t_food)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">buildDrink</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t_drink)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> m_food;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> m_drink;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Meal.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Meal.hpp"</span></span></div><div class="line">Meal::Meal(<span class="built_in">std</span>::<span class="built_in">string</span> t_food, <span class="built_in">std</span>::<span class="built_in">string</span> t_drink)</div><div class="line">    : m_food(t_food), m_drink(t_drink) &#123;&#125;</div><div class="line">Meal::~Meal() &#123;&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Meal::getFood() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_food; &#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Meal::getDrink() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_drink; &#125;</div><div class="line"><span class="keyword">void</span> Meal::getMeal() <span class="keyword">const</span> &#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"套餐为:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></div><div class="line">            &lt;&lt; <span class="string">"食物:"</span> &lt;&lt; m_food &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></div><div class="line">            &lt;&lt; <span class="string">"饮料:"</span> &lt;&lt; m_drink &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> Meal::buildFood(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t_food) &#123; m_food = t_food; &#125;</div><div class="line"><span class="keyword">void</span> Meal::buildDrink(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t_drink) &#123; m_drink = t_drink; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilder.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BUILDER_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUILDER_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Meal.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MealBuilder();</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildFood</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildDrink</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt; getResult();</div><div class="line">  <span class="keyword">virtual</span> ~MealBuilder()&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt; m_meal;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilder.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilder.hpp"</span></span></div><div class="line">MealBuilder::MealBuilder() : m_meal(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt;(<span class="keyword">new</span> Meal())) &#123;&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt; MealBuilder::getResult() &#123; <span class="keyword">return</span> m_meal; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilderA.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MEALBUILDERA_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MEALBUILDERA_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilder.hpp"</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MealBuilderA</span> :</span> <span class="keyword">public</span> MealBuilder &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildFood</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildDrink</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilderA.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilderA.hpp"</span></span></div><div class="line"><span class="keyword">void</span> MealBuilderA::buildFood() &#123; m_meal-&gt;buildFood(<span class="string">"套餐A食物"</span>); &#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> MealBuilderA::buildDrink() &#123; m_meal-&gt;buildDrink(<span class="string">"套餐A饮料"</span>); &#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilderB.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MEALBUILDERB_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MEALBUILDERB_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilder.hpp"</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MealBuilderB</span> :</span> <span class="keyword">public</span> MealBuilder &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildFood</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildDrink</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilderB.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilderB.hpp"</span></span></div><div class="line"><span class="keyword">void</span> MealBuilderB::buildFood() &#123; m_meal-&gt;buildFood(<span class="string">"套餐B食物"</span>); &#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> MealBuilderB::buildDrink() &#123; m_meal-&gt;buildDrink(<span class="string">"套餐B饮料"</span>); &#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KFCWaiter.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilderA.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilderB.hpp"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt; Aptr =</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt;(<span class="keyword">new</span> MealBuilderA());</div><div class="line">  KFCWaiter k;</div><div class="line">  k.setMealBuilder(Aptr);</div><div class="line">  k.construct();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt; current_meal = Aptr-&gt;getResult();</div><div class="line"></div><div class="line">  current_meal-&gt;getMeal();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/08/创建型设计模式之build模式/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/07/UML时序图详解/">
                            UML时序图详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-07T15:17:23+08:00">
	
		    1月 07, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/设计模式之路/">设计模式之路</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="UML时序图详解"><a href="#UML时序图详解" class="headerlink" title="UML时序图详解"></a>UML时序图详解</h1><p>　　这几天在阅读《设计模式》一书，书中总结了前人在面向对象软件设计过程中针对特定的问题提出的简洁而优雅的解决方案。在阅读的过程中，我一边理解书中给出的实例，一边结合自己写过的项目或者用过的框架与当前模式进行对比，发现之前的项目有一些还是有很大的改进空间。在阅读本书的过程中，书中很多例子都是通过UML类图和UML时序图进行说明，所以，理解这些例子的前提是对UML类图以及UML时序图有一定的了解，UML类图在前面的博客(<a href="https://langzi989.github.io/2017/01/05/UML%E5%9B%BE%E8%A1%A8%E7%A4%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/)中已经讲解，现在我们主要来看一下UML时序图中的重要概念。" target="_blank" rel="external">https://langzi989.github.io/2017/01/05/UML%E5%9B%BE%E8%A1%A8%E7%A4%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/)中已经讲解，现在我们主要来看一下UML时序图中的重要概念。</a></p>
<p>　　UML类关系以及时序图在大三上《系统分析与设计》课的时候学过，但是那个时候不知道这东西有什么用，所以没有认真学和理解。随着实战经验的增多，越来越能体会到这些在软件设计的过程中重中之重，不管是描述你的设计思想还是与团队中其他人进行交流。所以还是建议大家在学到这一部分的时候对这门课认真对待。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>时序图是一种按照时间顺序显示对象之间的交互的图。时序图中显示的是参与交互的对象和对象之间消息传递的顺序。</p>
<h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><p>时序图中包含的主要的元素有:</p>
<ul>
<li>角色(Actor)</li>
<li>对象(Object)</li>
<li>生命线(life line)</li>
<li>控制焦点(focus of control)</li>
<li>消息(message)</li>
<li>自关联消息(self-associated message)</li>
<li>组合片段(combined fragment)</li>
</ul>
<h2 id="基本元素详解"><a href="#基本元素详解" class="headerlink" title="基本元素详解"></a>基本元素详解</h2><h3 id="角色-actor"><a href="#角色-actor" class="headerlink" title="角色(actor)"></a>角色(actor)</h3><p>角色指的是系统角色，这个角色可以是人，其他系统或者子系统</p>
<p>图形表示:</p>
<p><img src="/images/actor.png" alt=""></p>
<h3 id="对象-object"><a href="#对象-object" class="headerlink" title="对象(object)"></a>对象(object)</h3><p>对象包括三种:</p>
<ul>
<li>指定类名和对象名的对象objectName: className</li>
<li>指定类名但没有对象名的对象(匿名对象) :className</li>
<li>指定对象名但不指定类名的对象 objectName</li>
</ul>
<p>图形表示：<br>第一类:</p>
<p><img src="/images/object1.png" alt=""></p>
<p>第二类:</p>
<p><img src="/images/object2.png" alt=""></p>
<p>第三类:</p>
<p><img src="/images/object3.png" alt=""></p>
<h3 id="生命线-life-line"><a href="#生命线-life-line" class="headerlink" title="生命线(life line)"></a>生命线(life line)</h3><p>生命线在时序图中使用向下的虚线表示,它指的是其所对应的对象的存活时间。从上到下表示时间的推后。</p>
<p>图像表示:</p>
<p><img src="/images/lifeline.png" alt=""></p>
<h3 id="控制焦点-focus-of-control"><a href="#控制焦点-focus-of-control" class="headerlink" title="控制焦点(focus of control)"></a>控制焦点(focus of control)</h3><p>控制焦点在时序图中以方块的形式出现，它是一种表示时间段的方式，对象在这一时间段中执行相应的操作。</p>
<p>图像表示:</p>
<p><img src="/images/control.png" alt=""></p>
<h3 id="消息-message"><a href="#消息-message" class="headerlink" title="消息(message)"></a>消息(message)</h3><p>消息有三种类型</p>
<ul>
<li>同步消息：发送者发送请求后被阻塞，直到接受者返回消息或者做完其他处理之后发送者才能继续执行之后的操作</li>
<li>异步消息：发送者发送消息给接受者之后不等待接受者返回响应而继续执行下面的操作。</li>
<li>返回消息:接受者返回消息给发送者</li>
</ul>
<p>消息的图形表示：<br>同步消息:</p>
<p><img src="/images/message1.png" alt=""></p>
<p>异步消息:</p>
<p><img src="/images/message2.png" alt=""></p>
<p>返回消息:</p>
<p><img src="/images/message3.png" alt=""></p>
<h3 id="自关联消息-self-associated-message"><a href="#自关联消息-self-associated-message" class="headerlink" title="自关联消息(self-associated message)"></a>自关联消息(self-associated message)</h3><p>自关联消息一般指的是当前类调用自己的函数的情况</p>
<h3 id="组合片段-combined-fragment"><a href="#组合片段-combined-fragment" class="headerlink" title="组合片段(combined fragment)"></a>组合片段(combined fragment)</h3><p>组合片段中包括四个部分:</p>
<ul>
<li><p>Alternative fragment(alt表示):与if…then…else…对应</p>
</li>
<li><p>option fragment(opt表示):与switch对应</p>
</li>
<li><p>parallel fragment(par表示):表示同时发生</p>
</li>
<li><p>Loop Fragment(loop表示):与循环对应</p>
<p>图形表示:</p>
<p>alt:</p>
<p><img src="/images/alt.png" alt=""></p>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/07/UML时序图详解/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/05/UML图表示常见的类之间的关系/">
                            UML图表示常见的类之间的关系
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-05T21:12:28+08:00">
	
		    1月 05, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/设计模式之路/">设计模式之路</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="UML图表示常见的类之间的关系"><a href="#UML图表示常见的类之间的关系" class="headerlink" title="UML图表示常见的类之间的关系"></a>UML图表示常见的类之间的关系</h1><p>类之间的关系常见的主要包括以下几种:</p>
<ul>
<li>继承</li>
<li>实现</li>
<li>依赖</li>
<li>关联</li>
<li>聚合</li>
<li>组合</li>
</ul>
<h2 id="继承（inheritance）"><a href="#继承（inheritance）" class="headerlink" title="继承（inheritance）"></a>继承（inheritance）</h2><p>继承的概念大家都比较熟悉，他主要指的是派生类继承父类或者接口之间的继承，派生类继承了父类中原有的功能，并在此基础上添加了新的功能。例如public继承实质上是一种is-a的关系,(子类is a 基类)</p>
<p>图形表示:</p>
<p><img src="/images/继承.png" alt=""></p>
<h2 id="实现-implement"><a href="#实现-implement" class="headerlink" title="实现(implement)"></a>实现(implement)</h2><p>实现指的是一个类实现一个接口,一个类可以实现一个或者多个接口。实现是类和接口之间常见的一种关系。在java中通常通过implements实现。</p>
<p>图形表示：</p>
<p><img src="/images/实现.png" alt=""></p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>依赖指的是一个类A使用另外一个类B,这种该使用关系是偶然性的，临时的，非常弱的一种关系。但是类B的变化会影响到类A;比如人要使用船过河中，这个时候人和船就是一种依赖关系。具体表现在代码中就是<strong>B是类A中的某个方法的参数。</strong></p>
<p>图形表示:</p>
<p><img src="/images/依赖.png" alt=""></p>
<h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>关联是指俩个类之间的或者类和接口之间的一种强依赖关系。而这种强依赖关系不是偶然性的，而是长期的，而且双方的关系是平等的，关联可以是单向的，也可以是双向的。具体表现在代码中是<strong>(1):B以类属性的方式出现在类A中（２）A引用类型为B的全局变量</strong></p>
<p>图形表示:</p>
<p><img src="/images/关联.png" alt=""></p>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合是关联关系的一种特例，它表现的是一种has-a的关系，即整体与部分的关系，此时整体与部分可以是分离的，他们可以具有各自的声明周期，部分可以属于多个整体对象，也可以被多个整体对象共享；如计算机与CPU的关系<strong>聚合中部分和整体都有各自的生命周期，并且互相影响</strong></p>
<p>图形表示：</p>
<p><img src="/images/聚合.png" alt=""></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>组合也是关联的一种特例，它体现的是一种contain-a的关系，这种关系比聚合强；这个时候整体和部分是不可分离的，<strong>整体的声明周期与部分的声明周期相同，当整体的周期结束时，部分的周期也随之结束</strong>。如人和大脑的关系</p>
<p>图形表示：</p>
<p><img src="/images/组合.png" alt=""></p>
<h2 id="依赖性强弱"><a href="#依赖性强弱" class="headerlink" title="依赖性强弱:"></a>依赖性强弱:</h2><p>组合&gt;聚合&gt;关联&gt;依赖</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/05/UML图表示常见的类之间的关系/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/page/5/">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>NEWER POSTS</span>
            </a>
        </li>
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/page/7/">
                    <span>OLDER POSTS</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">page 6 of 8</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 魏传柳(2824759538@qq.com). All Rights Reserved.
    </span>
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
     </script>
   </br></br>本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avar.jpg"/>
        
            <h4 id="about-card-name">魏传柳(2824759538@qq.com)</h4>
        
            <h5 id="about-card-bio"><p>author.bio</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Guangzhou,China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script-i4qo6jx6jji9fg0dftpya6ivemizsbow4fhow76d8dwpm7m1wbvi378ssumx.min.js"></script>
<!--SCRIPTS END-->



</html>
