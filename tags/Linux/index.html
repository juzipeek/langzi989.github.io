
<!DOCTYPE html>
<html lang="zh-CN">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="魏传柳">
    <title>Tag: Linux - 魏传柳</title>
    <meta name="author" content="魏传柳(2824759538@qq.com)">
    
        <meta name="keywords" content="hexo,javascript,">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="魏传柳">
<meta property="og:url" content="http://yoursite.com/tags/Linux/index.html">
<meta property="og:site_name" content="魏传柳">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="魏传柳">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/avar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-nuvue6sithwirecbhvw3dkaobiojqvtadsnhguwi7k04xklybw5djl1smadp.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">魏传柳</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avar.jpg"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avar.jpg"/>
            </a>
            <span class="sidebar-profile-name">魏传柳(2824759538@qq.com)</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">categories</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">archives</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">search</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">about</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/langzi989" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://blog.csdn.net/u014630623" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-csdn"></i>
                    <span class="sidebar-button-desc">CSDN</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/10/06/汇编基础之寄存器与简单指令分析/">
                            汇编基础之寄存器及汇编指令
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-10-06T19:00:48+08:00">
	
		    10月 06, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/汇编/">汇编</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="汇编基础之寄存器及汇编指令"><a href="#汇编基础之寄存器及汇编指令" class="headerlink" title="汇编基础之寄存器及汇编指令"></a>汇编基础之寄存器及汇编指令</h1><blockquote>
<p>参考链接:<br><a href="http://www.cnblogs.com/technology/archive/2010/05/16/1736782.html" target="_blank" rel="external">http://www.cnblogs.com/technology/archive/2010/05/16/1736782.html</a><br><a href="http://anonymalias.github.io/2017/01/09/ucontext-theory/" target="_blank" rel="external">http://anonymalias.github.io/2017/01/09/ucontext-theory/</a></p>
</blockquote>
<p>最近在学习协程方面的知识,在协程的一种实现方式中有一种是用汇编实现的,所以这里再把汇编知识复习一下。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器按照其用途可分为以下4类:</p>
<ul>
<li>数据寄存器</li>
<li>指针及变址寄存器</li>
<li>段寄存器</li>
<li>控制寄存器</li>
</ul>
<h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>数据寄存器包括４个16位的寄存器(AX,BX,CX,DX)或者8个8位的寄存器(AH,AL,BH,BL,CH,CL,DH,DL)，这些寄存器都是用来暂时存放操作数，运算结果或者其他信息，但同时又具有某些专门的用途。</p>
<ul>
<li>AX(累加寄存器):算术运算中的主要寄存器,在乘除运算中用来指定除数和被除数,也是乘除运算后积和商的默认存储单元。,另外<strong>IO指令均使用该寄存器与IO设备传送信息</strong></li>
<li>BX(基址寄存器):指令寻址时常用作基址寄存器，存入偏移量或者偏移量的构成部分。</li>
<li>CX(计数寄存器):在循环指令操作或者串处理指令中隐含计数</li>
<li>DX(数据寄存器):在双字节运算中，与AX构成32位操作数，DX为高16位。在某些IO指令中,DX被用来存放端口地址</li>
</ul>
<h3 id="指针及变址寄存器"><a href="#指针及变址寄存器" class="headerlink" title="指针及变址寄存器"></a>指针及变址寄存器</h3><p>这些寄存器都是16位的寄存器,用来存放16为的操作数或者中间结果，但是更常见的是存放偏移量或者位移量</p>
<ul>
<li>SP(堆栈指针寄存器):指向栈顶的位置,与SS寄存器一起组成栈顶数据的物理地址</li>
<li>BP(基址指针寄存器):系统默认其指向堆栈中的某一单元，即提供栈中该单元偏移量，加段前缀后，BP可作为非堆栈段的地址指针。一般用于识别栈帧的起始位置。</li>
<li>SI(源变址寄存器):与DS联用, 指示数据段中某操作的偏移量. 在做串处理时, SI指示源操作数地址, 并有自动增量或自动减量的功能. 变址寻址时, SI与某一位移量共同构成操作数的偏移量</li>
<li>DI(目的变址寄存器):与DS联用, 指示数据段中某操作数的偏移量, 或与某一位移量共同构成操作数的偏移量. 串处理操作时, DI指示附加段中目的地址, 并有自动增量或减量的功能</li>
</ul>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><ul>
<li>CS(代码段):存放当前程序的指令代码</li>
<li>DS(数据段):存放程序所涉及的源数据以及结果</li>
<li>SS(堆栈段):以先进后出原则的数据区</li>
<li>ES(附加段):辅助数据区，存放串或者其他数据</li>
</ul>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><ul>
<li>IP（指令寄存器）: 存放下一条要执行的指令的偏移量</li>
<li>FR(控制标志位):<ul>
<li>CF(进位标识位):进行加减运算时, 如果最高二进制位产生进位或错位, CF则为1, 否则为0. 程序设计中, 常用条件转移指令JC, JNC指令据此标志位实现转移</li>
<li>PF(奇偶标志位):操作结果中二进制位1的个数为偶数是, PF为1, 某则为0</li>
<li>AF(辅助进位标志位):运算时半字节产生进位或借位时, AF为1, 某则为0. 主要用于BCD码的调整</li>
<li>ZF(零标志位):运算结果为0时, ZF为1, 否则为0</li>
<li>SF(符号标志位):当运算结果的最高位为1时, SF为1, 否则为0. 最高位表示符号数的正和负</li>
<li>TF(跟踪标志位):用于调试程序时进入单步方式工作. TF=1时, 每条指令执行完后产生一个内部中断, 让用户检查指令运行后寄存器, 存储器和各标志位的内容. TF=0时, CPU工作正常, 不产生内部中断</li>
<li>IF(中断允许标志位):IF=1同时中断屏蔽寄存器的相应位为0, 允许系统响应可屏蔽中断, 反之, 不接收外部发出的中断请求</li>
<li>DF(方向位标志位):用于控制串操作时地址指针位移方向. 当DF=1时, 指针向高地址方向移动</li>
<li>OF(溢出标志位):算术运算时结果超出系统所能表示的数的范围. 溢出时, OF=1</li>
</ul>
</li>
</ul>
<p>注意:上述为16位处理其器中的寄存器的名字，在32和64位系统中，寄存器中名字有相应的变化，具体看下面(32位在前面加E,64在前面加R，64位系统的中含有16个64位的通用寄存器):</p>
<p><img src="/images/register.png" alt=""></p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="汇编指令格式"><a href="#汇编指令格式" class="headerlink" title="汇编指令格式"></a>汇编指令格式</h3><p>汇编指令的格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[标号:]　指令助记符[[目的操作数][,源操作数]][;注释]</div></pre></td></tr></table></figure></p>
<ul>
<li>指令助记符:如MOV,ADD之类标识传送,加法。不区分大小写</li>
<li>目的操作数:作用有两个,1.参与指令操作2,暂时存储操作结果</li>
<li>源操作数:主要提供原始数据或操作对象。面向所有寻址方式</li>
<li>注释:用分号隔开</li>
</ul>
<p>汇编指令中常见的符号:</p>
<ul>
<li>imme:立即数</li>
<li>DST:目的操作数</li>
<li>SRC:源操作数</li>
<li>mem:存储器操作数</li>
<li>OPR:操作数</li>
<li>reg:通用寄存器</li>
<li>EA:偏移地址</li>
<li>Sreg:段寄存器</li>
<li>Port:端口地址</li>
<li>Lable:标号</li>
</ul>
<p>汇编指令可以分成六类:</p>
<ul>
<li>数据传送指令</li>
<li>算数运算指</li>
<li>逻辑运算与移位指令</li>
<li>串操作指令</li>
<li>程序控制指令</li>
<li>处理器控制指令<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><h4 id="数据传送指令-1"><a href="#数据传送指令-1" class="headerlink" title="数据传送指令"></a>数据传送指令</h4></li>
<li>MOV DST,SRC(传送指令):把源操作数的内容送入目的操作数<ul>
<li>立即数做源操作数时,立即数的长度必须小于等于目的操作数的长度</li>
<li>操作数分别为reg,reg或reg,sreg或sreg,sreg或reg,sreg时，两者的长度必须保持一致</li>
<li>立即数不能作为目的操作数</li>
<li>CS和IP寄存器不能做目的操作数,不允许用立即数为段寄存器赋值</li>
<li>不能将一个段寄存器的内容直接送到另一个段寄存器中, 可借助通用寄存器或PUSH, POP指令实现这一要求</li>
</ul>
</li>
<li>PUSH SRC(压栈指令): 将一个字数据压入当前栈顶, 位移量disp=-2的地址单元. 数据进栈时, 栈指针SP首先向低地址方向移动两个字节位置, 接着数据进栈, 形成新的栈顶</li>
<li>POP DST(出栈指令):弹出栈顶元素, 后将栈顶指针向栈底方向移动一个字</li>
<li>XCHG OPR1, OPR2(交换指令):交换指令: 将这两个操作数交换</li>
</ul>
<h4 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h4><ul>
<li>LEA DST, SRC(装载有效指令):该指令将源操作数的偏移量OA装载到目的操作数中</li>
<li>LDS DST, SRC(装载数据段指针指令):将当前数据段中的一个双字数据装入到一个通用寄存器SI(双字数据的低字)和数据段寄存器DS(双字数据的高字)中</li>
<li>LES DST,SRC(装载附加段指针指令):将附加数据段中的一个32位地址数据指针(附加段指针)送到DI(低字)和ES(高字)寄存器中</li>
</ul>
<h4 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h4><ul>
<li>LAHF(标志寄存器送AH指令): 将标志寄存器的低字节送入AH中</li>
<li>SAHF(AH送标志寄存器指令): 将AH寄存器内容送标志寄存器FR的低字节</li>
<li>PUSHF(标志进栈指令): 标志寄存器进栈</li>
<li>POPF (标志出栈指令): 标志寄存器出栈</li>
</ul>
<h4 id="累加器专用传送指令"><a href="#累加器专用传送指令" class="headerlink" title="累加器专用传送指令"></a>累加器专用传送指令</h4><ul>
<li>IN   AL, Port:从端口读入数据, 存放在AL中</li>
<li>OUT PORT,AL:传送AL中的数据到端口</li>
<li>XLAT OPR或XLAT:用于将AL中当前内容转换为一种代码</li>
</ul>
<h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><h4 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h4><ul>
<li>ADD DST, SRC:DST+SRC的和存放到DST中去</li>
<li>ADC DST, SRC:带进位加法指令, DST+SRC+CF</li>
<li>INC DST:增1指令</li>
</ul>
<h4 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h4><ul>
<li>SUB DST, RSC:DST-SRC, 存放到DST中</li>
<li>SBB DST, SRC:带借位减法指令, DST-SRC-CF</li>
<li>DEC DST :减1指令</li>
<li>NEG DST:求补指令, 求补码</li>
<li>CMP OPR1, OPR2:比较指令</li>
</ul>
<h4 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h4><ul>
<li>MUL SRC:无符号数乘指令, AL*SRC, 结果放入AX中</li>
<li>IMUL SRC:有符号数乘指令, AL*SRC, 结果放入AX中</li>
</ul>
<h4 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h4><ul>
<li>DIV SRC :无符号数除指令, AX/SRC, 商放入AL中, 余数放在AH中</li>
<li>IDIV SRC:符号数除指令, AX/SRC, 上放入AL中, 余数放在AH中</li>
<li>CBW, CWD:都是符号扩展指令. 将AL的符号扩到AX中; 将AX的符号扩到DX</li>
</ul>
<h3 id="逻辑运算与移位指令"><a href="#逻辑运算与移位指令" class="headerlink" title="逻辑运算与移位指令"></a>逻辑运算与移位指令</h3><h4 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h4><ul>
<li>NOT OPR:逻辑非指令</li>
<li>AND OPR:逻辑与指令</li>
<li>OR OPR:逻辑或指令</li>
<li>XOR OPR :逻辑异或指令</li>
</ul>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令:"></a>移位指令:</h4><ul>
<li>SHL DST, CNT:逻辑左移</li>
<li>SHR DST, CNT:逻辑右移</li>
<li>SAL DST, CNT:算术左移</li>
<li>SAR DST, CNT:算术右移</li>
</ul>
<h4 id="循环移位指令"><a href="#循环移位指令" class="headerlink" title="循环移位指令"></a>循环移位指令</h4><ul>
<li>ROL              DST, CNT:循环左移</li>
<li>ROR       DST, CNT:循环右移</li>
<li>RCL        DST, CNT:带进位循环左移</li>
<li>RCR              DST, CNT:带进位循环右移</li>
</ul>
<h3 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h3><ul>
<li>MOVS:串传送指令</li>
<li>CMPS:串比较指令</li>
<li>SCAS:串扫描指令</li>
<li>LODS:装入串指令</li>
<li>STOS:存储串指令</li>
</ul>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><h4 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令:"></a>转移指令:</h4><ul>
<li>JMP:无条件转移指令</li>
<li>JX:条件转移指令(JC/JNC, JZ/JNZ, JE/JNE, JS/JNS, JO/JNO, JP/JNP…)</li>
</ul>
<h4 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h4><ul>
<li>LOOP 标号:该指令执行时, 技术寄存器CXX首先减1, 然后判断CX, 若为0, 跳出循环</li>
</ul>
<h4 id="条件循环指令"><a href="#条件循环指令" class="headerlink" title="条件循环指令"></a>条件循环指令</h4><ul>
<li>LOOPZ/LOOPE, LOOPNZ/LOOPNE:前者用于找到第一个不为0的事件, 后者用于找到第一个为0的事件</li>
</ul>
<h4 id="子程序调用指令"><a href="#子程序调用指令" class="headerlink" title="子程序调用指令"></a>子程序调用指令</h4><ul>
<li>CALL  子程序名:段内直接调用</li>
<li>RET</li>
</ul>
<h4 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h4><ul>
<li>INT N(中断类型号):软中断指令</li>
<li>IRET:中断返回指令</li>
</ul>
<h3 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h3><h4 id="标志处理指令"><a href="#标志处理指令" class="headerlink" title="标志处理指令:"></a>标志处理指令:</h4><ul>
<li>CLC:进位标志CF置0</li>
<li>CMC:进位标志CF求反</li>
<li>STC:进位标志值1</li>
<li>CLD:方向标志置0</li>
<li>STD:方向标志置1</li>
<li>CLI:中断允许标志置0</li>
<li>STI:中断允许标志置1</li>
</ul>
<h4 id="其他处理器控制指令"><a href="#其他处理器控制指令" class="headerlink" title="其他处理器控制指令:"></a>其他处理器控制指令:</h4><ul>
<li>NOP:空操作</li>
<li>HLT:停机</li>
<li>WAIT:等待</li>
<li>ESC:换码</li>
<li>LOCK:封锁</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/10/06/汇编基础之寄存器与简单指令分析/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/10/06/C++协程实现/">
                            C++协程实现及原理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-10-06T17:00:48+08:00">
	
		    10月 06, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="C-协程及其原理"><a href="#C-协程及其原理" class="headerlink" title="C++协程及其原理"></a>C++协程及其原理</h1><h2 id="协程的几种实现方式及原理"><a href="#协程的几种实现方式及原理" class="headerlink" title="协程的几种实现方式及原理"></a>协程的几种实现方式及原理</h2><p>协程又可以称为用户线程,微线程，可以将其理解为单个进程或线程中的多个<strong>用户态线程</strong>，这些微线程在用户态进程控制和调度.协程的实现方式有很多种，包括</p>
<ol>
<li>使用glibc中的ucontext库实现</li>
<li>利用汇编代码切换上下文</li>
<li>利用C语言语法中的switch-case的奇淫技巧实现(protothreads)</li>
<li>利用C语言的setjmp和longjmp实现</li>
</ol>
<p>实际上，无论是上述那种方式实现协程,其原理是相同的，都是通过保存和恢复寄存器的状态，来进行各协程上下文的保存和切换。</p>
<h2 id="协程较于函数和线程的优点"><a href="#协程较于函数和线程的优点" class="headerlink" title="协程较于函数和线程的优点"></a>协程较于函数和线程的优点</h2><ul>
<li>相比于函数:协程避免了传统的函数调用栈，几乎可以无限地递归</li>
<li>相比与线程:协程没有内核态的上下文切换，近乎可以无限并发。协程在用户态进程显式的调度，可以把异步操作转换为同步操作，也意味着不需要加锁,避免了加锁过程中不必要的开销。</li>
</ul>
<p>进程,线程以及协程的设计都是为了并发任务可以更好的利用CPU资源，他们之间最大的区别在于CPU资源的使用上:</p>
<ul>
<li>进程和线程的任务调度是由内核控制的，是抢占式的；</li>
<li>协程的任务调度是在用户态完成,需要代码里显式地将CPU交给其他协程,是协作式的</li>
</ul>
<p>由于我们可以在用户态调度协程任务，所以我们可以把<strong>一组相互依赖的任务设计为协程。这样,当一个协程任务完成之后,可以手动的进行任务切换，把当前任务挂起(yield),切换到另一个协程区工作</strong>.由于我们可以控制程序主动让出资源，很多情况下将不需要对资源进行加锁。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/10/06/C++协程实现/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/10/06/ucontext函数详解/">
                            ucontext族函数详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-10-06T16:00:48+08:00">
	
		    10月 06, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="ucontext族函数详解"><a href="#ucontext族函数详解" class="headerlink" title="ucontext族函数详解"></a>ucontext族函数详解</h1><blockquote>
<p>the ucontext_t type is a structure type suitable for holding the context for the user thread of execution. A thread’s context include stack,saved registersm a list of block signals</p>
<p>上述为ncontext_t结构体的定义，ucontext机制是GNU C库提供的一组创建，保存，切换用户态执行上下文的API，从上面的描述可以看出ucontext_t结构体使得用户在程序中保存当前的上下文成为可能。我们也可以利用此实现用户级线程，即协程。</p>
</blockquote>
<h2 id="ucontext-t以及ucontext族函数"><a href="#ucontext-t以及ucontext族函数" class="headerlink" title="ucontext_t以及ucontext族函数"></a>ucontext_t以及ucontext族函数</h2><h3 id="ucontext-t结构体"><a href="#ucontext-t结构体" class="headerlink" title="ucontext_t结构体"></a>ucontext_t结构体</h3><p>ucontext_t结构体定义,一个ucontext_t至少包括以下四个成员,可能依据不同系统包括其他不同的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> &#123;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span>* <span class="title">uc_link</span>;</span></div><div class="line">  <span class="keyword">sigset_t</span> uc_sigmask;</div><div class="line">  <span class="keyword">stack_t</span> uc_stack;</div><div class="line">  <span class="keyword">mcontext_t</span> uc_mcontext;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>类成员解释:</p>
<ul>
<li>uc_link:为当前context执行结束之后要执行的下一个context，若uc_link为空，执行完当前context之后退出程序。</li>
<li>uc_sigmask : 执行当前上下文过程中需要屏蔽的信号列表，即信号掩码</li>
<li>uc_stack : 为当前context运行的栈信息。</li>
<li>uc_mcontext : 保存具体的程序执行上下文，如PC值，堆栈指针以及寄存器值等信息。它的实现依赖于底层，是平台硬件相关的。此实现不透明。</li>
</ul>
<h3 id="ucontext族函数"><a href="#ucontext族函数" class="headerlink" title="ucontext族函数"></a>ucontext族函数</h3><p>ucontext族函数主要包括以下四个:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;ucontext.h&gt;</div><div class="line">void makecontext(ucontext_t* ucp, void (*func)(), int argc, ...);</div><div class="line">int swapcontext(ucontext_t* olducp, ucontext_t* newucp);</div><div class="line">int getcontext(ucontext_t* ucp);</div><div class="line">int setcontext(const ucontext_t* ucp);</div></pre></td></tr></table></figure></p>
<ul>
<li>makecontext:初始化一个ucontext_t,func参数指明了该context的入口函数，argc为入口参数的个数，每个参数的类型必须是int类型。另外在makecontext之前，一般需要显示的初始化栈信息以及信号掩码集同时也需要初始化uc_link，以便程序退出上下文后继续执行。</li>
<li>swapcontext:原子操作，该函数的工作是保存当前上下文并将上下文切换到新的上下文运行。</li>
<li>getcontext:将当前的执行上下文保存在ucp中，以便后续恢复上下文</li>
<li>setcontext : 将当前程序切换到新的context,在执行正确的情况下该函数直接切换到新的执行状态，不会返回。</li>
</ul>
<blockquote>
<p>注意:setcontext执行成功不返回，getcontext执行成功返回0，若执行失败都返回-1。若uc_link为NULL,执行完新的上下文之后程序结束。</p>
</blockquote>
<h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">newContextFun</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is the new context"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> <span class="built_in">stack</span>[<span class="number">10</span>*<span class="number">1204</span>];</div><div class="line"></div><div class="line">  <span class="comment">//get current context</span></div><div class="line">  <span class="keyword">ucontext_t</span> curContext;</div><div class="line">  getcontext(&amp;curContext);</div><div class="line"></div><div class="line">  <span class="comment">//modify the current context</span></div><div class="line">  <span class="keyword">ucontext_t</span> newContext = curContext;</div><div class="line">  newContext.uc_stack.ss_sp = <span class="built_in">stack</span>;</div><div class="line">  newContext.uc_stack.ss_size = <span class="keyword">sizeof</span>(<span class="built_in">stack</span>);</div><div class="line">  newContext.uc_stack.ss_flags = <span class="number">0</span>;</div><div class="line"></div><div class="line">  newContext.uc_link = &amp;curContext;</div><div class="line"></div><div class="line">  <span class="comment">//register the new context</span></div><div class="line">  makecontext(&amp;newContext, (<span class="keyword">void</span>(*)(<span class="keyword">void</span>))newContextFun, <span class="number">0</span>);</div><div class="line">  swapcontext(&amp;curContext, &amp;newContext);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"main\n"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/10/06/ucontext函数详解/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/09/20/UnixIPC关联数据结构与对象权限/">
                            UnixIPC 关联数据结构与对象权限
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-09-20T20:09:08+08:00">
	
		    9月 20, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="UnixIPC-关联数据结构与对象权限"><a href="#UnixIPC-关联数据结构与对象权限" class="headerlink" title="UnixIPC 关联数据结构与对象权限"></a>UnixIPC 关联数据结构与对象权限</h1>
                    
                        
                    
                    
                        <p>
                            <a href="/2017/09/20/UnixIPC关联数据结构与对象权限/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/09/20/UnixIPC中key_t类型本质/">
                            UnixIPC 机制和key_t本质类型
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-09-20T20:09:08+08:00">
	
		    9月 20, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="System-V-IPC-机制和key-t本质类型"><a href="#System-V-IPC-机制和key-t本质类型" class="headerlink" title="System V IPC 机制和key_t本质类型"></a>System V IPC 机制和key_t本质类型</h1><h2 id="System-V三种IPC机制"><a href="#System-V三种IPC机制" class="headerlink" title="System V三种IPC机制"></a>System V三种IPC机制</h2><p>System V IPC包括三种不同的通信机制</p>
<ul>
<li>消息队列:消息队列类似于管道,但是又有很大的差别。第一,消息队列是有边界的，所以消息队列的通信机制是通过消息进行传递，而管道是通过字节流进行通信。第二，每条消息包括一个完整的整形字段，消息队列可以通过类型来选择消息。</li>
<li>信号量:用于同步两个进程。</li>
<li>共享内存:共享内存允许两个进程共享同一个内存段。即一块内存被映射到不同进程的虚拟内存中。</li>
</ul>
<h2 id="key-t本质"><a href="#key-t本质" class="headerlink" title="key_t本质"></a>key_t本质</h2><p>System V系统调用都有一个相关的get系统调用，它与文件io中的open函数类似，不同的是它的参数是一个整数，给定一个整数之后，系统会做以下操作:</p>
<ul>
<li>使用给定key创建一个新的IPC对象，并将IPC对象标识key_t返回给调用者.</li>
<li>若该key对应的IPC对象存在，直接将标识返回给调用者，相当于使用key换取标识,而不做创建操作.</li>
</ul>
<p>上述IPC对象的标识类型为key_t。key_t的本质是什么?我们可以通过grep命令追踪到</p>
<p>在文件/usr/include/sys/ipc.h中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#ifndef __key_t_defined</div><div class="line">typedef __key_t key_t;</div><div class="line"># define __key_t_defined</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>在文件/usr/include/bits/types.h中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__STD_TYPE __KEY_T_TYPE __key_t;        /* Type of an IPC key.  */</div></pre></td></tr></table></figure></p>
<p>在文件/usr/include/bits/typesizes.h中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define __KEY_T_TYPE            __S32_TYPE</div></pre></td></tr></table></figure>
<p>在文件中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define __S32_TYPE              int</div></pre></td></tr></table></figure>
<p>故从上面的追踪，可以看出key_t的本质为int类型.</p>
<h2 id="获取key-t方法"><a href="#获取key-t方法" class="headerlink" title="获取key_t方法"></a>获取key_t方法</h2><p>获取ket_t的方法三种</p>
<ul>
<li>随机选取一个整数值作为key值，多个进程共享一个key值。注意此时不能使用已经存在的key</li>
<li>在创建IPC对象的get方法中用IPC_PRIVATE作为key值，这样会导致每个调用都会创建一个新的IPC对象</li>
<li>使用ftok函数生成一个key,这个方法产生的key接近唯一。</li>
</ul>
<h3 id="IPC-PRIVATE"><a href="#IPC-PRIVATE" class="headerlink" title="IPC_PRIVATE"></a>IPC_PRIVATE</h3><p>IPC_PRIVATE本质上为0的宏定义.使用方法是直接使用IPC_PRIVATE作为key生成一个IPC对象。这种做法保证每次产生的都是全新的IPC对象。<br>这种做法适用于在父进程fork前创建IPC对象，从而达到子进程继承IPC对象的目的。</p>
<h3 id="ftok生成key"><a href="#ftok生成key" class="headerlink" title="ftok生成key"></a>ftok生成key</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型:"></a>函数原型:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></div><div class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">char</span>* pathname, <span class="keyword">int</span> proj);</div></pre></td></tr></table></figure>
<h4 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能:"></a>函数功能:</h4><p>此函数的功能是根据pathname和proj的值生成key，该算法只使用proj的最低的8个有效位，应用程序必须确保pathname引用一个可以应用stat()的既有文件。否则该函数会返回-1。</p>
<p>在linux中，key_t一般是32位的值。它通过取<strong>proj参数的最低８个有效位，包含该文件所属的文件系统的设备的设备号的最低8个有效位以及pathname所引用文件的inode号的最低16个有效位组合而成，这样保证了唯一性</strong>。所以从上面可以看出，对于同意个文件的不同路径(inode值相同),proj值相同，此时产生的key是相同的。　</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/09/20/UnixIPC中key_t类型本质/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/09/10/Unix高级编程之signal/">
                            Unix高级编程之signal
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-09-10T05:24:40+08:00">
	
		    9月 10, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Unix高级编程之signal"><a href="#Unix高级编程之signal" class="headerlink" title="Unix高级编程之signal"></a>Unix高级编程之signal</h1><p>signal函数相关的细节描述详见另外两篇篇博客，这里不详细赘述:<br><a href="https://langzi989.github.io/2017/09/08/C++%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">https://langzi989.github.io/2017/09/08/C++%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0/</a><br><a href="https://langzi989.github.io/2017/05/04/Wait%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">https://langzi989.github.io/2017/05/04/Wait%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</a></p>
<h2 id="显示信号的描述"><a href="#显示信号的描述" class="headerlink" title="显示信号的描述"></a>显示信号的描述</h2><p>信号的个数可以用宏<strong>NSIG</strong>获取。</p>
<p>显示信号的描述有三种方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//first method</span></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strsignal</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</div><div class="line"><span class="comment">//second method,</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">psignal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">char</span>* msg)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//third memthod</span></div><div class="line">sys_siglist[sig];</div></pre></td></tr></table></figure></p>
<h3 id="上述三种方法的区别"><a href="#上述三种方法的区别" class="headerlink" title="上述三种方法的区别"></a>上述三种方法的区别</h3><p>sys_siglist是直接存储信号描述的数组，一般情况下，推荐使用strsignal。</p>
<p>strsignal和psignal函数对locale敏感，会打印出当地的语言。<br>调用psignal会在本地的错误出输出流输出，msg:strsignalmsg；</p>
<p>如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//此时错误数据流将会打印出:SIGINT:Interrupt</div><div class="line">psignal(SIGINT, &quot;SIGINT&quot;);</div></pre></td></tr></table></figure></p>
<h2 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h2><p>许多相关的系统调用涉及到一组不同的信号，这时候需要信号集。linux中使用sigset_t结构体来表示信号集。一般情况，信号集是使用掩码实现的，但是可能有一些是其他实现方式。<br>信号集结构体相关的函数.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//初始化空信号集。注意不可使用memset或者静态变量全局变量初始化信号集为空，这样会出问题。因为不是所有的信号集都是通过掩码实现的</span></div><div class="line"><span class="comment">//0出错，1成功</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//初始化信号集包括所有的信号</span></div><div class="line"><span class="comment">//0出错，1成功</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//向信号集中添加信号</span></div><div class="line"><span class="comment">//0出错，1成功</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">int</span> sig)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//从信号集中去除信号</span></div><div class="line"><span class="comment">//0出错，1成功</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">int</span> sig)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//检查某一信号是不是在当前信号集中。返回1在,０不在</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">int</span> sig)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//以下三个为GNU C中的非标准函数，</span></div><div class="line"></div><div class="line">＃define _GNU_SOURCE</div><div class="line"><span class="comment">//对两个信号集作交集存储于dest中</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigandset</span><span class="params">(<span class="keyword">sigset_t</span>* dest, <span class="keyword">sigset_t</span>* left, <span class="keyword">sigset_t</span>* right)</span></span>;</div><div class="line"><span class="comment">//对两个信号集做并集存储于dest中</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigorset</span><span class="params">(<span class="keyword">sigset_t</span>* dest, <span class="keyword">sigset_t</span>* left, <span class="keyword">sigset_t</span>* right)</span></span>;</div><div class="line"><span class="comment">//判断信号集是否为空</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigisemptyset</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<h2 id="信号掩码-进程中阻塞信号传递"><a href="#信号掩码-进程中阻塞信号传递" class="headerlink" title="信号掩码(进程中阻塞信号传递)"></a>信号掩码(进程中阻塞信号传递)</h2><p>内核会为每个进程维护一个信号掩码(标识一组信号),当一个信号被传递到该进程的时候，若该信号在信号掩码中,进程会阻塞该信号的传递，直到将该信号从信号掩码中剔除。</p>
<p>向信号掩码中添加一个信号的方式有以下几种：</p>
<ul>
<li>当调用信号处理器程序的时候，可将引发该调用的信号自动添加到信号掩码中，这取决于sigaction函数在安装信号时使用的标志。</li>
<li>使用sigaction函数建立信号处理程序时，可以指定一组额外信号,当调用该处理器程序时将阻塞。</li>
<li>使用<strong>sigprocmask函数</strong>修改进程的信号掩码。</li>
</ul>
<h3 id="sigprocmask函数"><a href="#sigprocmask函数" class="headerlink" title="sigprocmask函数"></a>sigprocmask函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">sigset_t</span>* old)</span></span>;</div></pre></td></tr></table></figure>
<p>参数:</p>
<ul>
<li>how : 指定修改信号掩码的方式,有三种方式<ul>
<li>SIG_BLOCK : 向指定信号中添加指定信号.</li>
<li>SIG_UNBLOCK:　将指定信号从原有的信号掩码中移除。若被移除的信号掩码不存在不报错</li>
<li>SIG_SETMASK:  直接设置(赋值),覆盖原有的值</li>
</ul>
</li>
<li>set :  需要设置的新的信号掩码集</li>
<li>old:  旧的信号掩码集。可在设置信号掩码集之后回复原有的信号掩码。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">time_t</span> start = time(<span class="literal">NULL</span>);</div><div class="line">	<span class="keyword">sigset_t</span> new_set, pre;</div><div class="line">	sigemptyset(&amp;new_set);</div><div class="line">	sigaddset(&amp;new_set, SIGINT);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;new_set, &amp;pre) == <span class="number">-1</span>) &#123;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"sigprocmask set error"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">		sleep(<span class="number">1</span>);</div><div class="line">		<span class="keyword">time_t</span> end = time(<span class="literal">NULL</span>);</div><div class="line">		<span class="keyword">if</span> (end - start &gt;= <span class="number">15</span>) &#123;</div><div class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hahah 接触阻塞"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">			sigprocmask(SIG_SETMASK, &amp;pre, <span class="literal">NULL</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="sigpending获取正在等待状态的信号"><a href="#sigpending获取正在等待状态的信号" class="headerlink" title="sigpending获取正在等待状态的信号"></a>sigpending获取正在等待状态的信号</h2><p>若进程接收信号被阻塞之后，我们希望获取被阻塞的信号，则可以使用sigpending函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>使用此函数的场景是:若某个进程接收到被阻塞的信号,如果希望这些信号被移出阻塞队列,此时可以通过sigpending获取被阻塞的信号，然后将此信号的处理器函数IGNORE,并将其剔除信号掩码即可。</p>
<p><strong>在信号被阻塞的时候，不对信号做排队处理，即即使进程阻塞了100个SIGINT信号，此时当SIGINT从信号掩码中去除时，该进程接收的还是只是一个SIGINT信号。</strong></p>
<h2 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h2><p>除了signal函数之外,sigaction系统调用是设置信号处理的另一个选择。sigaction和signal函数相比更加灵活和具有可移植性。sigaction允许在不改变信号处理器程序的情况下获取信号的默认处理方式。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/09/10/Unix高级编程之signal/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/06/12/Unix网络编程之主机字节序与网络字节序/">
                            Unix网络编程之主机字节序与网络字节序
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-06-12T19:20:46+08:00">
	
		    6月 12, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Unix网络编程/">Unix网络编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Unix网络编程之主机字节序与网络字节序"><a href="#Unix网络编程之主机字节序与网络字节序" class="headerlink" title="Unix网络编程之主机字节序与网络字节序"></a>Unix网络编程之主机字节序与网络字节序</h1><p>在各种计算机体系中，对于字节，字等的存储机制有所不同，但是在网络通信过程中，如果双方交流的信息存储结构不一致，则会导致通信失败的结果。当前计算机中通常采用的字节存储机制主要有两种:<strong>大端规则与小端规则</strong>。<strong>网络通信的过程中的存储机制统一为大端规则。</strong></p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><blockquote>
<p>参考：<a href="http://www.cppblog.com/tx7do/archive/2015/12/14/71276.html" target="_blank" rel="external">http://www.cppblog.com/tx7do/archive/2015/12/14/71276.html</a></p>
</blockquote>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/06/12/Unix网络编程之主机字节序与网络字节序/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/06/12/Unix网络编程基础之套接字结构/">
                            Unix网络编程基础之套接字结构
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-06-12T16:57:47+08:00">
	
		    6月 12, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Unix网络编程/">Unix网络编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Unix网络编程基础之套接字结构"><a href="#Unix网络编程基础之套接字结构" class="headerlink" title="Unix网络编程基础之套接字结构"></a>Unix网络编程基础之套接字结构</h1><p>大多数的套接字函数都使用到了套接字地址，它们以套接字地址的指针作为参数。每个协议族都定义了自己的套接字地址结构，这些套接字地址结构均以sockaddr_开头，以协议族唯一的后缀结尾。</p>
<h2 id="IPv4套接字地址结构"><a href="#IPv4套接字地址结构" class="headerlink" title="IPv4套接字地址结构"></a>IPv4套接字地址结构</h2><p>IPv4的套接字以sockaddr_in命名，其具体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></div><div class="line">  <span class="keyword">in_addr_t</span> s_addr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></div><div class="line">  uint8 sin_len;            <span class="comment">//套接字的长度,sizeof(struct　sockaddr_in)</span></div><div class="line">  <span class="keyword">sa_family_t</span> sin_family;   <span class="comment">//协议族</span></div><div class="line">  <span class="keyword">in_port_t</span> sin_port;       <span class="comment">//套接字端口</span></div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>  <span class="comment">//套接字地址</span></div><div class="line"></div><div class="line">  <span class="keyword">char</span> sin_zero[<span class="number">8</span>];         <span class="comment">//保留位</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>sin_len : 套接字的长度字段，类型为uint8_t,sizeof(struct sockaddr_in),不是所有的系统都支持。长度字段简化了可变长度的套接字的处理。<strong>在使用过程中无需设置和检查它</strong>，除非涉及路由套接字。</li>
<li>sin_family : 协议族，IPv4的协议族为AF_INET.类型为无符号整形，其长度受系统的影响。若sockaddr_in中含有sin_len字段，其大小为16位，若含有长度字段，其大小为8位。</li>
<li>sin_port : 套接字端口, 一般为uint16_t类型。</li>
<li>sin_addr : 套接字Ip，其类型为in_addr，in_addr中的s_addr类型为uint32_t.</li>
<li>sin_zero : 不常用，若需要在套接字中加入额外字段，使用到此字段，<strong>若不使用将其置为0，一般使用sockaddr_in首先将整个结构置0</strong>。</li>
</ul>
<blockquote>
<p><strong>注意：套接字地址结构仅在本机上使用，虽然结构中的某些字段用在不同主机之间的通信，但是结构体本身不在主机之间传递。</strong></p>
</blockquote>
<h3 id="协议族参数说明"><a href="#协议族参数说明" class="headerlink" title="协议族参数说明"></a>协议族参数说明</h3><p>网络通信过程中有不同的协议族，通常我们在socket地址的sin_family中指出当前通信使用的协议族，不同协议族对应不同的参数，其对应参数如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">sin_family</th>
<th>协议说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AF_INET</td>
<td>IPv4协议</td>
</tr>
<tr>
<td style="text-align:center">AF_INET6</td>
<td>IPv6协议</td>
</tr>
<tr>
<td style="text-align:center">AF_LOCAL</td>
<td>Unix域协议</td>
</tr>
<tr>
<td style="text-align:center">AF_ROUTE</td>
<td>路由套接字协议</td>
</tr>
<tr>
<td style="text-align:center">AF_KEY</td>
<td>密钥套接字</td>
</tr>
</tbody>
</table>
<h2 id="通用套接字地址结构"><a href="#通用套接字地址结构" class="headerlink" title="通用套接字地址结构"></a>通用套接字地址结构</h2><p>套接字函数以套接字地址结构指针作为参数的过程中，由于在C中没有继承的机制，这个时候向套接字函数传递参数的时候，由于不同协议的套接字地址不同，会出现问题。这个时候有一种解决办法就是<strong>传递void*指针给socket函数，但是void空指针的出现在socket函数之后</strong>，所以这个方案不可行。这个时候的解决方案是　<strong>定义一个通用的套接字函数，socket函数的参数为通用套接字地址的指针，传递参数的时候我们将特定的套接字指针强制转换为通用套接字地址指针。</strong>　如bind函数的函数原型为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span>, struct sockaddr*, <span class="keyword">socklen_t</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>通用套接字地址的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></div><div class="line">  <span class="keyword">uint8_t</span> sa_len;</div><div class="line">  <span class="keyword">sa_family_t</span> sa_family;</div><div class="line">  <span class="keyword">char</span> sa_data[<span class="number">14</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Ubuntu16-04中sockaddr-in的定义"><a href="#Ubuntu16-04中sockaddr-in的定义" class="headerlink" title="Ubuntu16.04中sockaddr_in的定义"></a>Ubuntu16.04中sockaddr_in的定义</h2><p>Ubuntu16.04中sockaddr_in的定义在/usr/include/netinet/in.h，注意其不支持sin_len字段，为了保持与通用套接字字符串兼容，其保留字符串的长度直接用通用套接字的大小减去其他字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></div><div class="line">  &#123;</div><div class="line">    __SOCKADDR_COMMON (sin_);</div><div class="line">    <span class="keyword">in_port_t</span> sin_port;                 <span class="comment">// Port number.  </span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>            <span class="comment">// Internet address.  </span></div><div class="line"></div><div class="line">    <span class="comment">//Pad to size of struct sockaddr</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</div><div class="line">                          __SOCKADDR_COMMON_SIZE -</div><div class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</div><div class="line">                           <span class="keyword">sizeof</span> (struct in_addr)];</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/06/12/Unix网络编程基础之套接字结构/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/06/11/Unix时间相关函数总结-md/">
                            Unix时间相关函数总结.md
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-06-11T20:09:08+08:00">
	
		    6月 11, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Unix时间相关函数总结"><a href="#Unix时间相关函数总结" class="headerlink" title="Unix时间相关函数总结"></a>Unix时间相关函数总结</h1><p>在进行Unix编程的过程中，我们不可避免的会遇到需要时间相关的操作，如文件的创建修改时间，数据库中字段插入或更新的时间。</p>
<h2 id="Unix时间相关的类型"><a href="#Unix时间相关的类型" class="headerlink" title="Unix时间相关的类型"></a>Unix时间相关的类型</h2><ul>
<li>time_t</li>
<li>struct timeb</li>
<li>struct timeval</li>
<li>struct timespec</li>
<li>struct tm</li>
<li>clock_t</li>
</ul>
<h3 id="time-t"><a href="#time-t" class="headerlink" title="time_t"></a>time_t</h3><p>time_t是一个有符号的整数类型，表示的含义是从1970年1月1日到某一个时间点的秒数。若为32位系统，由int类型的范围可以推算出，time_t可以表示的时间范围是1901-12-13 20:45:52到2038-０1-19 03:14:07。</p>
<h3 id="struct-ime-b"><a href="#struct-ime-b" class="headerlink" title="struct ime_b"></a>struct ime_b</h3><p>time_b结构体是一个精确到毫秒的结构体，其有四个成员，成员列表如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeb</span>&#123;</span></div><div class="line">  <span class="keyword">time_t</span> time;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> millitm;</div><div class="line">  <span class="keyword">short</span> timezone;　　　　<span class="comment">//时区标志</span></div><div class="line">  <span class="keyword">short</span> dstflag;　　　　 <span class="comment">//夏令时标志</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以通过下列函数获取当前的timeb:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftime</span><span class="params">(struct timeb* tb)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="struct-timeval"><a href="#struct-timeval" class="headerlink" title="struct timeval"></a>struct timeval</h3><p>timeval是一个精确到微妙的结构体。其中主要包含两个成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></div><div class="line">  <span class="keyword">time_t</span> tv_sec;</div><div class="line">  suseconds tv_usec;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>此值通常通过gettimeofday获取<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval* tv, struct timezone* tz)</span></span>; <span class="comment">//timezone参数已废弃，一般设为NULL，</span></div></pre></td></tr></table></figure></p>
<h3 id="struct-timespec"><a href="#struct-timespec" class="headerlink" title="struct timespec"></a>struct timespec</h3><p>timespec是一个精确到纳秒的结构体。其主要包含两个成员<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>&#123;</span></div><div class="line">  <span class="keyword">time_t</span> tv_sec; <span class="comment">//秒</span></div><div class="line">  <span class="keyword">long</span> tv_nsec; <span class="comment">//纳秒</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此结构体一般通过下列函数获取：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">clock_gettime</span><span class="params">(<span class="keyword">clockid_t</span> which_clock, struct timespec* tp)</span></span>;</div></pre></td></tr></table></figure></p>
<p>上述参数中which_clock用于标识那种时钟时间，可选值如下</p>
<ul>
<li>CLOCK_REALTIME  　　　　　 : 系统当前时间,1970-1-1开始</li>
<li>CLOCK_MONOTONIC  　　　　　: 系统的启动时间，不能被设置</li>
<li>CLOCK_PROCESS_CPUTIME_ID : 进程运行时间</li>
<li>CLOCK_THREAD_CPUITME_ID  : 线程运行时间</li>
<li>CLOCK_REALTIME_HR        : CLOCK_REALTIME的高精度版本</li>
<li>CLOCK_MONOTONIC_HR       : CLOCK_MONOTONIC的高精度版本</li>
</ul>
<h3 id="struct-tm"><a href="#struct-tm" class="headerlink" title="struct tm"></a>struct tm</h3><p>struct tm被称为一种分解时间，日期和时间被分解成多个独立字段。其形式如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></div><div class="line">  <span class="keyword">int</span> tm_sec;     <span class="comment">//秒 (0-60)</span></div><div class="line">  <span class="keyword">int</span> tm_min;     <span class="comment">//分 (0-59)</span></div><div class="line">  <span class="keyword">int</span> tm_hour;    <span class="comment">//时 (0-23)</span></div><div class="line">  <span class="keyword">int</span> tm_mday;    <span class="comment">//日 (1-31)</span></div><div class="line">  <span class="keyword">int</span> tm_mon;     <span class="comment">//月 (0-11)</span></div><div class="line">  <span class="keyword">int</span> tm_year;    <span class="comment">//年 (1900-)</span></div><div class="line">  <span class="keyword">int</span> tm_wday;    <span class="comment">//一周中的周几(周日为0)</span></div><div class="line">  <span class="keyword">int</span> tm_yday;    <span class="comment">//一年中的第几天。(1月1号为0)</span></div><div class="line">  <span class="keyword">int</span> m_isdst;    <span class="comment">//DST大于0表示为夏令时时间。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Unix时间相关函数"><a href="#Unix时间相关函数" class="headerlink" title="Unix时间相关函数"></a>Unix时间相关函数</h2><p>Unix时间相关的函数除了上面已经提到的函数还包括以下函数</p>
<ul>
<li>time(time_t timep)</li>
<li>ctime</li>
<li>gmtime</li>
<li>localtime</li>
<li>mktime</li>
<li>asctime</li>
<li>strftime</li>
<li>strptime</li>
</ul>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="keyword">time_t</span> time(<span class="keyword">time_t</span>* timep);</div></pre></td></tr></table></figure>
<p>time函数返回当前时间的时间戳，此时间戳为从1970年1月1日到当前时间的时间戳，此值不受时区和夏令时(DST)。此函数的返回值为当前的时间戳，函数参数为time_t指针，当前时间除了返回值之外，还将此时间放入timep中。所以使用time函数时我们<strong>将timep设置为NULL</strong>即可。</p>
<h3 id="ctime"><a href="#ctime" class="headerlink" title="ctime"></a>ctime</h3><h4 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timep)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h4><p>ctime函数的功能为<strong>将time_t转化为打印字符串格式</strong>。把一个指向time_t的指针timep传入函数ctime,将返回一个长度为26字节的字符串，包含\0和换行符。ctime进行转换的时候，会<strong>考虑时区和夏令时</strong>，所以返回的时间字符串为当地时间。返回时间的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Wed Jun  8 14:22:34 2011</div></pre></td></tr></table></figure></p>
<p>特别注意返回的字符串是经由静态分配的，若多次调用此函数，之前获取的时间会受影响。SuSv3规定，调用ctime(),gmtime(),localtime()以及asctime()中的任意一个函数，都可能覆盖其他函数返回的结果。</p>
<blockquote>
<p>静态分配的意思是这些函数返回的数据都是般存在同一个静态变量中，所以下一次的结果会覆盖上一次的数据。如果需要对之前的数据保存，此时需要将结果拷贝到自己分配的内存中。</p>
</blockquote>
<p>###　gmtime和localtime</p>
<h4 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="function">struct tm* <span class="title">gmtime</span><span class="params">(<span class="keyword">time_t</span>* timep)</span></span>;</div><div class="line"><span class="function">struct tm* <span class="title">localtime</span><span class="params">(time* timep)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="函数功能-1"><a href="#函数功能-1" class="headerlink" title="函数功能"></a>函数功能</h4><p>gmttime和localtime的作用是将time_t值转换为分解时间struct tm类型。他们的主要区别是<strong>gmtime转换为对应于UTC的分解时间，而localtime考虑时区和夏令时</strong>。</p>
<h3 id="mktime"><a href="#mktime" class="headerlink" title="mktime"></a>mktime</h3><h4 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="keyword">time_t</span> mktime(struct tm* timeptr);</div></pre></td></tr></table></figure>
<p>####　函数功能<br>mktime的作用是将一个<strong>本地时区的分解时间转化为time_t类型</strong>。需要注意的是，mktime可能<strong>改变timeptr所指的内容。若分解时间不符合要求，mktime将其自动转换为有效时间</strong>。如秒为61,此时会将其变成1并讲分加１。</p>
<h3 id="asctime"><a href="#asctime" class="headerlink" title="asctime"></a>asctime</h3><h4 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#incude <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">asctime</span><span class="params">(<span class="keyword">const</span> struct tm* timeptr)</span></span>;</div></pre></td></tr></table></figure>
<h4 id="函数功能-2"><a href="#函数功能-2" class="headerlink" title="函数功能"></a>函数功能</h4><p>asc的功能是<strong>将分解时间转化为打印时间，特别注意的是asctime转化的过程中不考虑时区和夏令时</strong>，返回的数据也是静态分配的。</p>
<h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime"></a>strftime</h3><h4 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="keyword">size_t</span> strftime(<span class="keyword">char</span>* outstr, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span>* format, <span class="keyword">const</span> struct tm* timeptr);</div></pre></td></tr></table></figure>
<h4 id="函数功能-3"><a href="#函数功能-3" class="headerlink" title="函数功能"></a>函数功能</h4><p>此函数的功能是将分解时间转换为打印时间，并可以指定打印时间的格式为format。不同于ctime和asctime，strftime结果不包含换行符。若返回的字符串超过了maxsize大小，函数返回0指示为转换错误。定义的格式中其格式化字符串可以参考预定义的格式。参考《Linux/Unix系统编程手册.上册》第158页。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/06/11/Unix时间相关函数总结-md/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/24/Unix标准IO缓冲类型/">
                            Unix标准IO文件流及缓冲类型
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-24T21:14:10+08:00">
	
		    5月 24, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Unix标准IO文件流及缓冲类型"><a href="#Unix标准IO文件流及缓冲类型" class="headerlink" title="Unix标准IO文件流及缓冲类型"></a>Unix标准IO文件流及缓冲类型</h1><h2 id="Unix标准IO文件流"><a href="#Unix标准IO文件流" class="headerlink" title="Unix标准IO文件流"></a>Unix标准IO文件流</h2><p>在<strong>文件IO相关函数</strong>的一节中,我们所有的I/O函数都是围绕着文件描述符来操作的，当打开一个文件的时候，即返回一个文件描述符，然后该文件描述符用于后续的文件操作。而对于标准IO库，对于文件的操作都是围绕这<strong> 文件流 file stream</strong>进行的。当我们使用标准IO库打开或创建一个文件的时候，我们已经使一个流和一个文件进行关联。</p>
<h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>由于历史原因，C语言中原来表示流的数据结构是FILE，而不是叫做流。由于大多数的库函数使用到了FILE类型，有的时候在使用FILE指针的时候也叫其为流，这导致后来很多数据把FILE和流搞得十分混乱。实际上流就是标准IO库中程序与文件交互的一种方式。</p>
<p>标准IO函数fopen打开一个文件时返回一个指向FILE对象的指针，该对象通常是一个结构，<strong>它包含了标准IO库为管理该流所需要的所有信息，包括该文件的文件描述符，用于指向该流缓冲区的指针，缓冲区的长度，当前缓冲区中的字符数以及出错标志等等</strong>。</p>
<h3 id="标准输入，标准输出以及标准错误"><a href="#标准输入，标准输出以及标准错误" class="headerlink" title="标准输入，标准输出以及标准错误"></a>标准输入，标准输出以及标准错误</h3><p>标准库中对于每一个进程都预定义了三个流，分别是stdin,stdout以及stderr，他们分别对应与Linux文件IO中的STDIN_FILENO,STDOUT_FILENO和STDERR_FILENO。它们的定义在stdio.h中</p>
<h2 id="I-O文件流的缓冲类型"><a href="#I-O文件流的缓冲类型" class="headerlink" title="I/O文件流的缓冲类型"></a>I/O文件流的缓冲类型</h2><p>标准IO提供缓冲的目的是为了通过减少使用read和write调用的次数来提高IO读写的效率，它对每个IO流自动的进行缓冲处理，从而避免了用户程序在使用read和write需要考虑的这一点。</p>
<p>标准IO流提供了三种缓冲。分别是全缓冲(fully buffering)，行缓冲(line Buffering)以及无缓冲(nonBuffering)。</p>
<h3 id="全缓冲"><a href="#全缓冲" class="headerlink" title="全缓冲"></a>全缓冲</h3><p>在使用全缓冲的情况下，当数据填满整个缓冲区之后才进行实际的IO操作。对于驻留在磁盘上的文件的读写通常是使用全缓冲。通常如果不给文件流指定缓冲区的情况下，标准IO函数会首先调用malloc函数获取所需要的缓冲区。</p>
<h3 id="行缓冲"><a href="#行缓冲" class="headerlink" title="行缓冲"></a>行缓冲</h3><p>在使用行缓冲的情况下，每当输入输出遇到换行或者缓冲区满了的情况下才会进行实际的IO操作，当涉及到终端输入输出的时候通常使用行缓冲。</p>
<p>对于行缓冲有两个限制。1.由于接收行缓冲的缓冲区的长度是固定的，所以只要填满了缓冲区，即使还没有遇到换行符，也会进行IO操作。2.任何时候，只要通过IO库要求从一个不带缓冲的流或者一个行缓冲的流得到输入数据，那么就会冲洗所有缓冲输出流。</p>
<p>###不带缓冲<br>此时标准IO库不对字符进行缓冲存储。这就使得输入流要求IO立即进行，如标准错误流，若果出现错误，会立马输出。</p>
<blockquote>
<p>flush一个流即刷新缓冲区有两个含义。</p>
<ul>
<li>在IO库方面，flush意味着将缓冲区中的内容写到磁盘上，该缓冲区可能还没有满</li>
<li>在终端驱动方面表示丢弃已经存储在缓冲区中的内容。</li>
</ul>
</blockquote>
<p>##标准文件流与缓冲类型之间的关系</p>
<ul>
<li>当标准输入输出指向的是交互式设备（如终端）的时候，它们是行缓冲的，若不是则是全缓冲的。</li>
<li>标准错误永远是无缓冲的。</li>
</ul>
<h2 id="与缓冲相关的函数"><a href="#与缓冲相关的函数" class="headerlink" title="与缓冲相关的函数"></a>与缓冲相关的函数</h2><p>我们可以通过一下两个函数对将缓冲关闭或者改变缓冲的类型。其中这些函数应该在流被打开之后调用，而且也应该在对流进行一切操作之前调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fd, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fd, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</div></pre></td></tr></table></figure>
<p>使用setbuf函数打开或者关闭缓冲，当buf是一个有效缓冲区时，此时缓冲打开，若流指向的是终端设备，则此时该流是行缓冲的，否则该流是全缓冲的；当buf为NULL的时候，表示关闭该缓冲。</p>
<p>使用setvbuf可以精确的说明缓冲的类型，这里是使用mode来说明的，mode的值包括以下几个：</p>
<ul>
<li>_IOFBF 全缓冲</li>
<li>_IOLBUF 行缓冲</li>
<li>_IONBUF 无缓冲</li>
</ul>
<p>如果指定一个不带缓冲的流,则忽略buf和size参数。如果指定缓冲，则buf和size分别指定一个缓冲区域和缓冲区域的长度。若此时buf为NULL，则标准IO库将自动制定一个适合长度的缓冲区。</p>
<p>上述函数与缓冲之间的关系</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">mode</th>
<th style="text-align:center">buf</th>
<th style="text-align:center">缓冲区及长度</th>
<th style="text-align:left">缓冲类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setbuf</td>
<td style="text-align:center"></td>
<td style="text-align:center">非空</td>
<td style="text-align:center">长度为size的缓冲区buf</td>
<td style="text-align:left">全缓冲或行缓冲</td>
</tr>
<tr>
<td style="text-align:center">setbuf</td>
<td style="text-align:center"></td>
<td style="text-align:center">NULL</td>
<td style="text-align:center">无缓冲区</td>
<td style="text-align:left">不带缓冲</td>
</tr>
<tr>
<td style="text-align:center">setvbuf</td>
<td style="text-align:center">_IOFBF</td>
<td style="text-align:center">非空</td>
<td style="text-align:center">长度为size的缓冲区buf</td>
<td style="text-align:left">全缓冲</td>
</tr>
<tr>
<td style="text-align:center">setvbuf</td>
<td style="text-align:center">_IOFBF</td>
<td style="text-align:center">NULL</td>
<td style="text-align:center">合适长度的缓冲区buf</td>
<td style="text-align:left">全缓冲</td>
</tr>
<tr>
<td style="text-align:center">setvbuf</td>
<td style="text-align:center">_IOLBF</td>
<td style="text-align:center">非空</td>
<td style="text-align:center">长度为size的缓冲区buf</td>
<td style="text-align:left">行缓冲</td>
</tr>
<tr>
<td style="text-align:center">setvbuf</td>
<td style="text-align:center">_IOLBF</td>
<td style="text-align:center">NULL</td>
<td style="text-align:center">合适长度的缓冲区buf</td>
<td style="text-align:left">行缓冲</td>
</tr>
<tr>
<td style="text-align:center">setvbuf</td>
<td style="text-align:center">_IONBF</td>
<td style="text-align:center">忽略</td>
<td style="text-align:center">无缓冲区</td>
<td style="text-align:left">不带缓冲</td>
</tr>
</tbody>
</table>
<p>我们还可以通过fflush强制冲洗一个流，此函数使该流所有未写的数据都被传送到内核。作为一种特殊的情况，当流的NULL时，所有的流将被冲洗：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE* fd)</span></span>;</div></pre></td></tr></table></figure></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/24/Unix标准IO缓冲类型/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/tags/Linux/page/2/">
                    <span>OLDER POSTS</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">page 1 of 2</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 魏传柳(2824759538@qq.com). All Rights Reserved.
    </span>
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
     </script>
   </br></br>本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avar.jpg"/>
        
            <h4 id="about-card-name">魏传柳(2824759538@qq.com)</h4>
        
            <h5 id="about-card-bio"><p>author.bio</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Guangzhou,China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script-i4qo6jx6jji9fg0dftpya6ivemizsbow4fhow76d8dwpm7m1wbvi378ssumx.min.js"></script>
<!--SCRIPTS END-->



</html>
