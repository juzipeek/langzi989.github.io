{"meta":{"title":"魏传柳","subtitle":null,"description":null,"author":"魏传柳(langzi989)","url":"http://yoursite.com"},"pages":[{"title":"all-categories","date":"2016-12-01T16:59:23.933Z","updated":"2016-12-01T16:59:23.933Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2016-12-01T16:59:49.905Z","updated":"2016-12-01T16:59:49.905Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""},{"title":"all-archives","date":"2016-12-01T17:00:12.569Z","updated":"2016-12-01T17:00:12.569Z","comments":false,"path":"all-archives/index.html","permalink":"http://yoursite.com/all-archives/index.html","excerpt":"","text":""}],"posts":[{"title":"free如何知道要free多大的空间","slug":"free如何知道要free多大的空间","date":"2017-04-07T02:50:31.000Z","updated":"2017-04-07T03:46:23.402Z","comments":true,"path":"2017/04/07/free如何知道要free多大的空间/","link":"","permalink":"http://yoursite.com/2017/04/07/free如何知道要free多大的空间/","excerpt":"","text":"在C语言中，当向一个函数传递指针的时候，它的长度信息往往会被截断（如果是数组名），传入函数的只是一个指针，而无法标示数组的长度，在函数中我们也无法获取它的长度信息，除非显示的传递一个长度参数。但是使用free函数的过程中，我们只是向free中传递了一个指针，并没有标示它的大小，那free是如何知道将要被free掉的内存的大小呢？下面将详细解答这一问题。 malloc函数的实现是以块分配内存，在被分配的块中包括两部分。第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量；第二部分中存储实际用户数据。而使用malloc分配内存返回的是第二部分用户数据的地址。而块的两个部分在内存中的存储取决有编译器的实现，一般有两种情况，第一种是最常见的，即元数据和用户数据是连续的，存储在连续空间位置。第二种是两部分分开存储。 对于第一种情况，malloc分配内存的空间图如下： 12345678____ The allocated block ____/ \\+--------+--------------------+| Header | Your data area ... |+--------+--------------------+ ^ | +-- The address you are given 对于上述情况，malloc中内存转换实现方式为：123456/* The corresponding word size */#define SIZE_SZ (sizeof(INTERNAL_SIZE_T)).../* conversion from malloc headers to user pointers, and back */#define chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ))#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ)) 如上源码我们可以看出来，chunk2mem将原始指针转换为user_data的指针，mem2chunk做了相反的转换。这个时候free的实现为： 1234void free(void* mem) &#123; p = mem2chunk(mem); // Now that you know how large is chunk \"p\", go ahead and free the chunk.&#125; 同时，我们通过实验可以推测，标准库对void*的operator=做了重载。123456789101112#include &lt;iostream&gt;int main() &#123; int *a = (int*)malloc(sizeof(int)); int *b = (int*)malloc(sizeof(int)); short *c = (short*)malloc(sizeof(short)); std::cout &lt;&lt; a &lt;&lt; std::endl &lt;&lt; b &lt;&lt; std::endl &lt;&lt; c &lt;&lt; std::endl; std::cout &lt;&lt; b - a &lt;&lt; std::endl; std::cout &lt;&lt; reinterpret_cast&lt;size_t&gt;(b) - reinterpret_cast&lt;size_t&gt;(a) &lt;&lt; std::endl;&#125; 输出结果为:123450x10b5c200x10b5c400x10b5c60832","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"why assigment operator can not be frined function","slug":"why-assigment-operator-can-not-be-frined-function","date":"2017-03-21T06:30:41.000Z","updated":"2017-03-21T06:31:31.856Z","comments":true,"path":"2017/03/21/why-assigment-operator-can-not-be-frined-function/","link":"","permalink":"http://yoursite.com/2017/03/21/why-assigment-operator-can-not-be-frined-function/","excerpt":"","text":"why assigment operator can not be frined this is a problem in my work and I have find th solution on stackoverflow,so recorder here problem descriptionWhen I refactor my object, I have a problem which need to change the return valueof and function std::string to a struct data, but I don’t want to change my codewhere the function be used, so I want to overload the assignment operator whichwill assign a struct to string.The code is as follows: 1234567891011121314151617181920#include &lt;string&gt;class data_struct&#123; friend std::string operator = (std::string&amp; s, data_struct&amp; d);private: bool success&#123;false&#125;; std::string message&#123;\"\"&#125;;public: data_struct(bool t_success, std::string t_message): success(t_success), message(t_message) &#123;&#125;&#125;std::string operator = (std::string&amp; s, data_struct&amp; d) &#123; s = d.s; return s;&#125;int main() &#123; data_struct d(false,\"haha\"); std::string s = d;&#125; when I compile this file , this is an error follows: 123456789main.cpp:3:64: error: ‘std::__cxx11::string operator=(std::__cxx11::string&amp;, data_struct&amp;)’ must be a nonstatic member function friend std::string operator = (std::string&amp; s, data_struct&amp; d); ^main.cpp:12:13: error: expected initializer before ‘operator’ std::string operator = (std::string&amp; s, data_struct&amp; d) &#123; ^main.cpp: In function ‘int main()’:main.cpp:19:19: error: conversion from ‘data_struct’ to non-scalar type ‘std::__cxx11::string &#123;aka std::__cxx11::basic_string&lt;char&gt;&#125;’ requested std::string s = d; why does this happen?Firstly, it should be noted that this has nothing to do with the operator being implemented as a friend specifically. It is really about implementing the copy-assignment as a member function or as a non-member (standalone) function. Whether that standalone function is going to be a friend or not is completely irrelevant: it might be, it might not be, depending on what it wants to access inside the class. Now, the answer to this question is given in D&amp;E book (The Design and Evolution of C++). The reason for this is that the compiler always declares/defines a member copy-assignment operator for the class (if you don’t declare your own member copy-assignment operator). If the language also allowed declaring copy-assignment operator as a standalone (non-member) function, you could end up with the following 1234567891011121314151617181920212223// Class definitionclass SomeClass &#123; // No copy-assignment operator declared here // so the compiler declares its own implicitly ...&#125;;SomeClass a, b;void foo() &#123; a = b; // The code here will use the compiler-declared copy-assignment for `SomeClass` // because it doesn't know anything about any other copy-assignment operators&#125;// Your standalone assignment operatorSomeClass&amp; operator =(SomeClass&amp; lhs, const SomeClass&amp; rhs);void bar() &#123; a = b; // The code here will use your standalone copy-assigment for `SomeClass` // and not the compiler-declared one&#125; As seen in the above example, the semantics of the copy-assignment would change in the middle of the translation unit - before the declaration of your standalone operator the compiler’s version is used. After the declaration your version is used. The behavior of the program will change depending on where you put the declaration of your standalone copy-assignment operator. This was considered unacceptably dangerous (and it is), so C++ doesn’t allow copy-assignment operator to be declared as a standalone function. It is true that in your particular example, which happens to use a friend function specifically, the operator is declared very early, inside the class definition (since that’s how friends are declared). So, in your case the compiler will, of course, know about the existence of your operator right away. However, from the point of view of C++ language the general issue is not related to friend functions in any way. From the point of view of C++ language it is about member functions vs. non-member functions, and non-member overloading of copy-assignment is just prohibited entirely for the reasons described above. Solutiondue to the solution above is not proper.So I overWrite the orignal function, andinvoke different version in their needed place.","categories":[{"name":"C++ problems","slug":"C-problems","permalink":"http://yoursite.com/categories/C-problems/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"工厂类模式家族之简单工厂模式","slug":"工厂类模式家族之简单工厂模式","date":"2017-01-09T08:57:04.000Z","updated":"2017-01-09T09:01:14.162Z","comments":true,"path":"2017/01/09/工厂类模式家族之简单工厂模式/","link":"","permalink":"http://yoursite.com/2017/01/09/工厂类模式家族之简单工厂模式/","excerpt":"","text":"工厂类模式家族之简单工厂模式在面向对象编程的领域，设计模式给我们提供了适合特定场景的软件设计思想，不过大多设计模式都可以通过一般的设计进行替代，但我们为什么还有费工夫去遵循设计模式呢？这就要说到设计模式的精髓了，我们通过对软件系统进行良好的设计，不但可以提高代码的可重用性，增强系统的可扩展性，给客户提供良好的接口，还可以减少编码过程中因代码组织太乱扩展过程中需要修改旧代码而带来的一连串的错误，降低维护成本。软件设计过程我们应该尽量追求符合软件设计的开闭原则。 开闭原则:在面向对象编程领域中，开闭原则规定“软件中的对象(类，模块，函数)应该对于扩展是开放的，但是对于修改是封闭的”。该特性在产品化的环境中是特别有价值的，在这种环境中我们认为一旦类完成，我们可以对它进行扩展改变其行为，但是不允许修改类。也就是说一个类的实现只应该因错误而修改。－－by wiki 工厂模式家族包括三种重要的模式，分别是简单工厂模式，工厂模式以及抽象工厂模式。他们都属于类的创建型模式。创建型模式包括两种，分别是类的创建型模式和对象的创建型模式。类的创建型模式通常使用继承关系，将类的创建交由其具体的子类完成，这样就向外界隐藏了如何得到具体类的实现细节，以及这个类的实例是如何被创建或者组织在一起的。；对象创建型模式通常把一个类的创建委托给另一个对象完成，可以根据语境动态地决定生成哪个具体类的实例。 本节我们来讲解工厂模式中的简单工厂模式。主要包括以下几个部分： 简单工厂模式的实质 简单工厂模式的适用性 简单工厂模式的结构 简单工厂模式的参与者 简单工厂模式各成分之间的交互 实际应用 简单工厂模式的优缺点 简单工厂模式实例代码 简单工厂模式的实质简单工厂模式又称为静态工厂模式。 它的实质是根据客户传递的信息，工厂类通过该信息制造出相应的产品的实例返回给客户。这样我们就做到了客户只是产品的消费者，而真正的创建者是工厂类。 在简单工厂模式中，待被创建的产品通常继承自同一个类。而这个类中包含了具体产品的所有的公共成员和方法。 简单工厂模式的适用性简单工厂模式将对象的创建和对象本身的业务分离开来，降低了系统的耦合度，当维护期间需要对客户代码或者产品代码进行修改的时候，修改其中之一不会影响另一个。 简单工厂模式的结构 简单工厂模式的参与者简单工厂模式中一般有以下几个部分: 工厂类：简单工厂模式的核心，它的作用是根据客户提供的信息创建相应的具体产品 抽象产品：所有具体产品的父类，其中主要包含所有具体产品共有的方法或对象 具体产品：工厂类创建的具体实例。 简单工厂模式各成分之间的交互 客户首先创建factory类(一般为单例模式)， factory类创建成功后，客户调用其createProduct方法，并传入相关信息， 具体产品实例被创建并返回给client,开始进行使用concreteProduct 简单工厂模式的实际应用在实际开发中使用简单工厂模式中，我们可以进行变通的使用。 在实际情况种可能会出现比较复杂的抽象产品和和具体产品之间的关系，这个时候我们依然也可以使用抽象工厂模式: 简单工厂模式的优缺点简单工厂模式的优点: 通过在中间添加一个工厂类，降低产品类和客户代码之间的耦合度；客户在获取产品的时候无需记住所有产品的构造方法，只需要通过同意的工厂类接口进行创建产品，大大提高了效率准确率。 简单工厂模式的缺点：所有的产品实例化的逻辑都在工厂类的一个创建方法中，当需要添加新产品的时候，不得不进行修改factory类，这样就违背了设计的开闭原则(对扩展开放，对修改封闭)；另外当产品类别过多的时候，会出现这个函数冗杂的问题，增加维护成本。最重要的是这个工厂类是所有产品的入口，当它不能工作的时候，所有的产品将陷入瘫痪状态。 简单工厂的实例下面通过形状shape,circle以及rectangle来实现一个简单的简单工厂模式(如有问题，欢迎指正)： 12345678910111213141516171819//factory.hpp#ifndef FACTORY_HPP_#define FACTORY_HPP_#include \"circle.hpp\"#include \"rectangle.hpp\"#include &lt;memory&gt;#include &lt;string&gt;class Factory &#123;private: Factory() &#123;&#125; Factory(const Factory &amp;) = delete; Factory &amp;operator=(const Factory &amp;) = delete;public: static std::shared_ptr&lt;Factory&gt; m_factory; static std::shared_ptr&lt;Factory&gt; getInstance(); static std::shared_ptr&lt;Shape&gt; getShape(const std::string &amp;flag);&#125;;#endif 12345678910111213141516171819//factory.cpp#include \"factory.hpp\"std::shared_ptr&lt;Factory&gt; Factory::m_factory = nullptr;std::shared_ptr&lt;Factory&gt; Factory::getInstance() &#123; if (m_factory == nullptr) &#123; m_factory = std::unique_ptr&lt;Factory&gt;(new Factory()); &#125; return m_factory;&#125;std::shared_ptr&lt;Shape&gt; Factory::getShape(const std::string &amp;flag) &#123; if (0 == flag.compare(\"circle\")) &#123; return std::shared_ptr&lt;Shape&gt;(new Circle()); &#125; else if (0 == flag.compare(\"rectangle\")) &#123; return std::shared_ptr&lt;Shape&gt;(new Rectangle()); &#125;&#125; 12345678910//shape.hpp#ifndef SHAPE_HPP_#define SHAPE_HPP_#include &lt;iostream&gt;class Shape &#123;public: virtual void draw() = 0; virtual double getArea() = 0;&#125;;#endif 12345678910111213141516//circle.hpp#ifndef CIRCLE_HPP#define CIRCLE_HPP#include \"shape.hpp\"class Circle : public Shape &#123;public: Circle(double t_radius = 0) : m_radius(t_radius) &#123;&#125; virtual void draw() &#123; std::cout &lt;&lt; \"this is a circle, the radius is : \" &lt;&lt; m_radius &lt;&lt; std::endl; &#125;; virtual double getArea() &#123; return m_radius * m_radius * 3.14; &#125;private: double m_radius;&#125;;#endif 123456789101112131415161718//rectangle.hpp#ifndef RECTANGLE_HPP_#define RECTANGLE_HPP_#include \"shape.hpp\"class Rectangle : public Shape &#123;public: Rectangle(int a = 0, int b = 0) : m_height(a), m_width(b) &#123;&#125; virtual void draw() &#123; std::cout &lt;&lt; \"this is a rectangle\\n height: \" &lt;&lt; m_height &lt;&lt; \"\\nwidth:\" &lt;&lt; m_width &lt;&lt; std::endl; &#125; virtual double getArea() &#123; return m_height * m_width; &#125;private: int m_height; int m_width;&#125;;#endif 12345678910111213//main.cpp#include \"circle.hpp\"#include \"factory.hpp\"#include \"rectangle.hpp\"int main() &#123; std::shared_ptr&lt;Factory&gt; t = Factory::getInstance(); std::shared_ptr&lt;Shape&gt; c = t-&gt;getShape(\"circle\"); c-&gt;draw(); std::cout &lt;&lt; \"the area is: \" &lt;&lt; c-&gt;getArea() &lt;&lt; std::endl; std::shared_ptr&lt;Shape&gt; r = t-&gt;getShape(\"rectangle\"); r-&gt;draw(); std::cout &lt;&lt; \"the area is :\" &lt;&lt; r-&gt;getArea() &lt;&lt; std::endl;&#125;","categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"简单工厂方法","slug":"简单工厂方法","permalink":"http://yoursite.com/tags/简单工厂方法/"}]},{"title":"GRASP设计原则（职责分配原则）","slug":"GRASP设计原则（职责分配原则）","date":"2017-01-08T11:45:46.000Z","updated":"2017-01-08T11:47:09.435Z","comments":true,"path":"2017/01/08/GRASP设计原则（职责分配原则）/","link":"","permalink":"http://yoursite.com/2017/01/08/GRASP设计原则（职责分配原则）/","excerpt":"","text":"GRASP设计原则（职责分配原则）GRASP(General responsibility assignment software Principle)设计原则是设计模式的基础,在GOF的23中设计模式中处处可以体现其中的一个或多个设计原则，所以在掌握设计模式之前需要对GRASP原则有一定的了解，本节我在这里总结一下grasp原则。 本文共分为以下几个内容： GRASP的九个原则 GRASP原则详解 GRASP原则在23中设计模式中的体现 GRASP的九个原则 信息专家原则(information) 创造者原则(creator) 低耦合原则(low coupling) 高内聚原则(high cohesion) 控制器原则(controller) 多态原则(polymorphism) 纯虚构(pure Fabrication) 中介原则(indirect) 受保护变量原则(protected Variations) Grasp原则详解信息专家原则(information expert)信息专家模式的本质指的是我们应该将职责委托给哪一个对象，这个职责可以是一个方法，也可以是一个算法或者其他内容。它是面向过程设计过程中最基本的原则。 委托原则:我们在设计对象的时候，如果某个对象拥有完成某个职责所需要的所有信息，那么这个职责就分配给这个对象实现。这个时候，这个类就是相对于这个职责的信息专家。 示例：我们在设计购物网站的时候，为避免重复，一种商品只能在购物车中出现一次，如果多次出现，则需要将其数量增加。这个时候我们在将物品放入购物车的时候，要首先判断当前物品是否在购物车中，判断两个物品是否为同一个物品的方法这个职责应该委托给谁呢？显而易见，商品类中有唯一标识，所以这个职责由商品类实现，而不是购物车。 创造者原则(creator)creator原则的本质是创建类对象职责应该委托给那个对象，也就是谁应该负责产生某个类的实例。 解决方案: 如果符合下面的一个或者多个条件，则可以将创建A的实例的职责分配给B; B包含A B聚合A B拥有初始化A的数据并在创建A的实例时将数据传递给A B记录A的实例 B频发使用A 满足上述一种或者多种情况的时候，我们应该奖创建A的实例的职责分配给B。 合理的creator原则带来的优点：如果职责分配合理，设计就能降低耦合，提高设计的清晰度，封装性和重用性。 示例:例如订单和商品的关系是聚合关系，这个时候我们将在订单中创建商品。 低耦合(Low coupling)耦合是评价一个系统中各个元素之间连接或者依赖关系强弱的尺度。低耦合的原则是我们在设计系统的时候尽量降低系统中各个元素之间的耦合度，这样对于系统的理解和维护都有很大的益处。 耦合性高的系统会带来的坏处: 一个类的修改导致其他类产生较大的影响； 系统难以维护和理解； 系统的重用性差，在重用一个高耦合类的时候，不得不重用它所依赖的所有类。 两个类具有以下特性中的其中一个，我们就说这两个类是耦合的： A具有一个类型为B的属性； A调用B的方法 A的方法包含对B的引用(参数或者返回值的方式) A是B的直接或者间接的子类 A是接口B的一种实现 低耦合系统的设计方法： 在类的划分上，尽量创建松耦合的类，类之间的耦合性越低，越有利于复用，修改一个类不会影响其他类。 在类的设计上，尽量降低类中成员和方法的访问权限。 在类的设计上，尽量将类设计为不变类 在类的引用上，将一个对象对另一个对象的引用降低到最小 高内聚(high cohesion)内聚是评价一个对象的职责被关联的尺度或者强弱，也可以说是功能性内聚的职责。也就是功能性紧密的相关职责应该放在同一个类中，并共同完成有限的功能。这样做更加有利于对类的理解和重用，也可以降低类的维护成本。 往往低内聚的系统设计会导致类的混乱，当对功能进行扩展或者改进的时候带来不必要的麻烦，低内聚的类也不利于重用，因为他们的职责如此之混乱。 为了达到高内聚，我们需要对类的职责进行分解，使分解出来的类具有独立的职责，满足单一职责原则。将一些需要在多个类中使用到的方法封装到一个类中，其他的类只负责他们需要负责的相关功能，这样我们可以提高类的内聚程度。 控制器原则(controller)控制器模式的实质是将一些系统事件的接受和处理委托给一个的对象controller，这个对象可以是一个类，系统或者子系统，它不与UI进行交互，它只负责系统信息的接收和处理。 一般情况下，控制器是一个系统，这个系统中包括多个处理器，分别对应处理不同的事务。通常情况下，一个控制器应当把要完成的功能委托给其他对象，而它只负责任务的协调控制和分配。 控制器原则与MVC模式相对应，MVC模式是一种比设计模式更高的架构模式。 多态原则(polymorphism)多态原则与面向对象设计原则中的多态概念类似，这里不再详细赘述。 纯虚构(pure Fabrication)纯虚构原则与我们所说的纯虚函数类似。 纯虚构的作用是用来解决高内聚和低耦合之间的矛盾的。高内聚低耦合是我们系统设计的终极目标，高内聚意味着我们要将类拆分成多个功能集中的类，但是拆分的多个类之间需要进行协作才能正常工作，这样又增加了类之间的耦合性。 纯虚构原则是用来解决上述问题的方案。它要求将一部分类的职责转移到纯虚构类中，在理想的情况下，分配给这种虚构类的职责是为了达到高内聚低耦合的效果。在实际的操作过程中，纯虚构类的实现又很多种方式，例如将数据库中操作的方法从数据库实体中分离出来，形成专门的数据访问类；通过对类的分解来实现类的重用，新增加的数据访问类对应于数据的持久化存储，这是软件开发过程中为了方便虚构出来的一个概念。一般情况下，纯虚构模式通常基于功能进行划分的。 中介模式(indirect)中介模式的目的是为了避免两个对象之间产生直接耦合，降低对象之间的耦合度。 解决方案是建立中间对象来协调两个对象之间的交互，避免耦合性过高。 受保护模式(protected variations)受保护模式的实质与OCP(开放闭合原则)类似，我们首先找到系统中不稳定的变化点，使用统一的接口封装起来，如果未来发生变化的时候，可以通过扩展接口来扩展新的功能，而不需要改变旧的代码。这样达到易于扩展的目的。","categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"grasp","slug":"grasp","permalink":"http://yoursite.com/tags/grasp/"}]},{"title":"创建型设计模式之build模式","slug":"创建型设计模式之build模式","date":"2017-01-07T17:36:19.000Z","updated":"2017-01-08T03:38:06.169Z","comments":true,"path":"2017/01/08/创建型设计模式之build模式/","link":"","permalink":"http://yoursite.com/2017/01/08/创建型设计模式之build模式/","excerpt":"","text":"创建型设计模式之build模式最近在读《设计模式-可复用面向对象软件设计的基础》一书，在阅读的过程中我会结合书中的相关知识和实例以及在网络上的博客对相关的模式的理解进行总结，并在此基础上加入自己的一些理解，总结模式中需要注意的一些点，记录在此博客，以供大家交流分享，同时防止自己对内容遗忘，如有不正确指出，欢迎批评指正。 本节的主要内容是设计模式中的创建型模式之一:builder模式 要用好builder模式，必须对其机制了解透彻，将该模式用在合适的软件中才能显出它真正的威力，第五部分中实例将为您展示它的真正威力。 本文内容分为以下几个方面: builder模式的意图 builder模式的适用性 builder模式的结构(通用UML类图)及详解 builder模式中的参与者 builder模式中各个成分之间的交互 builder模式比较好的一个实例 builder模式使用过程中注意的点 KFC套餐实例代码 builder模式的精髓都隐藏于builder模式的意图和实用性中，让你真正理解这两个方面，可以说你已经掌握了builder模式（以下意图和模式都摘自《设计模式》书中） builder模式的意图builder模式的意图是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 builder模式的适用性 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 提前记录一下:装配的工作是由导向器(director)完成的，复杂对象的创建是由具体的建造器完成(concreteBuilder)，这里不明白没问题，等你看完全文再过来看这里你就理解了。 当且仅当上面两个条件均满足的情况下我们要使用builder模式（完全理解这两条不一件重要的事情，但是不要着急,当你读完这篇文章的时候就会拨开它的庐山真面目了） builder模式的结构(UML类图)及详解builder模式的UML类图关系如下: 注意的问题: 在builder中一般不声明纯虚函数，而是把它们定义为空方法，这使客户只重定义他们感兴趣的操作。 在director中，注意我们不是把所有的buildPart都去执行一次，而是根据需要的客户的需求，进行定制的去buildPart部分构建，可以构建一次，也可以构建多次。 一般将m_product声明为protected成员，因为这样既保证了封装性，又能使得concreteBuilder能够正常操作product； builder模式种的参与者从上面的类图中我们也可以看出,在builder模式中的参与者有以下四种,以及他们的职责分别是:(此处为个人理解，与书中内容可能不一致,如果有问题欢迎指正) Director: 负责装配product的各个部件，使用Builder的类方法进行实现。它的作用是隔离了客户与product的具体生产过程；并负责控制product的生产过程。 Builder: 为创建一个product对象的各个部件指定抽象接口。一般情况下默认builderPart的操作默认为空。 concreteBuilder: 具体实现每一个部件的具体的复杂生产过程，如buildPartA()的具体实现，并提供一个检索产品的接口。 Product: 这个争议不大，即为被构造的复杂对象。此类对象会有不同的表示。 builder模式各个成分之间的交互方式先上一张时序图: 从上面的时序图可以分析出，各个成分之间的交互方式如下: 客户首先创建一个concreteBuilder对象,然后创建一个Director, 创建结束之后，使用concreteBuilder修饰对象Director, 然后调用Director的construct()方法，进行构造Product, 最后客户通过concreteBuilder的getResult()方法取回生成的Product builder模式中一个较好的实例两个实例来自网络对两本书籍实例的纠正,改编 上面这篇文章深刻的分析了builder模式的本质以及诸多误区的分析，收益颇多，在此感谢博主分享。 在本例中,设备(Equipment)是一个复杂对象，由一个machine和一个或多个输入端口(InputPort)或者输出端口(outputPort)组成；其中输入或输出端口可能有不同的类型(ordinary和super)。现在要你设计一个生成不同型号的产品，要求产品可能包含一进一出(普通或super)，一进两出(普通或super)。 在设计中,我们首先定义一个LCDFactory对象充当director，一个设备生成器(EQPBuilder),相当于Builder。 ​ 首先ordinary和super是port的内部实现方式不同，所以我们需要定义两个具体类，即 ordinaryEQPBuilder和superEQPBuilder。 ​ 在EQPbuilder中，我们将定义四个函数，分别是:buildMachine(), addInputPort(), addOutputPort()和getEQP()。两个concrete类继承EQPBuilder。 ​ 当我们需要获取不同数目的port的设备，这属于组装方面的范畴，所以我们将在LCDFactory中的createEQP中做。其UML类图如下: builder模式在使用的过程中需要注意的问题这里所说的注意的问题可能上面已经提到了，但是这里还是要着重强调一下，因为我们稍不注意，就可能将模式滥用，导致系统设计的失败。 在builder模式中Builder一定不要定义纯虚函数成员函数，而是定义为空方法的虚函数，这样就可以使得客户可以只定义他们感兴趣的操作。 Director负责装配产品，concreteBuilder负责实现复杂产品部件的具体实现 在Director中调用Builder的buildPart函数的时候，并不是每个函数都被调用，而是根据要生成的product对其选择性调用，可能调用零次，也可能调用多次。 Builder中的m_product声明为protected,即保证对象的封装性，又能让具体类方便的使用。(这是我在写代码的时候的解决方法，如果有更好的将m_product声明为private的解决方法欢迎交流2824759538@qq.com) KFC套餐实例代码这是本人使用KFC服务员生成套餐时的一种模拟，其实实际情况中并不需要使用builder模式，但是这里为了练手强行写成了builder模式，希望大家不要吐槽。 1234567891011121314//KFCWaiter.hpp 注意此处water相当于Director的作用#ifndef KFCWAITER_HPP_#define KFCWAITER_HPP_#include \"MealBuilder.hpp\"class KFCWaiter &#123;public: void setMealBuilder(std::shared_ptr&lt;MealBuilder&gt; t_builder); void construct();private: std::shared_ptr&lt;MealBuilder&gt; m_builder;&#125;;#endif 123456789//KFCWaiter.cpp#include \"KFCWaiter.hpp\"void KFCWaiter::setMealBuilder(std::shared_ptr&lt;MealBuilder&gt; t_builder) &#123; m_builder = t_builder;&#125;void KFCWaiter::construct() &#123; m_builder-&gt;buildFood(); m_builder-&gt;buildDrink();&#125; 123456789101112131415161718192021// Meal.hpp Meal相当于Product#ifndef MEAL_HPP#define MEAL_HPP#include &lt;iostream&gt;#include &lt;string&gt;class Meal &#123;public: Meal(std::string t_food = \"hanbao\", std::string t_drink = \"kele\"); ~Meal(); std::string getFood() const; std::string getDrink() const; void getMeal() const; void buildFood(const std::string &amp;t_food); void buildDrink(const std::string &amp;t_drink);private: std::string m_food; std::string m_drink;&#125;;#endif 1234567891011121314//Meal.cpp#include \"Meal.hpp\"Meal::Meal(std::string t_food, std::string t_drink) : m_food(t_food), m_drink(t_drink) &#123;&#125;Meal::~Meal() &#123;&#125;std::string Meal::getFood() const &#123; return m_food; &#125;std::string Meal::getDrink() const &#123; return m_drink; &#125;void Meal::getMeal() const &#123; std::cout &lt;&lt; \"套餐为:\" &lt;&lt; std::endl &lt;&lt; \"食物:\" &lt;&lt; m_food &lt;&lt; std::endl &lt;&lt; \"饮料:\" &lt;&lt; m_drink &lt;&lt; std::endl;&#125;void Meal::buildFood(const std::string &amp;t_food) &#123; m_food = t_food; &#125;void Meal::buildDrink(const std::string &amp;t_drink) &#123; m_drink = t_drink; &#125; 123456789101112131415161718//MealBuilder.hpp#ifndef BUILDER_HPP#define BUILDER_HPP#include \"Meal.hpp\"#include &lt;memory&gt;#include &lt;string&gt;class MealBuilder &#123;public: MealBuilder(); virtual void buildFood() = 0; virtual void buildDrink() = 0; std::shared_ptr&lt;Meal&gt; getResult(); virtual ~MealBuilder()&#123;&#125;;protected: std::shared_ptr&lt;Meal&gt; m_meal;&#125;;#endif 1234//MealBuilder.cpp#include \"MealBuilder.hpp\"MealBuilder::MealBuilder() : m_meal(std::shared_ptr&lt;Meal&gt;(new Meal())) &#123;&#125;std::shared_ptr&lt;Meal&gt; MealBuilder::getResult() &#123; return m_meal; &#125; 12345678910//MealBuilderA.hpp#ifndef MEALBUILDERA_HPP_#define MEALBUILDERA_HPP_#include \"MealBuilder.hpp\"class MealBuilderA : public MealBuilder &#123;public: virtual void buildFood(); virtual void buildDrink();&#125;;#endif 12345//MealBuilderA.cpp#include \"MealBuilderA.hpp\"void MealBuilderA::buildFood() &#123; m_meal-&gt;buildFood(\"套餐A食物\"); &#125;void MealBuilderA::buildDrink() &#123; m_meal-&gt;buildDrink(\"套餐A饮料\"); &#125; 12345678910//MealBuilderB.hpp#ifndef MEALBUILDERB_HPP_#define MEALBUILDERB_HPP_#include \"MealBuilder.hpp\"class MealBuilderB : public MealBuilder &#123;public: virtual void buildFood(); virtual void buildDrink();&#125;;#endif 12345//MealBuilderB.cpp#include \"MealBuilderB.hpp\"void MealBuilderB::buildFood() &#123; m_meal-&gt;buildFood(\"套餐B食物\"); &#125;void MealBuilderB::buildDrink() &#123; m_meal-&gt;buildDrink(\"套餐B饮料\"); &#125; 1234567891011121314//main.cpp#include \"KFCWaiter.hpp\"#include \"MealBuilderA.hpp\"#include \"MealBuilderB.hpp\"int main() &#123; std::shared_ptr&lt;MealBuilder&gt; Aptr = std::shared_ptr&lt;MealBuilder&gt;(new MealBuilderA()); KFCWaiter k; k.setMealBuilder(Aptr); k.construct(); std::shared_ptr&lt;Meal&gt; current_meal = Aptr-&gt;getResult(); current_meal-&gt;getMeal();&#125;","categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"UML时序图详解","slug":"UML时序图详解","date":"2017-01-07T07:17:23.000Z","updated":"2017-01-07T07:25:30.165Z","comments":true,"path":"2017/01/07/UML时序图详解/","link":"","permalink":"http://yoursite.com/2017/01/07/UML时序图详解/","excerpt":"","text":"UML时序图详解 这几天在阅读《设计模式》一书，书中总结了前人在面向对象软件设计过程中针对特定的问题提出的简洁而优雅的解决方案。在阅读的过程中，我一边理解书中给出的实例，一边结合自己写过的项目或者用过的框架与当前模式进行对比，发现之前的项目有一些还是有很大的改进空间。在阅读本书的过程中，书中很多例子都是通过UML类图和UML时序图进行说明，所以，理解这些例子的前提是对UML类图以及UML时序图有一定的了解，UML类图在前面的博客(https://langzi989.github.io/2017/01/05/UML%E5%9B%BE%E8%A1%A8%E7%A4%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/)中已经讲解，现在我们主要来看一下UML时序图中的重要概念。 UML类关系以及时序图在大三上《系统分析与设计》课的时候学过，但是那个时候不知道这东西有什么用，所以没有认真学和理解。随着实战经验的增多，越来越能体会到这些在软件设计的过程中重中之重，不管是描述你的设计思想还是与团队中其他人进行交流。所以还是建议大家在学到这一部分的时候对这门课认真对待。 定义时序图是一种按照时间顺序显示对象之间的交互的图。时序图中显示的是参与交互的对象和对象之间消息传递的顺序。 基本元素时序图中包含的主要的元素有: 角色(Actor) 对象(Object) 生命线(life line) 控制焦点(focus of control) 消息(message) 自关联消息(self-associated message) 组合片段(combined fragment) 基本元素详解角色(actor)角色指的是系统角色，这个角色可以是人，其他系统或者子系统 图形表示: 对象(object)对象包括三种: 指定类名和对象名的对象objectName: className 指定类名但没有对象名的对象(匿名对象) :className 指定对象名但不指定类名的对象 objectName 图形表示：第一类: 第二类: 第三类: 生命线(life line)生命线在时序图中使用向下的虚线表示,它指的是其所对应的对象的存活时间。从上到下表示时间的推后。 图像表示: 控制焦点(focus of control)控制焦点在时序图中以方块的形式出现，它是一种表示时间段的方式，对象在这一时间段中执行相应的操作。 图像表示: 消息(message)消息有三种类型 同步消息：发送者发送请求后被阻塞，直到接受者返回消息或者做完其他处理之后发送者才能继续执行之后的操作 异步消息：发送者发送消息给接受者之后不等待接受者返回响应而继续执行下面的操作。 返回消息:接受者返回消息给发送者 消息的图形表示：同步消息: 异步消息: 返回消息: 自关联消息(self-associated message)自关联消息一般指的是当前类调用自己的函数的情况 组合片段(combined fragment)组合片段中包括四个部分: Alternative fragment(alt表示):与if…then…else…对应 option fragment(opt表示):与switch对应 parallel fragment(par表示):表示同时发生 Loop Fragment(loop表示):与循环对应 图形表示: alt:","categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://yoursite.com/tags/UML/"}]},{"title":"UML图表示常见的类之间的关系","slug":"UML图表示常见的类之间的关系","date":"2017-01-05T13:12:28.000Z","updated":"2017-01-05T13:16:34.933Z","comments":true,"path":"2017/01/05/UML图表示常见的类之间的关系/","link":"","permalink":"http://yoursite.com/2017/01/05/UML图表示常见的类之间的关系/","excerpt":"","text":"UML图表示常见的类之间的关系类之间的关系常见的主要包括以下几种: 继承 实现 依赖 关联 聚合 组合 继承（inheritance）继承的概念大家都比较熟悉，他主要指的是派生类继承父类或者接口之间的继承，派生类继承了父类中原有的功能，并在此基础上添加了新的功能。例如public继承实质上是一种is-a的关系,(子类is a 基类) 图形表示: 实现(implement)实现指的是一个类实现一个接口,一个类可以实现一个或者多个接口。实现是类和接口之间常见的一种关系。在java中通常通过implements实现。 图形表示： 依赖依赖指的是一个类A使用另外一个类B,这种该使用关系是偶然性的，临时的，非常弱的一种关系。但是类B的变化会影响到类A;比如人要使用船过河中，这个时候人和船就是一种依赖关系。具体表现在代码中就是B是类A中的某个方法的参数。 图形表示: 关联关联是指俩个类之间的或者类和接口之间的一种强依赖关系。而这种强依赖关系不是偶然性的，而是长期的，而且双方的关系是平等的，关联可以是单向的，也可以是双向的。具体表现在代码中是(1):B以类属性的方式出现在类A中（２）A引用类型为B的全局变量 图形表示: 聚合聚合是关联关系的一种特例，它表现的是一种has-a的关系，即整体与部分的关系，此时整体与部分可以是分离的，他们可以具有各自的声明周期，部分可以属于多个整体对象，也可以被多个整体对象共享；如计算机与CPU的关系聚合中部分和整体都有各自的生命周期，并且互相影响 图形表示： 组合组合也是关联的一种特例，它体现的是一种contain-a的关系，这种关系比聚合强；这个时候整体和部分是不可分离的，整体的声明周期与部分的声明周期相同，当整体的周期结束时，部分的周期也随之结束。如人和大脑的关系 图形表示： 依赖性强弱:组合&gt;聚合&gt;关联&gt;依赖","categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://yoursite.com/tags/UML/"}]},{"title":"docker防止fork炸弹","slug":"docker防止fork炸弹","date":"2016-12-29T11:00:25.000Z","updated":"2016-12-29T13:01:08.965Z","comments":true,"path":"2016/12/29/docker防止fork炸弹/","link":"","permalink":"http://yoursite.com/2016/12/29/docker防止fork炸弹/","excerpt":"","text":"docker防止fork炸弹在开发过程中，我们使用了docker作为容器来进行编程语言代码的评测，以用于防止有害代码破坏宿主物理机器，但是在昨天发现docker还是会受fork炸弹的影响将宿主物理机器挂掉。针对这个问题，我在docker官网找到了相关的解决方法，记录分享并以备之后再次遇到此类问题可以很快找到解决方案。当前解决方案只适用于docker1.1版本及之后(通过docker.io进行安装,sudo apt install docker.io)。解决方案的思想就是:在启动docker的时候给其加上启动选项–pids-limit来限制cgroup中的fork的进程的最大数，我这里限制的30,可以根据自己的需求去限制。1docker run -it --pids-limit 30 Ubuntu:14.04 上述方法即可防止fork炸弹。以下内容转载自http://blog.csdn.net/thinkhy/article/details/50995720 Docker容器与安全Docker能否大规模用于生产环境，尤其是公有云环境，就在于Docker是否能提供安全的环境。本文将总结《Docker容器与容器云》一书3.9节『Docker与容器安全』的主要内容，包括Docker现有安全机制、存在的安全问题以及Docker安全增强三个方面。 1. Docker的安全机制1.1 Docker daemon安全 Docker向外界服务提供了四种通信方式，默认是以Unix域套接字的方式来与客户端通信，这种方式较TCP形式更为安全。 Docker也提供了TLS传输层安全协议，通过–tlsverify(安全传输校验），–tlscacert(信任证书)、–tlskey(服务器或者客户端秘钥）、–tlscert（证书位置）来配置。1.2 镜像安全 Docker registry镜像库访问控制 Docker daemon第一次启动时，通过公网（Amazon CDN）载入official.json包，饮食公共image和用户image的目录以及数字签名信息。 official.json在Docker daemon启动时加载到MemoryGraph，MemoryGraph用于存储公钥以及命名之间的授权映射，默认授权节点对授权空间有读写权限。 镜像校验和 镜像校验和用来保证镜像的完整性，以预防可能出现的镜像破环。 目前Docker对于镜像校验和和验证失败不采取任何措施，仅输出警告信息1.3 内核安全 内核为容器提供了两种技术cgroup和namespace，分别对容器进行资源限制和资源隔离。 容器本质是进程，cgroup用来限制容器的资源使用量，避免单个容器耗尽系统资源。 namespace用来隔离容器与宿主机，以及不同的容器。 Docker目前仅完整支持uts、ipc、pid、network、mount这5种ns,user ns尚未完全支持。 系统资源未进行隔离，如/proc，/sys、SELinux、time、syslog、/dev设备信息等均未进行隔离。1.4 容器之间的网络安全 Docker可通过iptabls设定规则实现禁止或允许容器之间的通信。1.5 Docker容器Capability限制 容器的行为通过Linux超级用户分组限制，具体包括了CHOWN、DAC_OVERRIDe、FSETID、FOWNER、MKNOD、NET_RAW、SETGID、SETUID、SETFCAP、SETPCAP、NET_BIND_SERVICE、SYS_CHROOT、KILL和AUDIT_WRITE。 Docker进程的Capability可通过docker run命令的参数进行配置2. Docker安全问题2.1 磁盘资源限制问题 Docker容器通过镜像层叠的方式来构建容器内的文件系统，本质上还是在宿主机文件系统的目录(/var/lib/docker)下存储文件。 极有可能出现一个容器将宿主机上所有的磁盘空间耗尽，导致其它容器无法存储文件，所以有必要对容器的磁盘使用量进行限制。2.2 容器逃逸问题 Docker使用操作系统进行虚拟化，共享内核、内存、CPU以及磁盘，易造成容器逃逸问题。 Docker1.0之后采用白名单来限制容器的能力，会给出默认的容器Capability清单，禁止容器拥有清单之外的Capability。2.3 容器DoS攻击与流量限制问题 公有云基于虚拟化技术实现，攻击数据包可能不需要通过物理网卡就可以攻击同一个宿主机下的其他容器，传统Dos预防措施无法适用容器之间的攻击。 的Docker容器连接在网桥上，通过veth pari技术创建网卡，其一端在容器内命名为eth0，另一张网上驻留在宿主机环境之中。 同一宿主机下所有容器共用一张物理网卡，如果一个容器抢占大部分带宽，会影响其它容器使用。2.4 超级权限问题 docker run时加入–privileged参数能使容器获得所有的超级用户权限能力，并将所有的宿主机的所有设备挂载到容器内。3. Docker安全的解决方案3.1 SELinux SELinux三种控制方式 Type Enforcement: 主要的访问控制机制。 Role-Based Access Control(RBAC)：基于SELinux用户的权限控制手段。 Multi-Level Security(MLS): 多级分类安全，指定level标签。 为什么要在Docker中使用SELinux SELinux将所有进程和文件打上标签，而容器以进程方式运行，所以控制进程如何访问资源，也就是限制容器如何去访问资源。 SELinux策略是全局的，它不是针对具体用户设定，而是强制整个系统遵循。 减少提权攻击风险。3.2 user namespace 容器的超级用户权限通过ns映射到宿主机是一个普通用户。 容器被恶意程序攻击，所做的也就是这个普通用户的权限，而非宿主机的超级权限。3.3 磁盘限额 Docker仅对Device Mapper文件系统的限额提供了–storage-opt参数进行限制。 cgroup没有对磁盘进行限制，Linux磁盘限额技术主要基于用户和文件系统。 可能的解决方案 所有用户共有宿主机的一块磁盘，限制用户在磁盘上的使用量来限定容器的磁盘使用量。 选择支持目录限额的文件系统，如XFS。 Docker定期检查每一个容器磁盘使用量，会对性能造成影响。 创建虚拟文件系统，些文件系统仅供某一个容器使用。3.4 容器流量限制 Docker没对容器的网络带宽做限制。 可以采用Traffic Controller容器对容器网卡流量进行限制，一定程序上减少容器Dos攻击危害。3.5 GRSecurity内核安全增强工具 Docker容器共享宿主机的内存，在内存安全上存在不少问题，需要针对内存破坏做防御。 GRSecurity是一个对内核的安全扩展，通过智能访问控制来阻止内存破坏，预防0day漏洞。3.6 fork炸弹 fork炸弹以极快速度创建大量进程，以此消耗系统资源，使系统无法运行新程序，现有进程运行速度放缓。 容器本身在内核层面隔离性不足，fork bomb会给容器带来灾难性影响。 fork bomb受到社区关注（Issue 6479），但目前还没有完美解决方案。 Docker无法使用ulimit来限制forkbomb问题，因为一个宿主机用户可能同时启动多个容器，无法对每个容器做进程数的限制。 总结Docker自身已经提供了不少安全机制，但Docker目前仍然只适于运行可信应用程序（内部使用），如果需要运行任意代码，安全很难得到保证。在日常应用中，还可以通过SELinux、GRSecurity、seccomp等工具来增强容器安全。","categories":[{"name":"docker技术","slug":"docker技术","permalink":"http://yoursite.com/categories/docker技术/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"time命令详解","slug":"time命令详解","date":"2016-12-27T13:18:33.000Z","updated":"2016-12-27T15:19:33.189Z","comments":true,"path":"2016/12/27/time命令详解/","link":"","permalink":"http://yoursite.com/2016/12/27/time命令详解/","excerpt":"","text":"Linux time命令详解参考:http://blog.he96.com/2011/01/linux-timewhat-do-real-user-and-sys.html real,user,sys我们常用linux中的time命令计算某个程序的运行耗时，用户态CPU耗时，系统态COU耗时。例如:1234time fooreal 0m0.020suser 0m0.020ssys 0m0.000s 现在我们探讨一下上述三个时间分别代表的含义: real: 表示a.out程序的实际的运行耗时，也就是在a.out运行开始时刻你看了一下手表，a.out运行结束时刻看了一眼手表，两次时间的差值就是real的值。例如使用time sleep 2的时候real值为2 user: a.out运行在用户态CPU的时间 sys: a.out运行在核心态CPU的时间 用户态和核心态然后我们讲一下用户态和核心态： 核心态(kernal mode): 在内核态，代码拥有完全的，不受任何限制的访问底层硬件的能力。可以执行任意的CPU指令，访问任意的内存地址。内核态通常情况下，都是为哪些最底层的，由操作系统提供的，可信可靠耳朵代码来运行的。内核态崩溃将是灾难性的，它会影响到整个系统。 用户态(User mode):在用户态，代码不具备直接访问底层硬件或者内存的能力，而必须借助操作系统提供的可靠的,底层的API来访问硬件或者内存。由于这种隔离带来的保护作用，用户态代码崩溃，操作系统可以正常恢复。我们大多数代码是运行在用户态。 区分内核态和用户态的作用:隔离保护，使得系统更稳定。使用这三个时间我们可以计算当前程序CPU的使用率：CPU Usage = (user + sys) / real_time 常见误区 realtime = user + sys realtime &gt; user + sys由于有一些程序需要等待I/O等导致realtime与user+sys不相等当在多核CPU的情况下第二种情况不成立","categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"C++前置声明","slug":"C-前置声明","date":"2016-12-22T14:08:31.000Z","updated":"2016-12-22T16:10:28.499Z","comments":true,"path":"2016/12/22/C-前置声明/","link":"","permalink":"http://yoursite.com/2016/12/22/C-前置声明/","excerpt":"","text":"C++前置声明以个人理解，C++的前置声明的意思是在类定义之前对其进行声明。它在现实编程的场景中可以解决很多问题。比如解决两个类相互依赖的问题，降低类之间的编译依存关系等等。 实际场景我们分别定义一个锁(Lock)和钥匙(Key)的类(默认一把钥匙只能开一把锁，一把锁只能被一把钥匙打开)。代码如下：Lock.hpp12345678#include \"Key.hpp\"class Lock &#123; public: Lock(); virtual ~Lock(); private: Key m_key;&#125; Key.hpp12345678#include \"Lock.hpp\"class Key &#123; public: Key(); virtual ~Key(); private: m_lock;&#125; 这个时候出现了两个类相互包含的情况，因为在编译Lock.cpp的时候，我们需要去查看Key的定义，于是去定义Key,在Key中需要Lock的定义，于是又去构造Lock,这样下去，就出现了一个无限循环包含的情况，有些编译器会直接编译错误，而其他编译器会无限包含下去。这该怎么办呢？有办法，C++为我们提供了前置声明。前置声明是什么？就这个例子来讲，我们要造一把锁，光有锁不行啊，我们还得有能打开这把锁的钥匙。但是锁还没有造好，总不能先打造钥匙吧，钥匙的形状我定了，改天在造。先把锁造好，造锁的时候我要先给要是留一个位置，等锁造好了，我再决定造什么样的钥匙。前置声明就是我在声明一个类(Lock)的时候,用到了另外一个类（Key）的定义，但是Key还没定义呢，而且我先不需要Key的定义，只需要直到Key是一个类就好了。那好，我就先声明类Key,告诉编译器Key是一个类(不需要包含Key.hpp)1class Key; 然后在Lock中用到Key的时候，都用指针或者引用代替(因为指针是固定大小的，但Key的大小只有知道了Key的定义才能确定)。然后上面的代码就可以改造为如下： Lock.hpp12345678class Key;class Lock&#123; private: Key *mp_key; public: Lock(); virtual ~Lock();&#125;; Key.hpp12345678class Lock;class Key &#123; private: Lock* mp_lock; public: Key(); virtual ~Key();&#125; 前置声明注意的问题必须使用前置声明的指针或引用形式在需要使用前置声明的文件中，不可以使用类的定义式，因为类的定义式只有在类定义之后才能获取，这个时候类还没有定义，所以会出错。另一个类在构造的时候编译器是需要计算该对象所占的字节的大小给其分配内存的，但是如果使用类的定义式，这个时候类还未定义，所以无法计算其大小，所以只能使用指针或者引用的形式进行引用。 避免在Lock中使用Key的方法避免在Key定义之前调用Key的析构函数","categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"条款27:尽量少做转型动作","slug":"条款27-尽量少做转型动作","date":"2016-12-21T12:57:15.000Z","updated":"2016-12-21T14:28:46.924Z","comments":true,"path":"2016/12/21/条款27-尽量少做转型动作/","link":"","permalink":"http://yoursite.com/2016/12/21/条款27-尽量少做转型动作/","excerpt":"","text":"条款27:尽量少做转型动作(Effective C++)C++规则设计的目标之一是，保证类型错误决不可能发生。理论上如果你的程序很干净的通过编译，就表示它并不企图在任何对象身上执行任何不安全，无意义，愚蠢荒谬的操作。这是一个及其具有价值的保证，不要轻易放弃它。但是在很多种情况下，我们不得不进行转型操作，转型操作破坏了类型系统。这可能会导致任何可能种类的麻烦，有些容易辨识，但是有些可能会很隐晦。所以在需要进行转型操作的时候一定要慎重，尽量通过设计避免不必要的转型操作。 类型转换的形式首先我们回顾一下类型转换的语法，因为通常有三种不同的形式，可写出相同的类型转换动作。 C风格类型转换： (T)expression //将expression转换为类型T 函数式风格类型转换： T(expression) //同上上面的两种形式并无差别，纯粹只是把小括号摆放的位置不同而已，我们称上述两种转为为”旧式转型”(old style cast)。 C++还提供四中新式转型(new style): const_cast&lt; T &gt;(expression) dynamic_cast&lt; T &gt;(expression) reinterpret_cast&lt; T &gt;(expression) static_cast&lt; T &gt;(expression) const_cast通常被用来将对象的常量性移除(cast away the constness)。它也是唯一有此能力的C++-style转型操作符。 dynamic_cast主要用来执行类型向下转型(safe downcasting),也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一一个可能耗费重大运行成本的转型动作。 reinterpret_cast 意图执行低级转型，实际动作及结果可能取决于编译器。这也就表示它不可移植，例如将一个pointer to int 转型为int。这一类型转换在低级代码以外很少见。 static_cast 用来强迫隐式转换(implicit conversion)，例如将non-const对象转换为const对象，或者将int转换为double等等。也可以用来执行上述多种转换的反向转换,例如将void指针转换为type指针，将pointer to derive 转化为point to bas。但是无法将const转换为non-const。 dynamic_cast与static_cast详解 static_cast是用来强迫隐式类型转换，它可以用于1.基本数据类型以及指针之间的转换；2.类层次中基类与子类成员函数指针的转换；3.类层次结构中基类与子类指针或者引用之间的转换。 dynamic_cast可以用于1.继承关系中类指针或者引用之间的转换；2.包含虚函数之间对象指针的转换3.以及保证转换的安全性。 static_cast用于基本数据类型转换和指针之间的转换12345678char a;int b = static_cast&lt;int&gt;(a);char c = static_cast&lt;char&gt;(b);char *pa = NULL;int *pb = (int*)pa;pb = static_cast&lt;int*&gt;(pa); //编译错误static_cast只能用于void指针和type指针之间的转换void *pv = static_cast&lt;void*&gt;(pa); //正确pb = static_cast&lt;int*&gt;(pv); 类层次中基类与子类成员函数指针的转换12345678910111213141516171819202122class base &#123;public: base(int t_data) : m_data(t_data) &#123;&#125; void printData() &#123; std::cout &lt;&lt; m_data &lt;&lt; std::endl; &#125;private: int m_data;&#125;;class child : public base &#123;public: child(int t_data) : base(t_data) &#123;&#125; void printData() &#123; std::cout &lt;&lt; \"this is in the child\" &lt;&lt; std::endl; &#125;&#125;;typedef void (base::*basefun)();int main() &#123; base a(10); basefun func = &amp;base::printData; func = static_cast&lt;basefun&gt;(&amp;child::printData); (a.*func)(); //this is in the child&#125; 类层次结构中基类与子类指针或者引用之间的转换上行转换:子类指针或引用转换为基类的指针或引用 —安全下行转换:基类的指针或者引用转换为子类的指针或引用 —危险(避免这样做)123456789101112131415161718192021222324252627282930class A&#123;&#125;;class B:public A&#123;&#125;;class C:public A&#123;&#125;;class D&#123;&#125;;A objA;B objB;A* pObjA = new A();B* pObjB = new B();C* pObjC = new C();D* pObjD = new D();objA = static_cast&lt;A&amp;&gt;(objB); //转换为基类引用 objA = static_cast&lt;A&gt;(objB);objB = static_cast&lt;B&gt;(objA); //error 不能进行转换 pObjA = pObjB; //right 基类指针指向子类对象//objB = objA; //error 子类指针指向基类对象pObjA = static_cast&lt;A*&gt;(pObjB); //right 基类指针指向子类pObjB = static_cast&lt;B*&gt;(pObjA); //强制转换 OK 基类到子类//pObjC = static_cast&lt;C*&gt;(pObjB); //error 继承于统一类的派生指针之间转换//pObjD = static_cast&lt;D*&gt;(pObjC); //error 两个无关联之间转换 dynamic_cast继承关系的类指针对象或者引用之间的转换若积累中没有虚函数，使用dynamic_cast可以将子类的指针或引用转换为基类的指针或引用，与static_cast用法相同，不同的是,这个时候使用dynamic_cast将基类指针转换为子类指针的时候会出现编译错误(static_cast不会，但是很危险)。12345678910111213141516171819202122232425262728class A&#123;&#125;;class B:public A&#123;&#125;;class C:public A&#123;&#125;;class D&#123;&#125;;A objA;B objB;A* pObjA = new A();B* pObjB = new B();C* pObjC = new C();D* pObjD = new D();//objA = dynamic_cast&lt;A&gt;(objB); //error 非引用objA = dynamic_cast&lt;A&amp;&gt;(objB);//objB = dynamic_cast&lt;B&amp;&gt;(objA); //error A 不是多态类型不能转换 若有虚函数则可以进行转换pObjA = dynamic_cast&lt;A*&gt;(pObjB);//pObjB = dynamic_cast&lt;B*&gt;(pObjA); //error A 继承关系 不是多态类型不能转换//pObjB = dynamic_cast&lt;B*&gt;(pObjC); //error C 兄弟关系 不是多态类型不能转换//pObjB = dynamic_cast&lt;B*&gt;(pObjD); //error D 没有关系 不是多态类型不能转换 包含有虚函数之间的对象指针的转换使用dynamic_cast将基类指针转换为子类指针的时候并不是永远有效：只有基类指针本身指向的就是一个派生类对象的时候有效。其他时候结果为NULL;12345678910111213141516171819class A&#123;Public: Virtual ~A()&#123;&#125;&#125;;class B:public A&#123;&#125;;class C:public A&#123;&#125;;class D&#123;Public:Virtual ~D()&#123;&#125;&#125;;pObjB = dynamic_cast&lt;B*&gt;(pObjA); // worning 继承关系 父类具有虚函数 多态pObjB = dynamic_cast&lt;B*&gt;(pObjD); //worning 没有关系 D是多态类型可以转换//以上结果：pObjB == NULL 此处会发生一个运行时错误 dynamic_cast转换的安全性当涉及到基类和派生类对象之间的转换的时候，总使用dynamic_cast会避免很多错误，它是安全的，但是它会给程序运行带来巨大的开销。当子类指针转换为基类指针的时候,两种转型都OK,dynamic_cast开销较大。当基类指针转换为派生类指针的时候，若基类中没有虚函数，static_cast不会报错，但是做法很危险，dynamic_cast编译不通过。当含有虚函数的时候，若基类指针没有指向派生类，这个时候会返回NULL,所以也是安全的。 虚函数对于dynamic_cast转换的作用为什么dynamic_cast转换类指针的时候需要虚函数呢？dynamic_cast转换是在运行时进行转换，运行时转换就需要知道类对象的信息(继承关系等)。在运行时或者这个信息的是虚函数表指针，通过这个指针可以获取到该类对象的所有的虚函数，包括父类的。因为派生类会继承基类的虚函数表，所以通过这个虚函数表，我们就可以知道类对象的父类，在转换的时候就可以用来判断对象有无继承关系。所以虚函数对于正确的基类指针转换为子类指针是非常重要的。 effective的三点建议 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。 如果转型是必要的，试着将它隐藏与某个函数的背后。客户随后可以调用该函数，而不需要将转型放到他们自己的代码中。 宁可使用C++-style转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌","categories":[{"name":"effective C++","slug":"effective-C","permalink":"http://yoursite.com/categories/effective-C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"通过/proc/meminfo实时获取系统内存使用情况","slug":"通过-proc-meminfo实时获取系统内存使用情况","date":"2016-12-19T15:43:49.000Z","updated":"2016-12-19T21:00:44.288Z","comments":true,"path":"2016/12/19/通过-proc-meminfo实时获取系统内存使用情况/","link":"","permalink":"http://yoursite.com/2016/12/19/通过-proc-meminfo实时获取系统内存使用情况/","excerpt":"","text":"通过/proc/meminfo实时获取系统内存使用情况(Linux)linux内核提供了一种通过/proc文件系统来在运行时访问内核内部数据结构，改变内核设置的机制，各种硬件平台上的linux系统的/proc文件系统的基本概念都是相同的。/proc文件系统是一种内核和内核模块用来向进程发送信息的机制。这个伪文件系统可以和内核内部的数据结构进行交互，获取实时的进程信息。注意，/proc文件系统是存储与内存而不是硬盘,/proc虚拟文件系统实质是以文件系统的形式访问内核数据的接口。 /proc/meminfolinux系统中/proc/meminfo这个文件用来记录了系统内存使用的详细情况。其中top，free命令中的数据是通过这个文件中的信息计算并按照特定的格式进行显示。/proc/meminfo内容详解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$cat /proc/meminfoMemTotal: 8052444 kBMemFree: 2754588 kBMemAvailable: 3934252 kBBuffers: 137128 kBCached: 1948128 kBSwapCached: 0 kBActive: 3650920 kBInactive: 1343420 kBActive(anon): 2913304 kBInactive(anon): 727808 kBActive(file): 737616 kBInactive(file): 615612 kBUnevictable: 196 kBMlocked: 196 kBSwapTotal: 8265724 kBSwapFree: 8265724 kBDirty: 104 kBWriteback: 0 kBAnonPages: 2909332 kBMapped: 815524 kBShmem: 732032 kBSlab: 153096 kBSReclaimable: 99684 kBSUnreclaim: 53412 kBKernelStack: 14288 kBPageTables: 62192 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 12291944 kBCommitted_AS: 11398920 kBVmallocTotal: 34359738367 kBVmallocUsed: 0 kBVmallocChunk: 0 kBHardwareCorrupted: 0 kBAnonHugePages: 1380352 kBCmaTotal: 0 kBCmaFree: 0 kBHugePages_Total: 0HugePages_Free: 0HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kBDirectMap4k: 201472 kBDirectMap2M: 5967872 kBDirectMap1G: 3145728 kB 详解： MemTotal: 所有内存(RAM)大小,减去一些预留空间和内核的大小。 MemFree: 完全没有用到的物理内存，lowFree+highFree MemAvailable: 在不使用交换空间的情况下，启动一个新的应用最大可用内存的大小，计算方式：MemFree+Active(file)+Inactive(file)-(watermark+min(watermark,Active(file)+Inactive(file)/2)) Buffers: 块设备所占用的缓存页，包括：直接读写块设备以及文件系统元数据(metadata)，比如superblock使用的缓存页。 Cached: 表示普通文件数据所占用的缓存页。 SwapCached: swap cache中包含的是被确定要swapping换页，但是尚未写入物理交换区的匿名内存页。那些匿名内存页，比如用户进程malloc申请的内存页是没有关联任何文件的，如果发生swapping换页，这类内存会被写入到交换区。 Active: active包含active anon和active file Inactive: inactive包含inactive anon和inactive file Active(anon): anonymous pages（匿名页），用户进程的内存页分为两种：与文件关联的内存页(比如程序文件,数据文件对应的内存页)和与内存无关的内存页（比如进程的堆栈，用malloc申请的内存），前者称为file pages或mapped pages,后者称为匿名页。 Inactive(anon): 见上 Active(file): 见上 Inactive(file): 见上 SwapTotal: 可用的swap空间的总的大小(swap分区在物理内存不够的情况下，把硬盘空间的一部分释放出来，以供当前程序使用) SwapFree: 当前剩余的swap的大小 Dirty: 需要写入磁盘的内存去的大小 Writeback: 正在被写回的内存区的大小 AnonPages: 未映射页的内存的大小 Mapped: 设备和文件等映射的大小 Slab: 内核数据结构slab的大小 SReclaimable: 可回收的slab的大小 SUnreclaim: 不可回收的slab的大小 PageTables: 管理内存页页面的大小 NFS_Unstable: 不稳定页表的大小 VmallocTotal: Vmalloc内存区的大小 VmallocUsed: 已用Vmalloc内存区的大小 VmallocChunk: vmalloc区可用的连续最大快的大小 通过/proc/meminfo实时获取系统内存使用情况http://man.linuxde.net/free目前我们希望实时获取系统中内存的使用情况，实际可以挪用的内存数为free+cache+buffer,实际使用的内存数为used-cache-buffer(total-free-cache-buffer),","categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"memory","slug":"memory","permalink":"http://yoursite.com/tags/memory/"}]},{"title":"通过/proc/stat计算linux系统即时CPU使用率","slug":"通过-proc-stat计算linux系统即时CPU使用率","date":"2016-12-18T22:03:09.000Z","updated":"2016-12-18T22:03:35.949Z","comments":true,"path":"2016/12/19/通过-proc-stat计算linux系统即时CPU使用率/","link":"","permalink":"http://yoursite.com/2016/12/19/通过-proc-stat计算linux系统即时CPU使用率/","excerpt":"","text":"通过/proc/stat计算linux系统即时CPU使用率/proc/stat/proc文件系统是一个伪文件系统，它存在于内存中，不占用外存空间。它以文件系统的方式为内核与进程提供通信接口。用户和应用程序可以通过/proc得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程是动态改变的，所以用户或应用程序读取/proc目录中的文件的时，/proc文件系统是动态从系统内核读出所需信息并提交的。在linux或Ubuntu系统中，/proc/stat文件记录了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前的值。我们可以通过一个较小的时间段的CPU利用率值来估算某一个时刻的CPU利用率。首先我们先来查看一下/proc/stat中的内容：123456$ cat /proc/statcpu 15543 334 4963 142337 3413 0 180 0 0 0cpu0 3877 142 1137 35988 615 0 28 0 0 0cpu1 3866 23 1068 35982 608 0 74 0 0 0cpu2 4104 159 1333 35395 735 0 59 0 0 0cpu3 3695 9 1424 34970 1454 0 18 0 0 0 上面的信息中前八个是比较重要的。 user(15543): 从系统启动到当前时刻，处于用户态的时间(用户空间的CPU时间)，不包括nice为负值的进程。 nice(334): 从系统启动到当前时刻，nice值为负的进程所占的CPU时间。 system(4963): 从系统启动到当前时刻，处于内核状态的CPU时间。 idle(142337): 从系统启动到当前时刻，除了I/O等待时间以外的其他等待时间 iowait(3413): ~，IO等待时间 irq(0): ~, 硬中断时间 softrq(180): ~,软中断时间。 steal: ~,在虚拟环境中运行的时间。 总的CPU时间为：total = user+nice+system+idle+iowait+irq+softrq 计算当前时刻的CPU使用率我们使用距离当前时刻较小的间隔的时间段的CPU使用率近似当前时刻的CPU使用率。12CPU Usage=1 - (△idle+△iowait) / △total_time =1 - (idle2+iowait2 - idle1 - iowait1) / (total_time2 - total_time1)","categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"linux进程nice值及其与优先级的关系","slug":"linux进程nice值及其与优先级的关系","date":"2016-12-18T20:25:04.000Z","updated":"2016-12-18T20:26:48.601Z","comments":true,"path":"2016/12/19/linux进程nice值及其与优先级的关系/","link":"","permalink":"http://yoursite.com/2016/12/19/linux进程nice值及其与优先级的关系/","excerpt":"","text":"linux进程nice值及其与优先级的关系在linux多任务环境的系统中，系统是根据进程的优先级(priority)给进程进行分配资源。优先级越高的进程越有优先执行的权利。配置进程优先权碎玉linux很有用，可以大大改善系统的性能。还可以把指定的进程运行在指定的cpu上。 nice与priority在linux中使用ps 的-l参数可以对进程的优先权信息进行查看：123456$ ps -l#打印信息:F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD0 S 1000 5242 5232 0 80 0 - 7461 wait pts/1 00:00:00 bash4 T 1000 5881 5242 0 80 0 - 12247 signal pts/1 00:00:01 top4 R 1000 6386 5242 0 80 0 - 8996 - pts/1 00:00:00 ps 从上面可以看出,上表中打印出一些有用的信息： UID: 进程的user id PID: 进程ID PPID: 当前进程的父进程的ID PRI: 优先级(pri越小优先级越高) NI: nice值，当前进程的nice值前三个值比较容易理解，pri和NI的含义，pri比较好理解，即进程的优先级，pri越小，优先级越高，那nice值呢？nice表示进程可被执行的优先级的修正数值。如前面说的，pri越小越优先被执行，那么加入nice之后pri(new)=pri(old)+nice。这样,当nice为负值的时候，该程序的pri变小，优先级越高。 注意:进程的nice值不是进程的优先级，但是会影响进程优先级的变化。 nice相关linux命令nice与renice1.nice的作用是启动时设置nice的值1ice -n -5 ./MatrixJudge &amp; -n参数用于指定nice值2.renice的作用是修改已经存在的进程的nice值1renice -5 -p 10000 上述的意思是将PID为10000的nice值置为-5,-p参数用于指定PID。","categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"tornado表单与模板","slug":"tornado表单与模板","date":"2016-12-16T15:48:06.000Z","updated":"2016-12-30T14:07:06.063Z","comments":true,"path":"2016/12/16/tornado表单与模板/","link":"","permalink":"http://yoursite.com/2016/12/16/tornado表单与模板/","excerpt":"","text":"tornado表单和模板在第一章中，我们学习了使用tornado创建一个web应用的基础知识。包括处理函数，HTTP方法以及tornado的框架的总体结构。在这一章中，我们学习tornado的更加强大的功能—-表单和模板。和大多数的web框架一样，tornado的一个重要的目标就是帮助你更快地编写程序，尽可能整洁地复用更多的代码。尽管tornado灵活，可以使用几乎所有python支持的模板语言，tornado自身也提供了一个轻量级，快速并且灵活的模板语言，在tornado.template模块中。 简单示例 Poem Maker Propoemmaker.py123456789101112131415161718192021222324252627282930313233import os.pathimport tornado.httpserverimport tornado.optionsimport tornado.webimport tornado.ioloopfrom tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class IndexHandler(tornado.web.RequestHandler): def get(self): self.render(\"index.html\")class PoemPageHandler(tornado.web.RequestHandler): def post(self): noun1 = self.get_argument(\"noun1\") noun2 = self.get_argument(\"noun2\") verb = self.get_argument(\"verb\") noun3 = self.get_argument(\"noun3\") self.render(\"poem.html\", roads=noun1, wood=noun2, made = verb, difference=noun3)if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", IndexHandler), (r\"/poem\", PoemPageHandler)], template_path = os.path.join(os.path.dirname(__file__), \"templates\"), static_path = os.path.join(os.path.dirname(__file__), \"static\")， debug=True) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 除了上述poemmaker.py，还需要在文件夹templates下添加以下两个文件。/templates/index.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;Poem Maker Pro&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Enter terms below.&lt;/h1&gt; &lt;form method=&quot;post&quot; action=&quot;/poem&quot;&gt; &lt;p&gt;Plural noun &lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;noun1&quot; /&gt;&lt;/p&gt; &lt;p&gt;Singular noun&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;noun2&quot; /&gt;&lt;/p&gt; &lt;p&gt;Verb (haha)&lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;verb&quot; /&gt;&lt;/p&gt; &lt;p&gt;Noun&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;noun3&quot; /&gt; &lt;/p&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; /templates/poem.html123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;this is the poem&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Your poem&lt;/h1&gt; &lt;p&gt;Two &#123;&#123;roads&#125;&#125; diverged in a &#123;&#123;wood&#125;&#125;, and I—&lt;br/&gt; I took the one less tracelled by, &lt;br/&gt; and that has &#123;&#123;made&#125;&#125; all the &#123;&#123;difference&#125;&#125;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 运行python文件:1python poemmaker.py 此时访问8000端口会出现首页上包括多个表单等待用户输入。这个表单包括多个文本域(命名为noun1, noun2等)，其中内容将在用户点击“submit”按钮时以post请求的方式发送到/poem。当点击submit按钮之后，tornado应用跳转到poem.html，插入你在表单中填写的值。结果是显示的一首诗。 下面我们逐条讲述当前示例中的每一个涉及到的知识点： 2.1.1渲染模板从结构上讲，poemmaker和第一章的例子很相似。我们定义了几个RequestHandler子类并把它们传递给tornado.web.Application对象。那么有什么不一样的地方呢？首先我们向Application对象的init方法传递了一个template参数。1template_path = os.path.join(os.path.dirname(__file__), \"templates\") template_path参数告诉tornado在哪里寻找模板文件。我们将在第三章中讲解其确切的用法和性质。而它的基本要点是：模板是一个允许你嵌入python代码片段的html文件。上面的代码告诉python在你的tornado应用文件相同目录下的templates文件夹下寻找模板文件。一旦我们告诉tornado在哪里寻找模板，我们就可以使用RequestHandlser类的render方法来告诉tornado读入模板文件，插入其中的模板代码，并将结果返回给浏览器。比如，在IndexHandler中，我们可以发现语句：1self.render(\"index.html\") 这段代码告诉tornado载templates文件夹下找到一个名字为index.html的文件，读取其中的内容，并发送给浏览器。 2.12 填充实际上index.html完全不能称之为模板，因为它所包含的完全是已经编写好的html标记。这可以是模板一个不错的使用方式。但是在通常情况下我们更希望html输出可以结合我们的程序传入给模板的值。模板poem.html使用PoemPageMaker渲染，它是一个模板。我们可以看到，在poem.html中，它可以看到模板中有一些被双大括号括起来的字符串，就像这样：123&lt;p&gt;Two &#123;&#123;roads&#125;&#125; diverged in a &#123;&#123;wood&#125;&#125;, and I—&lt;br/&gt;I took the one less tracelled by, &lt;br/&gt;and that has &#123;&#123;made&#125;&#125; all the &#123;&#123;difference&#125;&#125;.&lt;/p&gt; 在双大括号中的单词是占位符，当我们渲染模板时希望以实际值代替。我们可以使用render函数中传递关键字参数的方法 指定什么值将被填充到html文件中的对应位置，其中关键字对应模板文件中占位符的名字。下面是在poemPageMaker中相应的代码部分：12345noun1 = self.get_argument(\"noun1\")noun2 = self.get_argument(\"noun2\")verb = self.get_argument(\"verb\")noun3 = self.get_argument(\"noun3\")self.render(\"poem.html\", roads=noun1, wood=noun2, made = verb, difference=noun3) 在这里，我们告诉模板使用变量noun1作为模板中roads的值，以此类推。 2.13 设置静态路径你可以通过向Application类的构造函数传递一个名为static_path的参数来告诉tornado从文件系统一个特定的位置提供静态文件。在上述代码中如下：1static_path = os.path.join(os.path.dirname(__file__), \"static\")) 在这里，我们设置了一个当前应用目录下名为static的子目录作为static_path的参数。应用将读取static中的文件作为静态文件 2.1.4使用static_url生成urltornado模板提供了一个叫做static_url的函数生成static目录下文件的url.让我们来看看在index.html中static_url的调用代码的示例代码：1&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123;static_url(&quot;style.css&quot;)&#125;&#125;&quot;&gt; 这个对static_url的调用生成了url的值，并渲染出类似下面的代码：1&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/style.css?v=ab12&gt; 那么为什么使用static_url而不是在你的模板中硬编码呢？原因有以下两点：第一，static_url函数创建了一个基于文件内容的hash值，并将其添加到url末尾(查询字符串的参数是v).这个hash值确保浏览器总是加载一个文件的最新版本而不是以前的缓存版本。无论是在开发阶段还是部署到生产环境，都非常有用，因为用户不必为了可到你的静态内容去清除浏览器的缓存了。第二，你可以改变你的url结构，而不用改变模板中的代码。例如，你可以配置tornado响应来自路径/s/filename的请求时提供静态内容，而不是默认的/static路径。如果你使用static_url而不是硬编码，这个时候你不需要改变代码中的值。 debug参数在这个例子中，你可能注意到了debug=True的使用。它调用了一个便利的测试模块:tornado.autoreload模块，此时，一旦主要的python文件被修改，tornado会尝试重启服务器，而且载模板改变的时候会自动刷新。对于快速改变和实时更新这非常棒，但不要在生产上使用它，因为他将防止tornado缓存模板。 2.2模板语法既然我们已经看到了一个模板在实际应用中的例子，哪买让我们深入了解它们是如何工作的。tornado模板是被python表达式和控制语句标记的简单文本文件。tornado的语法非常直接。在2.1节中，我们展示了如何在一个web应用中使用render方法传送html给浏览器。你可以在tornado应用之外使用python解释器导入模块尝试模板系统，此时结果会被直接输出出来。1234&gt;&gt;&gt; from tornado.template import Template&gt;&gt;&gt; content = Template(\"&lt;html&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123;header&#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\")&gt;&gt;&gt; print content.generate(header=\"Welcome!\")&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 2.21填充表达式上面的演示我们也可以看出，向html中填充python变量的值，我们可以使用双大括号；其实我们可以在双大括号中插入python表达式，它会自动计算出其实际值：1234567&gt;&gt;&gt; from tornado.template import Template&gt;&gt;&gt; print Template(\"&#123;&#123; 1+1 &#125;&#125;\").generate()2&gt;&gt;&gt; print Template(\"&#123;&#123; 'scrambled eggs'[-4:] &#125;&#125;\").generate()eggs&gt;&gt;&gt; print Template(\"&#123;&#123; ', '.join([str(x*x) for x in range(10)]) &#125;&#125;\").generate()0, 1, 4, 9, 16, 25, 36, 49, 64, 81 2.22 控制流语句同样也可以在tornado模板中使用python条件和循环语句。控制与句以{ %和% }包围，并以类似下面形式使用：123&#123;% if page is None %&#125;或&#123;% if len(entrise) == 3 %&#125; 控制语句的大部分就像对应的python语句一样工作，支持if,for,wihle,try。在这些情况下，语句块以{ %开始，以 % }结束 模板:12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;header&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &#123;%for book in books%&#125; &lt;li&gt;&#123;&#123;book&#125;&#125;&lt;/li&gt; &#123;% end %&#125; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 处理函数:1234class BookHandler(tornado.web.RequestHandler): def get(self): self.render(\"books.html\", title=\"Home Page\", header=\"Books that are great\",\\ books=[\"python\", \"c++\", \"pascal\"]) 这个时候将渲染出：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;header&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;python&lt;/li&gt; &lt;li&gt;C++&lt;/li&gt; &lt;li&gt;pascal&lt;/li&gt; &#123;% end %&#125; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 不像其他的python模板渲染系统，tornado模板语言的一个最好的东西是在if和for语句块中可以使用的表达式没有限制.因此，你可以在你的模板中执行所有的python代码。同样，你也可以在你的控制语句块中间使用{ % set foo = “bar” % }来设置变量的值。你还有很多可以在控制语句块中做的事情，但是，在大多数情况下，你最好使用UI模块来做更复杂的划分。我们稍后会更详细的看到这一点。 2.2.3在模板中使用函数tornado在所有模板中默认提供了一些遍历的函数。他们包括：12345678#替换字符串s中的&amp;,&lt;,&gt;为他们对应的html字符escape(s)# 使用urllib.quote_plus替换字符串s中的字符为URL编码形式url_escape(s)#将val编码成json格式，底层使用json.dumps()json_encode(val)#过滤字符串s,把连续的多个空白字符替换成一个空格squeeze(s) 在模板中使用一个你自己编写的函数也很简单：只需要将函数名作为模板的参数传递即可，就像其他的变量。123456789&gt;&gt;&gt; from tornado.template import Template&gt;&gt;&gt; def disemvowel(s):... return ''.join([x for x in s if x not in 'aeiou'])...&gt;&gt;&gt; disemvowel(\"george\")'grg'&gt;&gt;&gt; print Template(\"my name is &#123;&#123;d('mortimer')&#125;&#125;\").generate(d=disemvowel)my name is mrtmr","categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"tornado","slug":"tornado","permalink":"http://yoursite.com/tags/tornado/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"tornado入门(简单的web服务)","slug":"tornado入门-简单的web服务","date":"2016-12-05T14:18:06.000Z","updated":"2016-12-10T16:12:14.591Z","comments":true,"path":"2016/12/05/tornado入门-简单的web服务/","link":"","permalink":"http://yoursite.com/2016/12/05/tornado入门-简单的web服务/","excerpt":"","text":"tornado入门tornado是使用python编写的一个强大的，可扩展的web服务器。它在高并发的网络请求中表现的足够稳定，但是却在创建和编写的过程中有着足够的轻量级，并能够被用在大量的应用和工具中。不同于那些最多只能达到10000个并发连接的传统web服务器，tornado在设计之初就考虑到了性能因素，旨在解决C10K问题，这样的设计使得其成为一个非常高性能的框架。此外，它还拥有处理安全性，用户验证，社交网络以及与外部服务进行异步交互的工具。 Hello tornadotornado是一个编写对HTTP请求响应的框架。作为程序员，你的工作是编写响应特定条件HTTP请求的响应的handler。 hello.py12345678910111213141516171819import tornado.httpserverimport tornado.ioloopimport tornado.optionsimport tornado.webfrom tornado.options import define, optionsdefine(\"port\", default=8000, help = \"run on the give port\", type = int)class indexHandler(tornado.web.RequestHandler): def get(self): greeting = self.get_argument(\"greeting\", \"hello\") self.write(greeting + \", friend user!\")if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", indexHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 编写一个tornado应用中最多的工作是定义继承自tornado.RequestHandler的类。在这个例子中，我们创建了一个简单的应用，在指定的端口监听请求，并在根目录(“/“)下响应请求。执行命令:1python hello.py --port=9999 使用命令对其访问12345curl http://localhost:9999hello, friend user!curl http://localhost:9999/?greeting=daviddavid, friend user! 现在tornado程序就已经在localhost:9999处进行监听。我们可以对其进行根目录使用get方法进行那个访问. 程序分析下面我们开始逐条语句进行分析：开始的import语句导入了程序所必须的tornado的相关模块。虽然tornado还有其他模块，但是我们在这个程序中只需要这四个模块 tornado中options模块分析12from tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int) tornado包含了一个有用的模块tornado.options来从命令行读取设置。我们在这里使用这个模块指定我们监听http请求的端口。它的工作流程是:如果一个与define语句中同名的设置在命令行中给出，那么它将成为全局options的一个属性。如果用户程序在运行的时候使用了–help选项，程序将打印出你所定义的选项以及你在define函数的help参数中指定的文本。如果程序没有为这个选项指定值，那么则使用default进行替代。tornado使用type来验证参数的类型，当类型不合适的时候跑出一个异常。因此，我们允许一个整数port作为options.port来访问程序，如果用户没有指定port的值，则默认为9999端口。 请求处理函数类及方法1234class indexHandler(tornado.web.RequestHandler): def get(self): greeting = self.get_argument(\"greeting\", \"hello\") self.write(greeting + \", friend user!\") 这是tornado请求处理函数类，它继承自tornado.web.RequestHandler,当处理一个请求的时候，tornado将这个类实例化，并调用http请求方法所对应的方法。在这个例子中，我们只定义了get方法，也就是说这个类对http的GET请求作出响应。我们稍后将看到实现不止一个http方法的处理函数。 获取查询参数1self.get_argument(\"greeting\", \"hello\") tornado的request类有很多有用的内建函数，包括get_argument()用来用一个查询字符串中获取参数的值。上述的意思是从查询字符串中获取查询参数greeting的值，若查询参数中没有greeting参数，则会其值为”hello”，即为其默认值。 RequestHandler的write函数1self.write(greeting + \", firendly user\") tornado另一个有用的方法是write,它以一个字符串作为参数，并将其写入到http响应中去。在这里，我们使用请求中greeting的参数提供的值插入到greeting中，并写回到相应中去。 创建Application实例123if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", indexHandler)]) 这里是真正使得tornado运转起来的语句。首先我们使用tornado的options解析命令行。然后我们创建了一个tornado的Application实例。传递给Application的init方法的最重要的参数就是handlers。它告诉tornado用那个类来响应特定的请求。 端口监听123http_server = tornado.httpserver.HTTPServer(app)http_server.listen(options.port)tornado.ioloop.IOLoop.instance().start() 从这离开始的代码会被反复使用，一旦Application对象被创建，我们可以将其传递给httpServer的对象，然后使用我们在命令行指定的端口进行监听。最后，在程序准备好接收HTTP请求后，我们创建一个tornado的IOLoop的实例进行启动。 简单字符串服务12345678910111213141516171819202122232425262728import textwrapimport tornado.webimport tornado.httpserverimport tornado.ioloopimport tornado.optionsfrom tornado.options import define,optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class ReverseHandler(tornado.web.RequestHandler): def get(self, input1, input2): self.write(input1) self.write(input2)class WrapHandler(tornado.web.RequestHandler): def post(self): text =self.get_argument(\"text\") width = self.get_argument(\"width\", 40) self.write(textwrap.fill(text, int(width)))if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/reverse/([0-9]+)(\\w+)\", ReverseHandler),\\ (r\"/wrap\", WrapHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 上述是一个简单的字符串操作的web服务，有两个作用:第一，到/reverse/string的GET请求奖会返回url路径中指定字符串的反转形式。12$curl http://localhost:8000/reverse/123456654321 作用二是，到/wrap的POST请求从参数text中取得指定文本，并返回按照参数width指定宽度装饰的文本。下面的请求指定一个没有宽度的字符串，所以它的输出宽度被指定为程序中的get_argument的默认值40123$http://localhost:8000/wrap -d text=Lorem+ipsum+dolor+sit+amet,+consectetuer+adipiscing+elit.Lorem ipsum dolor sit amet, consectetueradipiscing elit. RequestHandler的更多知识HTTP方法到目前为止我们只用了http中的get,post方法，但tornado支持任何合法的HTTP请求（GET,POST,HEAD,DELETE,OPTIONS）。你可以非常容易的定义上述任何一种方法的行为，只需要在RequestHandler类中使用同名方法。 HTTP状态码从上面的代码可以看出，你可以使用RequestHandler类的set_status()方法显式的去设置http的状态麻，但是你需要记住在某些情况下，tornado会自动的设置状态码。下面是一种常见的纲要。 404 Not Found当http请求的路径无法匹配到任何RequestHandler类对应的模式的时候tornado会返回404相应码。 400 Bad Request如果你调用了一个没有默认值的get_argument()方法，并且没有发现给定名称的参数，tornado将自动返回一个400响应码 405 Method Not Allowed如果传入的请求使用了RequestHandler中没有定义的http方法，tornado将自动返回一个405响应码。 500 Internal Server Error当程序遇到任何不能让其退出的错误的时候，tornado自动返回响应码500.代码中任何没有捕获的异常也会返回500. 200 OK如果相应成功，并没有其他返回码被设置，tornado将默认返回一个200.","categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"tornado","slug":"tornado","permalink":"http://yoursite.com/tags/tornado/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"迭代器和简单的生成器","slug":"迭代器和简单的生成器","date":"2016-12-04T12:22:48.000Z","updated":"2016-12-04T13:12:12.518Z","comments":true,"path":"2016/12/04/迭代器和简单的生成器/","link":"","permalink":"http://yoursite.com/2016/12/04/迭代器和简单的生成器/","excerpt":"","text":"迭代器和简单的生成器摘自: https://www.ibm.com/developerworks/cn/linux/sdk/python/charm-20/ python2.2引进了一种带有新型关键字的新型构造。这个构造是生成器；关键字是yield.生成器使几个新型，强大和富有表现力的编程习惯成为可能，但初看，要理解生成器，还是有一点难度。本文由浅入深的介绍了生成器，同时还介绍了迭代器的相关问题。 由于迭代器比较容易理解，让我们先看它。基本上迭代器是含有.next方法的对象。这样定义不十分正确但非常接近。事实上，当迭代器应用新的iter()内置函数的时候，大多数迭代器的上下文希望返回迭代器，需要使iter()方法返回self.本文的示例将会说明清楚这一点。如果迭代有一个逻辑的终止，则迭代器的.next()方法可能决定抛出StopIteration异常。生成器要稍微复杂化和一般化一点。但生成器典型的用途是用来定义迭代器；所以不值得总是为一些细微之处而担心，生成器是这样一个函数它记住上一次返回时在函数体中的位置，对于生成器函数的第二次调用跳转到该函数的中间，而上次调用的所有的局部变量都被记住 随机遍历让我们考虑一个简单的问题，可以使用很多方法解决它。假设我们想要一串正的随机数字流，这个数字流的要求是每一个数字不允许小于0.1,且相邻两个数字之间的大小相差绝对值不小于0.4 版本一版本一是比较传统的做法,我们直接写一个随机产生一串数字流的函数，并将他保存在一个list中返回:123456789101112131415def generate_random(): last, rand = 1, random.random() num = [] while rand &gt; 0.1: if abs(last - rand) &gt;= 0.4: last = rand num.append(rand) else: print \"invalid\" rand = random.random() num.append(rand) return numfor item in generate_random(): print item 从上面可以产出，这种方法有很大的局限性。首先这个示例中不可能产生庞大的数字列表，通过对数字的大小限制进行终结随机数的产生，我们可以通过限制进行预测此数列的大小。另一方面，在内存和性能方面使这种方法变得不切实际，以及没有必要。同样是这个问题，使得python较早的版本中添加了xrange()和xreadlines()。重要的是，许多流取决于外部事件，并且当每个元素可用时，才处理这些流。在python2.1和较早的版本中，我们的诀窍是使用静态函数局部变量来记住函数上一次调用的事情。显而易见，全局变量可以用来做同样的工作，但是它会带来大家熟知的问题：命名空间污染问题 ###版本二 使用静态成员解决上述问题1234567891011121314def generate_random_static(last = [1]): rand = random.random() if rand &lt; 0.1: return while abs(rand - last[0]) &lt; 0.4: print \"invalid\" rand = random.random() last[0] = rand return randnum = generate_random_static()while num is not None: print num num = generate_random_static() 这个函数是一个很好的存储器，它只需要记住上一次的的值，返回一个单一的数字。而不需要存储一整个列表。并且与此类似的函数可以返回却绝育外部事件的连续的值。不方便的是使用这个函数不够方便，且想当不灵活 版本三 定义迭代器类实质上python2.2的序列都是迭代器，python常见的习惯用法for elem in lst:而实际上是让;lst差生一个迭代器。然后for循环调用这个迭代器的.next()方法，直到遇到StopIteration为止。幸运的是，由于常见的内置类型自动产生它们的迭代器，所以python程序员不需要直到这里发生了什么。实际上，现在字典里有.iterkeys(),.iteritems(),.itervalues()方法产生迭代器。定制类支持直接使用randomwalk_list()以及一次一个元素这种极度节省的randomwalk_static,这是简单易懂的。1234567891011121314151617181920class generate_random_class(object): def __init__(self): self.last = 1 self.rand = random.random() def __iter__(self): return self def next(self): if self.rand &lt; 0.1: raise StopIteration else: while abs(self.last - self.rand) &lt; 0.4: print \"invalid\" self.rand = random.random() self.last = self.rand return self.randfor item in generate_random_class(): print item 版本四 生成器版本上述方法也会产生较多的问题，虽然它避免了产生整个list,大量局部变量的情况，但是当迭代器类或者函数取决于多个数据状态的时候，就需要记录多个数据的状态，这种情况下出现错误的记录较大。所以也不是一种较好的解决方法。使用python自带的生成器yield关键字在 Python 2.2+ 中，不直接 写生成器。 相反，编写一个函数，当调用它时，返回生成器。这可能看起来有点古怪，但“函数工厂”是 Python 的常见特性，并且“生成器工厂”明显是这个概念性扩展。在 Python 2.2+ 中使函数成为生成器工厂是它主体某处的一个或多个 yield 语句。如果 yield 发生， return 一定只发生在没有伴随任何返回值的情况中。 然而，一个较好的选择是，安排函数体以便于完成所有 yield 之后，执行就“跳转到结束”。但如果遇到 return ，它导致产生的生成器抛出 StopIteration 异常，而不是进一步生成值。1234567891011def generate_random_yield(): last, rand = 1, random.random() while rand &gt; 0.1: if abs(last - rand) &gt;= 0.4: last = rand yield rand rand = random.random() yield randfor item in generate_random_yield(): print item 上述做法的好处是逻辑简洁，与正常写法无意，也保证了通用性。","categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"生成器","slug":"生成器","permalink":"http://yoursite.com/tags/生成器/"},{"name":"迭代器","slug":"迭代器","permalink":"http://yoursite.com/tags/迭代器/"}]},{"title":"python yield使用浅析","slug":"python-yield使用浅析","date":"2016-12-03T14:08:04.000Z","updated":"2016-12-04T11:53:12.318Z","comments":true,"path":"2016/12/03/python-yield使用浅析/","link":"","permalink":"http://yoursite.com/2016/12/03/python-yield使用浅析/","excerpt":"","text":"python yield使用浅析摘自:https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/初学python的人经常会发现python函数中使用了很多yield关键字，然而，带有yield关键字的函数的执行流程和普通函数的执行流程不同，yield带来了什么作用，为什么要设计yield?本文将由浅入深地讲解yield的概念和用法，帮助读者体会yield在python中的简单而强大的功能您可能听说过，带有yield的函数在python中称为generator(生成器)，何谓生成器？先抛开generator,以一个常见的编程题目来展示yield的概念。 如何生成斐波那契数列版本1（直接输出斐波那契数列）斐波那契额数列的概念搭建应该比较清晰，相信大家能共很轻易的写出如下的算法来计算斐波那契数列:123456def fab(max): n, a, b = 0, 0, 1 while n &lt; max: print b a, b = b, a + b n = n + 1 执行fab(5),我们会的到如下的结果：123456&gt;&gt;&gt; fab(5)11235 结果没有问题，但是有经验的开发者会指出，直接在fab函数中 print打印出结果可复用性较差，因为fab返回的结果是None,其他函数无法获取该函数生成的斐波那契数列。所以要提高该函数的可复用性，最好不要直接打印出数列，而是返回一个list 版本二（返回list）123456789def fab(max): n, a, b = 0, 0, 1 L = [] while n &lt; max: L.append(b) a, b = b, a + b n = n + 1 return L 使用如下方式打印出斐波那契数列：1234567&gt;&gt;&gt; for n in fab(5):... print =n11235 上述版本获取了可复用性的要求，但是该函数在运行的过程中占用的内存会随着参数max的增大而增大，如果要控制内存占用，最好不要用list来保存中介按结果，而是通过iterable对象来迭代。例如在python2.x中123for i in range(0,100)for i in xrange(0,100) 前者会生成一个长度为100的list,而后者则不会生成一个100的list，而是在每次迭代中返回下一个数值，内存占用空间很小。因为xrange不返回list,而返回一个iterable的意向，利用iterable我们可以吧fab函数写成一个支持iterable的class 版本三（实现支持iterable的对象）1234567891011121314class fab(object): def __init__(self, max): self.max = maxself.n, self.a. self.b = 0, 0, 1 def __iter__(self): return self def next(self): if self.n &lt; self.max: r = self.b self.a, self.b = self.b, self.a + self.b self.n = self.n + 1 return r raise StopIteration Fab函数通过next不断返回数列的下一个数，内存占用始终为常数1234567&gt;&gt;&gt;for n in fab(5):... print n11235 上述代码虽然实现了我们版本二的要求，但是代码远远没有第一个版本简洁。如果想要保持第一版的简洁，这个时候就要用上yield 版本四123456def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 第四个版本和第一个版本相比仅仅把print b该成了yield b,就在保持简洁性的同时获得了iterable的效果。调用第四个版本和第二个版本的fab完全一致:1234567&gt;&gt;&gt;for n in fab(5):... print n11235 简单的将,yield的作用就是把一个函数变成了一个generator,带有yield的函数不在是一个普通函数,python解释器会将其视为一个generator,调用fab(5)不会执行fab函数，而是返回一个iterable对象。在for循环执行的时候，每次循环都会执行fab内部的代码，执行到yield b的时候，fab就返回一个迭代之，下次迭代时，代码从yieldb 的下一条语句执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到yield也可以调用fab(5)的next()方法进行回去每次计算的值。 yield函数的执行流程123456789101112131415&gt;&gt;&gt; f = fab(5)&gt;&gt;&gt; f.next()1&gt;&gt;&gt; f.next()1&gt;&gt;&gt; f.next()2&gt;&gt;&gt; f.next()3&gt;&gt;&gt; f.next()5&gt;&gt;&gt; f.next()Traceback (most recent call last): File \"&lt;stdin&gt;\". line 1, in &lt;module&gt; StopIteration 当函数执行结束的时候，generator自动自动抛出StopIteration的异常，表示迭代的结束，而在for循环中，我们不需要手动的进行处理异常，循环会自动的正常结束。 一个带有yield的函数就是一盒generator,它和普通的函数不同，声称一个generator看起来想函数调用，但是部执行任何函数代码，直到对其调用next()(注意在for循环中会自动调用next)才开始执行。虽然执行流程和普通函数一样，但是每执行到一个yield语句，就会中断，并返回一个迭代值，下次执行的时候从yield的下一个语句开始执行。看起来像是一个函数在正常执行的过程中被yield中断了数次，每次中断都会通过yield返回当前迭代器的值。yield的好处显而易见，把一个函数该写成generator就获得了迭代能力，比起在类的实例中保存状态计算下一个next的值，更加使代码清洁，而且执行流程非常清晰 判断是否为generator方法是使用isgeneratorfunction来进行判断12from inspect import isgeneratorfunctionisgeneratorfunction(fab) 注意fab不可迭代,而fab(5)可迭代 return的作用在一个generator function中，若函数中没有return语句，默认为函数执行到函数结尾，而如果中间遇到return语句，则直接判处StopIteration异常，结束迭代。使用yield进行读取文件的例子123456789def read_file(fpath): block_size = 1024 with open(fpath, \"rb\") as f: while True: block = f.read(block_size) if block: yield block else return 上述当文件读取完毕的时候奖直接返回StopIteration异常，结束迭代。","categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"yield","slug":"yield","permalink":"http://yoursite.com/tags/yield/"}]},{"title":"python装饰其入门","slug":"python装饰其入门","date":"2016-12-02T13:43:51.000Z","updated":"2016-12-04T11:30:31.762Z","comments":true,"path":"2016/12/02/python装饰其入门/","link":"","permalink":"http://yoursite.com/2016/12/02/python装饰其入门/","excerpt":"","text":"python装饰器预备知识一级对象python将一切（包括函数）视为object的子类，即一切皆为对象，因此函数可以像变量一样被指向和传递，下面我们来看一个例子。 1234def foo(): pass#注意issubclass是python的一个内置函数,用于判断两个类是不是子类关系print issubclass(foo.__class__, object) 输出结果: 1True 上述代码说明了python中的函数都是object的子类，下面我们看一下函数被当做参数传递的效果 1234567def foo(func): func()def bar(): print \"bar\"foo(bar) 运行结果如下:1bar python中的作用域 namespacepython 提供namespace来重新实现函数/方法，变量等信息的区别，七一共有三种作用域: local namespace:作用范围为当前函数或者类方法 global namespace:作用范围为当前模块 build-in namespace:作用范围为所有模块 当变量或者方法出现重名的情况时，python会按照local-&gt;global-&gt;build-in的顺序去搜索,并以第一个找到的元素为当前的namespace，此种做法与C/C++中的相似 *args和**kwargs在python中我们使用*args和kwargs传递可变长参数,*args用作传递非命名键值可变长参数列表(位置参数)；**kwargs用作传递键值可变长参数 *args：把所有的参数按照出现顺序打包成一个list **kwargs：把所有的key-value形式的参数打包成一个dict 例子： 1234567def add(x, y): print x + yparams_list = (1, 2)dict_list = &#123;\"x\":1, \"y\":2&#125;add(*params_list)add(**dict_list) 打印结果:1233 python装饰器入门python允许你，作为程序员，使用函数完成一些很酷的事情。在python中，函数是一级对象(first-class)，这就意味着你可以像使用字符串，整数，或者其他对象一样使用函数。例如，你可以将函数赋值给变量：12345def square(n): return n * nprint square(4) #16alias = squareprint alias(5) #25 然而一等函数的真正威力在于你可以把函数传给其他函数，或者从其他函数中返回函数。函数的内值函数map利用了这种能力：给map传一个函数以及一个列表，他会依次以列表中的每个元素作为参数调用你传给它的函数，从而生成一个新的列表。如下所示的例子中应用了上面的square函数： 12number = [1,2,3,4]print map(square, number) #[1,4,9,16] 如果一个函数接受一个函数作为参数或者返回一个函数，则这个函数被称为高阶函数虽然map简单使用了我们传给它的函数，而没有改变这个函数，但我们也可以使用高阶函数去改变其他函数的行为。例如：假设有这样一个函数，会被调用很多次，以致运行待解非常昂贵:12def fib(n): return n if n in [0,1] else fib(n - 2) + fib(n - 1) 为了提高这个函数的效率，我们一般会保存计算过程中得出的中间结果，这样对于函数调用树中经常出现某个n，当需要计算n对应的结果时，就不需要重复计算了。有很多种方式可以实现这一点。例如我们可以将这些结果存在一个字典中，当某个值为参数调用fib函数的时候，首先去字典中查一下结果是否已经计算出来，如果计算出来直接返回反之计算。但是这样的话，每次我们想调用fib函数，都需要重复那段相同的字典检查样板式代码。相反，如果让fib函数自己在内部负责存储结果，那么在其他代码中调用fib，就非常方便，只要简单的调用它就好了。这种技术被称为memoization当然我们可以把这种memozition代码直接放入fib函数中，但是python给我们提供了一种更加优雅的选择因为可以编写修改其他函数的函数，那么我们就可以便携一个通用的memozation函数，以一个函数作为参考，并返回这个函数的memozation版本。123456789def memoze(fn): store_results = &#123;&#125; def memoized(args): try: return store_results[args] except: result = store_result[args] = fn(args) return result return memoized 如上，momoize函数以另一个函数作为参数，函数体中创建了一个字典对象来存储函数调用结果：键为被memoized包含后的函数的参数，值为以键为参数调用函数的返回值。memoize函数返回一个新的函数，这个函数会首先检查store_results中是否存在与当前参数对应的条目，如果有则直接返回，如果没有，则使用原始函数进行计算。memoize返回的这种新的函数常被称为包装器函数。因为它只是另外一个真正起作用的函数外面的一个薄层。很好，我们现在有了memoize函数，现在将fib函数传给它，从而得到了一个经过包装的fib，这个版本的fib函数不需要重复以前的那样繁重的工作：1234def fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1)fib = memoize(fib) 通过高阶函数memoize，我们获得了memoization带来的好处，并不需要对fib函数自己做出任何的改变，以免夹杂着memoization的代码而模糊了函数的实质工作。但是，你也许注意到上面的代码看着还是有点别扭，因为我们必须写三遍fib。由于这种模式(传递一个函数给另一个函数，然后将结果返回给与原来那个函数同名的函数变量，在使用包装器函数的代码中极为常见)，python提供了一种特殊的愈发：装饰器123@memoizedef fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1) 这里我们说memoize函数装饰了fib函数。需要注意的是这仅是语法上的简便写法（被称为“语法糖”）。这段代码与前面的代码片段做的是同样的事情：定义一个名为fib的函数，把它传给memoize函数，将返回结果存为名为fib的函数变量。特殊的(看起来有点奇怪的)@语法只是减少了冗余。 你可以使用多个装饰器，它会自底向上逐个起作用，例如假如有另外一个装饰器函数decorate1234@memoize@decoratedef fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1) 等价于：123def fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1)fib = memoize(decorator(fib)) 当装饰器函数含有参数的时候，方法是123@mimoize(\"172.168.1.1\")fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1)","categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]}]}