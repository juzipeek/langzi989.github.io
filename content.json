{"meta":{"title":"魏传柳","subtitle":null,"description":null,"author":"魏传柳(langzi989)","url":"http://yoursite.com"},"pages":[{"title":"all-archives","date":"2016-12-01T17:00:12.569Z","updated":"2016-12-01T17:00:12.569Z","comments":false,"path":"all-archives/index.html","permalink":"http://yoursite.com/all-archives/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2016-12-01T16:59:23.933Z","updated":"2016-12-01T16:59:23.933Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2016-12-01T16:59:49.905Z","updated":"2016-12-01T16:59:49.905Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"tornado入门(简单的web服务)","slug":"tornado入门-简单的web服务","date":"2016-12-05T14:18:06.000Z","updated":"2016-12-10T16:12:14.591Z","comments":true,"path":"2016/12/05/tornado入门-简单的web服务/","link":"","permalink":"http://yoursite.com/2016/12/05/tornado入门-简单的web服务/","excerpt":"","text":"tornado入门tornado是使用python编写的一个强大的，可扩展的web服务器。它在高并发的网络请求中表现的足够稳定，但是却在创建和编写的过程中有着足够的轻量级，并能够被用在大量的应用和工具中。不同于那些最多只能达到10000个并发连接的传统web服务器，tornado在设计之初就考虑到了性能因素，旨在解决C10K问题，这样的设计使得其成为一个非常高性能的框架。此外，它还拥有处理安全性，用户验证，社交网络以及与外部服务进行异步交互的工具。 Hello tornadotornado是一个编写对HTTP请求响应的框架。作为程序员，你的工作是编写响应特定条件HTTP请求的响应的handler。 hello.py12345678910111213141516171819import tornado.httpserverimport tornado.ioloopimport tornado.optionsimport tornado.webfrom tornado.options import define, optionsdefine(\"port\", default=8000, help = \"run on the give port\", type = int)class indexHandler(tornado.web.RequestHandler): def get(self): greeting = self.get_argument(\"greeting\", \"hello\") self.write(greeting + \", friend user!\")if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", indexHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 编写一个tornado应用中最多的工作是定义继承自tornado.RequestHandler的类。在这个例子中，我们创建了一个简单的应用，在指定的端口监听请求，并在根目录(“/“)下响应请求。执行命令:1python hello.py --port=9999 使用命令对其访问12345curl http://localhost:9999hello, friend user!curl http://localhost:9999/?greeting=daviddavid, friend user! 现在tornado程序就已经在localhost:9999处进行监听。我们可以对其进行根目录使用get方法进行那个访问. 程序分析下面我们开始逐条语句进行分析：开始的import语句导入了程序所必须的tornado的相关模块。虽然tornado还有其他模块，但是我们在这个程序中只需要这四个模块 tornado中options模块分析12from tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int) tornado包含了一个有用的模块tornado.options来从命令行读取设置。我们在这里使用这个模块指定我们监听http请求的端口。它的工作流程是:如果一个与define语句中同名的设置在命令行中给出，那么它将成为全局options的一个属性。如果用户程序在运行的时候使用了–help选项，程序将打印出你所定义的选项以及你在define函数的help参数中指定的文本。如果程序没有为这个选项指定值，那么则使用default进行替代。tornado使用type来验证参数的类型，当类型不合适的时候跑出一个异常。因此，我们允许一个整数port作为options.port来访问程序，如果用户没有指定port的值，则默认为9999端口。 请求处理函数类及方法1234class indexHandler(tornado.web.RequestHandler): def get(self): greeting = self.get_argument(\"greeting\", \"hello\") self.write(greeting + \", friend user!\") 这是tornado请求处理函数类，它继承自tornado.web.RequestHandler,当处理一个请求的时候，tornado将这个类实例化，并调用http请求方法所对应的方法。在这个例子中，我们只定义了get方法，也就是说这个类对http的GET请求作出响应。我们稍后将看到实现不止一个http方法的处理函数。 获取查询参数1self.get_argument(\"greeting\", \"hello\") tornado的request类有很多有用的内建函数，包括get_argument()用来用一个查询字符串中获取参数的值。上述的意思是从查询字符串中获取查询参数greeting的值，若查询参数中没有greeting参数，则会其值为”hello”，即为其默认值。 RequestHandler的write函数1self.write(greeting + \", firendly user\") tornado另一个有用的方法是write,它以一个字符串作为参数，并将其写入到http响应中去。在这里，我们使用请求中greeting的参数提供的值插入到greeting中，并写回到相应中去。 创建Application实例123if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", indexHandler)]) 这里是真正使得tornado运转起来的语句。首先我们使用tornado的options解析命令行。然后我们创建了一个tornado的Application实例。传递给Application的init方法的最重要的参数就是handlers。它告诉tornado用那个类来响应特定的请求。 端口监听123http_server = tornado.httpserver.HTTPServer(app)http_server.listen(options.port)tornado.ioloop.IOLoop.instance().start() 从这离开始的代码会被反复使用，一旦Application对象被创建，我们可以将其传递给httpServer的对象，然后使用我们在命令行指定的端口进行监听。最后，在程序准备好接收HTTP请求后，我们创建一个tornado的IOLoop的实例进行启动。 简单字符串服务12345678910111213141516171819202122232425262728import textwrapimport tornado.webimport tornado.httpserverimport tornado.ioloopimport tornado.optionsfrom tornado.options import define,optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class ReverseHandler(tornado.web.RequestHandler): def get(self, input1, input2): self.write(input1) self.write(input2)class WrapHandler(tornado.web.RequestHandler): def post(self): text =self.get_argument(\"text\") width = self.get_argument(\"width\", 40) self.write(textwrap.fill(text, int(width)))if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/reverse/([0-9]+)(\\w+)\", ReverseHandler),\\ (r\"/wrap\", WrapHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 上述是一个简单的字符串操作的web服务，有两个作用:第一，到/reverse/string的GET请求奖会返回url路径中指定字符串的反转形式。12$curl http://localhost:8000/reverse/123456654321 作用二是，到/wrap的POST请求从参数text中取得指定文本，并返回按照参数width指定宽度装饰的文本。下面的请求指定一个没有宽度的字符串，所以它的输出宽度被指定为程序中的get_argument的默认值40123$http://localhost:8000/wrap -d text=Lorem+ipsum+dolor+sit+amet,+consectetuer+adipiscing+elit.Lorem ipsum dolor sit amet, consectetueradipiscing elit. RequestHandler的更多知识HTTP方法到目前为止我们只用了http中的get,post方法，但tornado支持任何合法的HTTP请求（GET,POST,HEAD,DELETE,OPTIONS）。你可以非常容易的定义上述任何一种方法的行为，只需要在RequestHandler类中使用同名方法。 HTTP状态码从上面的代码可以看出，你可以使用RequestHandler类的set_status()方法显式的去设置http的状态麻，但是你需要记住在某些情况下，tornado会自动的设置状态码。下面是一种常见的纲要。 404 Not Found当http请求的路径无法匹配到任何RequestHandler类对应的模式的时候tornado会返回404相应码。 400 Bad Request如果你调用了一个没有默认值的get_argument()方法，并且没有发现给定名称的参数，tornado将自动返回一个400响应码 405 Method Not Allowed如果传入的请求使用了RequestHandler中没有定义的http方法，tornado将自动返回一个405响应码。 500 Internal Server Error当程序遇到任何不能让其退出的错误的时候，tornado自动返回响应码500.代码中任何没有捕获的异常也会返回500. 200 OK如果相应成功，并没有其他返回码被设置，tornado将默认返回一个200.","categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"tornado","slug":"tornado","permalink":"http://yoursite.com/tags/tornado/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"迭代器和简单的生成器","slug":"迭代器和简单的生成器","date":"2016-12-04T12:22:48.000Z","updated":"2016-12-04T13:12:12.518Z","comments":true,"path":"2016/12/04/迭代器和简单的生成器/","link":"","permalink":"http://yoursite.com/2016/12/04/迭代器和简单的生成器/","excerpt":"","text":"迭代器和简单的生成器摘自: https://www.ibm.com/developerworks/cn/linux/sdk/python/charm-20/ python2.2引进了一种带有新型关键字的新型构造。这个构造是生成器；关键字是yield.生成器使几个新型，强大和富有表现力的编程习惯成为可能，但初看，要理解生成器，还是有一点难度。本文由浅入深的介绍了生成器，同时还介绍了迭代器的相关问题。 由于迭代器比较容易理解，让我们先看它。基本上迭代器是含有.next方法的对象。这样定义不十分正确但非常接近。事实上，当迭代器应用新的iter()内置函数的时候，大多数迭代器的上下文希望返回迭代器，需要使iter()方法返回self.本文的示例将会说明清楚这一点。如果迭代有一个逻辑的终止，则迭代器的.next()方法可能决定抛出StopIteration异常。生成器要稍微复杂化和一般化一点。但生成器典型的用途是用来定义迭代器；所以不值得总是为一些细微之处而担心，生成器是这样一个函数它记住上一次返回时在函数体中的位置，对于生成器函数的第二次调用跳转到该函数的中间，而上次调用的所有的局部变量都被记住 随机遍历让我们考虑一个简单的问题，可以使用很多方法解决它。假设我们想要一串正的随机数字流，这个数字流的要求是每一个数字不允许小于0.1,且相邻两个数字之间的大小相差绝对值不小于0.4 版本一版本一是比较传统的做法,我们直接写一个随机产生一串数字流的函数，并将他保存在一个list中返回:123456789101112131415def generate_random(): last, rand = 1, random.random() num = [] while rand &gt; 0.1: if abs(last - rand) &gt;= 0.4: last = rand num.append(rand) else: print \"invalid\" rand = random.random() num.append(rand) return numfor item in generate_random(): print item 从上面可以产出，这种方法有很大的局限性。首先这个示例中不可能产生庞大的数字列表，通过对数字的大小限制进行终结随机数的产生，我们可以通过限制进行预测此数列的大小。另一方面，在内存和性能方面使这种方法变得不切实际，以及没有必要。同样是这个问题，使得python较早的版本中添加了xrange()和xreadlines()。重要的是，许多流取决于外部事件，并且当每个元素可用时，才处理这些流。在python2.1和较早的版本中，我们的诀窍是使用静态函数局部变量来记住函数上一次调用的事情。显而易见，全局变量可以用来做同样的工作，但是它会带来大家熟知的问题：命名空间污染问题 ###版本二 使用静态成员解决上述问题1234567891011121314def generate_random_static(last = [1]): rand = random.random() if rand &lt; 0.1: return while abs(rand - last[0]) &lt; 0.4: print \"invalid\" rand = random.random() last[0] = rand return randnum = generate_random_static()while num is not None: print num num = generate_random_static() 这个函数是一个很好的存储器，它只需要记住上一次的的值，返回一个单一的数字。而不需要存储一整个列表。并且与此类似的函数可以返回却绝育外部事件的连续的值。不方便的是使用这个函数不够方便，且想当不灵活 版本三 定义迭代器类实质上python2.2的序列都是迭代器，python常见的习惯用法for elem in lst:而实际上是让;lst差生一个迭代器。然后for循环调用这个迭代器的.next()方法，直到遇到StopIteration为止。幸运的是，由于常见的内置类型自动产生它们的迭代器，所以python程序员不需要直到这里发生了什么。实际上，现在字典里有.iterkeys(),.iteritems(),.itervalues()方法产生迭代器。定制类支持直接使用randomwalk_list()以及一次一个元素这种极度节省的randomwalk_static,这是简单易懂的。1234567891011121314151617181920class generate_random_class(object): def __init__(self): self.last = 1 self.rand = random.random() def __iter__(self): return self def next(self): if self.rand &lt; 0.1: raise StopIteration else: while abs(self.last - self.rand) &lt; 0.4: print \"invalid\" self.rand = random.random() self.last = self.rand return self.randfor item in generate_random_class(): print item 版本四 生成器版本上述方法也会产生较多的问题，虽然它避免了产生整个list,大量局部变量的情况，但是当迭代器类或者函数取决于多个数据状态的时候，就需要记录多个数据的状态，这种情况下出现错误的记录较大。所以也不是一种较好的解决方法。使用python自带的生成器yield关键字在 Python 2.2+ 中，不直接 写生成器。 相反，编写一个函数，当调用它时，返回生成器。这可能看起来有点古怪，但“函数工厂”是 Python 的常见特性，并且“生成器工厂”明显是这个概念性扩展。在 Python 2.2+ 中使函数成为生成器工厂是它主体某处的一个或多个 yield 语句。如果 yield 发生， return 一定只发生在没有伴随任何返回值的情况中。 然而，一个较好的选择是，安排函数体以便于完成所有 yield 之后，执行就“跳转到结束”。但如果遇到 return ，它导致产生的生成器抛出 StopIteration 异常，而不是进一步生成值。1234567891011def generate_random_yield(): last, rand = 1, random.random() while rand &gt; 0.1: if abs(last - rand) &gt;= 0.4: last = rand yield rand rand = random.random() yield randfor item in generate_random_yield(): print item 上述做法的好处是逻辑简洁，与正常写法无意，也保证了通用性。","categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"生成器","slug":"生成器","permalink":"http://yoursite.com/tags/生成器/"},{"name":"迭代器","slug":"迭代器","permalink":"http://yoursite.com/tags/迭代器/"}]},{"title":"python yield使用浅析","slug":"python-yield使用浅析","date":"2016-12-03T14:08:04.000Z","updated":"2016-12-04T11:53:12.318Z","comments":true,"path":"2016/12/03/python-yield使用浅析/","link":"","permalink":"http://yoursite.com/2016/12/03/python-yield使用浅析/","excerpt":"","text":"python yield使用浅析摘自:https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/初学python的人经常会发现python函数中使用了很多yield关键字，然而，带有yield关键字的函数的执行流程和普通函数的执行流程不同，yield带来了什么作用，为什么要设计yield?本文将由浅入深地讲解yield的概念和用法，帮助读者体会yield在python中的简单而强大的功能您可能听说过，带有yield的函数在python中称为generator(生成器)，何谓生成器？先抛开generator,以一个常见的编程题目来展示yield的概念。 如何生成斐波那契数列版本1（直接输出斐波那契数列）斐波那契额数列的概念搭建应该比较清晰，相信大家能共很轻易的写出如下的算法来计算斐波那契数列:123456def fab(max): n, a, b = 0, 0, 1 while n &lt; max: print b a, b = b, a + b n = n + 1 执行fab(5),我们会的到如下的结果：123456&gt;&gt;&gt; fab(5)11235 结果没有问题，但是有经验的开发者会指出，直接在fab函数中 print打印出结果可复用性较差，因为fab返回的结果是None,其他函数无法获取该函数生成的斐波那契数列。所以要提高该函数的可复用性，最好不要直接打印出数列，而是返回一个list 版本二（返回list）123456789def fab(max): n, a, b = 0, 0, 1 L = [] while n &lt; max: L.append(b) a, b = b, a + b n = n + 1 return L 使用如下方式打印出斐波那契数列：1234567&gt;&gt;&gt; for n in fab(5):... print =n11235 上述版本获取了可复用性的要求，但是该函数在运行的过程中占用的内存会随着参数max的增大而增大，如果要控制内存占用，最好不要用list来保存中介按结果，而是通过iterable对象来迭代。例如在python2.x中123for i in range(0,100)for i in xrange(0,100) 前者会生成一个长度为100的list,而后者则不会生成一个100的list，而是在每次迭代中返回下一个数值，内存占用空间很小。因为xrange不返回list,而返回一个iterable的意向，利用iterable我们可以吧fab函数写成一个支持iterable的class 版本三（实现支持iterable的对象）1234567891011121314class fab(object): def __init__(self, max): self.max = maxself.n, self.a. self.b = 0, 0, 1 def __iter__(self): return self def next(self): if self.n &lt; self.max: r = self.b self.a, self.b = self.b, self.a + self.b self.n = self.n + 1 return r raise StopIteration Fab函数通过next不断返回数列的下一个数，内存占用始终为常数1234567&gt;&gt;&gt;for n in fab(5):... print n11235 上述代码虽然实现了我们版本二的要求，但是代码远远没有第一个版本简洁。如果想要保持第一版的简洁，这个时候就要用上yield 版本四123456def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 第四个版本和第一个版本相比仅仅把print b该成了yield b,就在保持简洁性的同时获得了iterable的效果。调用第四个版本和第二个版本的fab完全一致:1234567&gt;&gt;&gt;for n in fab(5):... print n11235 简单的将,yield的作用就是把一个函数变成了一个generator,带有yield的函数不在是一个普通函数,python解释器会将其视为一个generator,调用fab(5)不会执行fab函数，而是返回一个iterable对象。在for循环执行的时候，每次循环都会执行fab内部的代码，执行到yield b的时候，fab就返回一个迭代之，下次迭代时，代码从yieldb 的下一条语句执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到yield也可以调用fab(5)的next()方法进行回去每次计算的值。 yield函数的执行流程123456789101112131415&gt;&gt;&gt; f = fab(5)&gt;&gt;&gt; f.next()1&gt;&gt;&gt; f.next()1&gt;&gt;&gt; f.next()2&gt;&gt;&gt; f.next()3&gt;&gt;&gt; f.next()5&gt;&gt;&gt; f.next()Traceback (most recent call last): File \"&lt;stdin&gt;\". line 1, in &lt;module&gt; StopIteration 当函数执行结束的时候，generator自动自动抛出StopIteration的异常，表示迭代的结束，而在for循环中，我们不需要手动的进行处理异常，循环会自动的正常结束。 一个带有yield的函数就是一盒generator,它和普通的函数不同，声称一个generator看起来想函数调用，但是部执行任何函数代码，直到对其调用next()(注意在for循环中会自动调用next)才开始执行。虽然执行流程和普通函数一样，但是每执行到一个yield语句，就会中断，并返回一个迭代值，下次执行的时候从yield的下一个语句开始执行。看起来像是一个函数在正常执行的过程中被yield中断了数次，每次中断都会通过yield返回当前迭代器的值。yield的好处显而易见，把一个函数该写成generator就获得了迭代能力，比起在类的实例中保存状态计算下一个next的值，更加使代码清洁，而且执行流程非常清晰 判断是否为generator方法是使用isgeneratorfunction来进行判断12from inspect import isgeneratorfunctionisgeneratorfunction(fab) 注意fab不可迭代,而fab(5)可迭代 return的作用在一个generator function中，若函数中没有return语句，默认为函数执行到函数结尾，而如果中间遇到return语句，则直接判处StopIteration异常，结束迭代。使用yield进行读取文件的例子123456789def read_file(fpath): block_size = 1024 with open(fpath, \"rb\") as f: while True: block = f.read(block_size) if block: yield block else return 上述当文件读取完毕的时候奖直接返回StopIteration异常，结束迭代。","categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"yield","slug":"yield","permalink":"http://yoursite.com/tags/yield/"}]},{"title":"python装饰其入门","slug":"python装饰其入门","date":"2016-12-02T13:43:51.000Z","updated":"2016-12-04T11:30:31.762Z","comments":true,"path":"2016/12/02/python装饰其入门/","link":"","permalink":"http://yoursite.com/2016/12/02/python装饰其入门/","excerpt":"","text":"python装饰器预备知识一级对象python将一切（包括函数）视为object的子类，即一切皆为对象，因此函数可以像变量一样被指向和传递，下面我们来看一个例子。 1234def foo(): pass#注意issubclass是python的一个内置函数,用于判断两个类是不是子类关系print issubclass(foo.__class__, object) 输出结果: 1True 上述代码说明了python中的函数都是object的子类，下面我们看一下函数被当做参数传递的效果 1234567def foo(func): func()def bar(): print \"bar\"foo(bar) 运行结果如下:1bar python中的作用域 namespacepython 提供namespace来重新实现函数/方法，变量等信息的区别，七一共有三种作用域: local namespace:作用范围为当前函数或者类方法 global namespace:作用范围为当前模块 build-in namespace:作用范围为所有模块 当变量或者方法出现重名的情况时，python会按照local-&gt;global-&gt;build-in的顺序去搜索,并以第一个找到的元素为当前的namespace，此种做法与C/C++中的相似 *args和**kwargs在python中我们使用*args和kwargs传递可变长参数,*args用作传递非命名键值可变长参数列表(位置参数)；**kwargs用作传递键值可变长参数 *args：把所有的参数按照出现顺序打包成一个list **kwargs：把所有的key-value形式的参数打包成一个dict 例子： 1234567def add(x, y): print x + yparams_list = (1, 2)dict_list = &#123;\"x\":1, \"y\":2&#125;add(*params_list)add(**dict_list) 打印结果:1233 python装饰器入门python允许你，作为程序员，使用函数完成一些很酷的事情。在python中，函数是一级对象(first-class)，这就意味着你可以像使用字符串，整数，或者其他对象一样使用函数。例如，你可以将函数赋值给变量：12345def square(n): return n * nprint square(4) #16alias = squareprint alias(5) #25 然而一等函数的真正威力在于你可以把函数传给其他函数，或者从其他函数中返回函数。函数的内值函数map利用了这种能力：给map传一个函数以及一个列表，他会依次以列表中的每个元素作为参数调用你传给它的函数，从而生成一个新的列表。如下所示的例子中应用了上面的square函数： 12number = [1,2,3,4]print map(square, number) #[1,4,9,16] 如果一个函数接受一个函数作为参数或者返回一个函数，则这个函数被称为高阶函数虽然map简单使用了我们传给它的函数，而没有改变这个函数，但我们也可以使用高阶函数去改变其他函数的行为。例如：假设有这样一个函数，会被调用很多次，以致运行待解非常昂贵:12def fib(n): return n if n in [0,1] else fib(n - 2) + fib(n - 1) 为了提高这个函数的效率，我们一般会保存计算过程中得出的中间结果，这样对于函数调用树中经常出现某个n，当需要计算n对应的结果时，就不需要重复计算了。有很多种方式可以实现这一点。例如我们可以将这些结果存在一个字典中，当某个值为参数调用fib函数的时候，首先去字典中查一下结果是否已经计算出来，如果计算出来直接返回反之计算。但是这样的话，每次我们想调用fib函数，都需要重复那段相同的字典检查样板式代码。相反，如果让fib函数自己在内部负责存储结果，那么在其他代码中调用fib，就非常方便，只要简单的调用它就好了。这种技术被称为memoization当然我们可以把这种memozition代码直接放入fib函数中，但是python给我们提供了一种更加优雅的选择因为可以编写修改其他函数的函数，那么我们就可以便携一个通用的memozation函数，以一个函数作为参考，并返回这个函数的memozation版本。123456789def memoze(fn): store_results = &#123;&#125; def memoized(args): try: return store_results[args] except: result = store_result[args] = fn(args) return result return memoized 如上，momoize函数以另一个函数作为参数，函数体中创建了一个字典对象来存储函数调用结果：键为被memoized包含后的函数的参数，值为以键为参数调用函数的返回值。memoize函数返回一个新的函数，这个函数会首先检查store_results中是否存在与当前参数对应的条目，如果有则直接返回，如果没有，则使用原始函数进行计算。memoize返回的这种新的函数常被称为包装器函数。因为它只是另外一个真正起作用的函数外面的一个薄层。很好，我们现在有了memoize函数，现在将fib函数传给它，从而得到了一个经过包装的fib，这个版本的fib函数不需要重复以前的那样繁重的工作：1234def fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1)fib = memoize(fib) 通过高阶函数memoize，我们获得了memoization带来的好处，并不需要对fib函数自己做出任何的改变，以免夹杂着memoization的代码而模糊了函数的实质工作。但是，你也许注意到上面的代码看着还是有点别扭，因为我们必须写三遍fib。由于这种模式(传递一个函数给另一个函数，然后将结果返回给与原来那个函数同名的函数变量，在使用包装器函数的代码中极为常见)，python提供了一种特殊的愈发：装饰器123@memoizedef fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1) 这里我们说memoize函数装饰了fib函数。需要注意的是这仅是语法上的简便写法（被称为“语法糖”）。这段代码与前面的代码片段做的是同样的事情：定义一个名为fib的函数，把它传给memoize函数，将返回结果存为名为fib的函数变量。特殊的(看起来有点奇怪的)@语法只是减少了冗余。 你可以使用多个装饰器，它会自底向上逐个起作用，例如假如有另外一个装饰器函数decorate1234@memoize@decoratedef fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1) 等价于：123def fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1)fib = memoize(decorator(fib)) 当装饰器函数含有参数的时候，方法是123@mimoize(\"172.168.1.1\")fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1)","categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]}]}