{"meta":{"title":"魏传柳","subtitle":null,"description":null,"author":"魏传柳(langzi989)","url":"http://yoursite.com"},"pages":[{"title":"all-archives","date":"2016-12-01T17:00:12.569Z","updated":"2016-12-01T17:00:12.569Z","comments":false,"path":"all-archives/index.html","permalink":"http://yoursite.com/all-archives/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"all-categories","date":"2016-12-01T16:59:23.933Z","updated":"2016-12-01T16:59:23.933Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"all-tags","date":"2016-12-01T16:59:49.905Z","updated":"2016-12-01T16:59:49.905Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"LinuxPs命令详解","slug":"LinuxPs命令使用","date":"2017-09-29T06:05:01.000Z","updated":"2017-09-29T06:57:53.314Z","comments":true,"path":"2017/09/29/LinuxPs命令使用/","link":"","permalink":"http://yoursite.com/2017/09/29/LinuxPs命令使用/","excerpt":"","text":"Linux ps命令使用详解ps命令常见使用方法有两种，另外我们可以通过一写参数对ps结果进行筛选和过滤。分别是:12ps -efps aux 那这两个命令有什么区别呢？下面将对这两个命令进行详细说明和解释。 ps -ef返回信息的格式:12345678UID PID PPID C STIME TTY TIME CMDroot 1 0 0 9月24 ? 00:00:25 /sbin/initroot 2 0 0 9月24 ? 00:00:00 [kthreadd]root 3 2 0 9月24 ? 00:00:00 [ksoftirqd/0]root 5 2 0 9月24 ? 00:00:00 [kworker/0:0H]root 7 2 0 9月24 ? 00:09:13 [rcu_sched]root 8 2 0 9月24 ? 00:00:00 [rcu_bh]... 对以上各列信息进行解释: uid : 用户id pid : 当前进程的id ppid : 当前进程的父进程id C : 进程占用CPU的百分比 STIME : 进程启动时间 CMD : 进程启动命令 上述返回值比较容易理解，不一一解释 ps aux返回信息的格式:12345678USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 120060 5392 ? Ss 9月24 0:25 /sbin/initroot 2 0.0 0.0 0 0 ? S 9月24 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S 9月24 0:00 [ksoftirqd/0]root 5 0.0 0.0 0 0 ? S&lt; 9月24 0:00 [kworker/0:0H]root 7 0.1 0.0 0 0 ? S 9月24 9:14 [rcu_sched]root 8 0.0 0.0 0 0 ? S 9月24 0:00 [rcu_bh]root 9 0.0 0.0 0 0 ? S 9月24 0:00 [migration/0] 对以上信息解释： user : 用户名 pid : 进程id %CPU : 进程运行占用CPU的百分比 %MEM : 进程占用内存的百分比 VSZ : 该进程使用的虚拟内存量，表示一个程序完全驻留在内存中占用的虚拟内存量 RSS : 该进程占用的固定内存量 TTY : 终端名 START : 进程开启时间 STAT : 进程的状态 TIME : 该进程实际使用的CPU时间 COMMAND : 进程运行指令 上述比较重要的信息主要包括VSZ,RSS以及STAT。VSZ表示一个程序完全驻留在内存中占用的内存量，其包括程序链接的动态链接库的大小,栈的大小以及代码段的大小。(手动算过，但是栈的大小很迷，貌似数组在栈中的大小与同类型变量的大小相同，待验证)。RSS包括运行过程中实际被加载到内存中的动态链接库，可执行文件以及栈的大小。STAT为当前进程的运行状态。其包括多种状态，具体解释如下所述: D : 不可中断(通常是IO进程) R : 正在运行或者在队列中的进程 S : 处在休眠状态的进程 T : 停止或者被追踪 Z : 僵尸进程 W : 进入内存交换 X : 死掉的进程 &lt; : 优先级较高的进程 n : 优先级较低的进程 s : 包含子进程 + : 位于后台进程组 可以在上述命令的基础上对查询结果进行筛选，如我们想要对内存占用量进行排序，方法如下: 1ps aux --sort -pMEM","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"ps","slug":"ps","permalink":"http://yoursite.com/tags/ps/"}]},{"title":"makefile自动变量与隐晦规则推导","slug":"makefile自动变量与隐晦规则推导","date":"2017-09-20T12:48:59.000Z","updated":"2017-09-24T08:48:44.367Z","comments":true,"path":"2017/09/20/makefile自动变量与隐晦规则推导/","link":"","permalink":"http://yoursite.com/2017/09/20/makefile自动变量与隐晦规则推导/","excerpt":"","text":"makefile自动变量与隐晦规则推导makefile的使用可以大大简化程序编译的过程，不过对于新手来说makefile的执行规则理解起来还是很让人迷糊的。其中最重要的原因是makefile中使用了大量的隐晦规则和自动变量来简化makefile的编写.本节将记录一下makefile自动变量和隐晦规则的推导过程以及makefile的执行流程。 12%.o:%.c $(CC) -c $(CFLAGS) -o $@ $&lt; 对于上面的推导规则，makefile是怎么将%c文件编译汇编成.o文件的？下面将针对这个问题进行讲解 自动变量makefile中的自动变量实质上是对一类变量的简写，当我们在模式规则中对这类变量处理的时候可以直接使用自动变量简化makefile代码的编写。自动变量包括如目标文件,依赖文件等。下面以实例的方式列出了一些常用的自动变量: 12a: a.o b.o c.o d.o g++ -c $(CFLAGS) -o $@ $&lt; $@: 表示模式规则中的目标文件,对于上面的模式规则,$@表示a $&lt;: 表示依赖中的第一个文件.对于上述规则,$&lt;表示a.o $^: 表示所有依赖文件的集合,对于上述规则$^表示a.o b.o c.o d.o $+: 表示所有依赖文件的集合(不去重).对于上述规则$+表示a.o b.o c.o d.o $%: 仅当目标是函数库文件(.a)文件时，表示规则中目标成员名。如一个目标是(test.a(a.o)),此时$%表示a.o, $@表示test.a $?: 所有比目标新的依赖目标的集合 $*: 表示目标规则中%以及%之前的部分。如若目标文件为”src/test.o”,目标文件模式为”src/%.o”,此时$*表示”src/test”。 隐晦规则自动规则推导使用makefile的makefile的隐晦自动规则推导功能也可以让我们的makefile的代码大大简化。使用隐晦规则，我们没必要为每一个类似的规则生成都去写类似的规则。makefile会自动推导依赖文件,并根据隐含规则推导出生成当前目标的命令。如下面的makefile:12345678target: a.o b.o c.o g++ -o $@ $^ $(LIB) $(INC) $(LINKER)a.o: a.c g++ -c $(CFLAGS) -o a.o a.cb.o: b.c g++ -c $(CFLAGS) -o b.o b.cc.o: c.c g++ -c $(CFLAGS) -o c.o c.c 上述规则没有使用隐晦规则,对于每一个.o文件的生成都写了一条规则语句.若使用隐晦规则推导，上述makefile可写为如下: 1234567SOURCE := $(shell find ./ -type f -name *.c)OBJECTS := $(patsubst *.c,*.o,$(SOURCE))target : $(OBJECTS) g++ -o $@ $^ $(LIB) $(INC) $(LINKER)%.o:%.c $(CC) -c $(CFLAGS) -o $@ $&lt; 从上面的隐晦规则可以看出,对于.o文件的生成命令，makefile都可以由隐晦规则” $(CC) -c $(CFLAGS) -o $@ $&lt;”推导出。即如当目标需要a.隐晦规则将推导出命令”g++ -c $(CFLAGS) -o a.o a.c”用于生成该目标. makefile执行过程由上一节中的makefile简单说一下makefile的执行规则。 1234567SOURCE := $(shell find ./ -type f -name *.c)OBJECTS := $(patsubst *.c,*.o,$(SOURCE))target : $(OBJECTS) g++ -o $@ $^ $(LIB) $(INC) $(LINKER)%.o:%.c $(CC) -c $(CFLAGS) -o $@ $&lt; makefile中首先声明了变量SOURCE和OBJECTS，SOURCE是当前文件夹下的所有.c文件的集合，OBJECTS是所有.c文件对应的目标文件.o的集合. 执行过程:首先,目标target依赖所有的目标文件.o，即a.o,b.o,c.o。当需要依赖a.o时，makefile会根据隐晦规则自动推导出生成a.o文件的命令，(“g++ -c $(CFLAGS) -o a.o a.c”)，生成a.o；类似的也会根据同样的过程生成b.o和c.o文件,这三个文件生成之后,再根据上述规则生成target。 makefile中常用函数wildcard函数函数参数:一个正则表达式函数功能:wildcard的中文意思是通配符，它的功能类似于正则表达式，用于展开一列所有符合其参数描述的文件名，文件之间用空格分割。 实例:1SOURCE=$(wildcard *.cpp) 此时SOURCE的值为所有的以.cpp为后缀的文件集合，以空格隔开。 patsubst函数函数参数: 第一个是需要匹配的样式，第二个是表示用什么替换它，第三个被处理的以空格隔开的字符串。函数功能:其功能是一个匹配替换的函数(pattern substitute)。 实例:12#TARGET表示与SOURCE中同名的目标文件.TARGET = $(patsubst *.cpp, *.o, $(SOURCE)) subst函数1$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;) 功能:字符串替换,将text中的from 替换为to实例:12#返回值：this is b$(subst a, b, this is a) strip函数1$(strip &lt;string&gt;) 功能:去除头部和尾部的空格实例:12#源字符串为&quot;a b c &quot;，返回值为&quot;a b c&quot;$(strip a b c ) filter函数1$(filter &lt;pattern...&gt;,&lt;text...&gt;) 功能:过滤特定模式的字符串实例:12#如source为a.c b.s c.h,则下列的返回值为a.c b.s$(filter *.c *.s, $(source)) word函数1$(word &lt;n&gt;,&lt;text&gt;) 函数功能:取单词函数。取出中的第n个单词(从1开始)，若越界，返回为空 实例:12#此函数返回值为bar$(word 2,foo bar fun) words函数1$(words &lt;text&gt;) 功能:统计字符串中单词的个数,返回个数实例:12#此函数返回值为3$(word foo bar fun) wordlist函数1$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt;) 功能:取中s-e个单词实例:12#返回bar fun$(wordlist 2,3, foo bar fun) firstword函数1$(firstword &lt;text&gt;) 函数功能：取中的首个单词实例:12#返回值为foo$(firstword foo bar fun) dir函数1$(dir ...) 功能：取给定文件名序列中的目录（即/前面的部分）。如没有/，则返回./实例：12#返回值为/home/ ./$(dir /home/test testfile) notdir函数1$(notdir ...) 功能：取给定文件名序列中的取出非目录部分（即/后面的部分）。实例：12#返回值为test testfile$(notdir /home/test testfile) suffix函数1$(suffix ..) 功能:取后缀函数,若没有后缀返回为空实例：12#返回值:.c .c$(suffix a.c b.c) basename函数1$(basename ...) 功能:取前缀函数,包括目录。实例:12#返回值:/home/test a$(basename /home/test.cpp a.cpp) addsuffix函数1$(addsuffix &lt;suffix&gt; &lt;name....&gt;) 功能：给指定文件序列添加后缀名实例:12#返回值:a.c b.c c.c$(addsuffix .c a b c) addprefix1$(addprefix &lt;prefix&gt; &lt;name...&gt;) 功能：给指定文件序列添加前缀实例：12#返回值:src/a src/b src/c$(addprefix src/ a b c) join函数1$(join &lt;list1&gt; &lt;list2&gt;) 功能:将两个字符串中的list对应项连接实例:1234#返回值:an 2b 3$(join 1 2 3, a b)#返回值:1a 2b c$(join 1 2, a b c) makefile中链接静态库顺序问题在链接静态库的时候，如果多个静态库之间存在依赖关系，则有依赖的静态库之间存在顺序问题，若顺序出现错误，则可能出现函数未定义或符号找不到等错误。 静态库链接的顺序的原则是：被依赖的库一定要放在后面，因为makefile在链接静态库时的顺序是从右往左(或从后向前).如libb.a依赖于liba.a，此时的链接顺序应该是:-Llibb.a -Lliba.a。 会出现上述问题的原因是:我们在生成静态库的时候并未把依赖库的定义编到生成的库中。如 1234gcc -c a.car cr liba.a a.ogcc -c b.car cr libb.a b.o # 虽然libb.a使用到了liba.o中的一些函数,但并不会将它们的定义包含进来,所以在链接test时需要指定这两个库","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"},{"name":"自动变量","slug":"自动变量","permalink":"http://yoursite.com/tags/自动变量/"},{"name":"规则推导","slug":"规则推导","permalink":"http://yoursite.com/tags/规则推导/"}]},{"title":"UnixIPC 机制和key_t本质类型","slug":"UnixIPC中key_t类型本质","date":"2017-09-20T12:09:08.000Z","updated":"2017-09-24T10:16:56.458Z","comments":true,"path":"2017/09/20/UnixIPC中key_t类型本质/","link":"","permalink":"http://yoursite.com/2017/09/20/UnixIPC中key_t类型本质/","excerpt":"","text":"System V IPC 机制和key_t本质类型System V三种IPC机制System V IPC包括三种不同的通信机制 消息队列:消息队列类似于管道,但是又有很大的差别。第一,消息队列是有边界的，所以消息队列的通信机制是通过消息进行传递，而管道是通过字节流进行通信。第二，每条消息包括一个完整的整形字段，消息队列可以通过类型来选择消息。 信号量:用于同步两个进程。 共享内存:共享内存允许两个进程共享同一个内存段。即一块内存被映射到不同进程的虚拟内存中。 key_t本质System V系统调用都有一个相关的get系统调用，它与文件io中的open函数类似，不同的是它的参数是一个整数，给定一个整数之后，系统会做以下操作: 使用给定key创建一个新的IPC对象，并将IPC对象标识key_t返回给调用者. 若该key对应的IPC对象存在，直接将标识返回给调用者，相当于使用key换取标识,而不做创建操作. 上述IPC对象的标识类型为key_t。key_t的本质是什么?我们可以通过grep命令追踪到 在文件/usr/include/sys/ipc.h中:1234#ifndef __key_t_definedtypedef __key_t key_t;# define __key_t_defined#endif 在文件/usr/include/bits/types.h中:1__STD_TYPE __KEY_T_TYPE __key_t; /* Type of an IPC key. */ 在文件/usr/include/bits/typesizes.h中: 1#define __KEY_T_TYPE __S32_TYPE 在文件中: 1#define __S32_TYPE int 故从上面的追踪，可以看出key_t的本质为int类型. 获取key_t方法获取ket_t的方法三种 随机选取一个整数值作为key值，多个进程共享一个key值。注意此时不能使用已经存在的key 在创建IPC对象的get方法中用IPC_PRIVATE作为key值，这样会导致每个调用都会创建一个新的IPC对象 使用ftok函数生成一个key,这个方法产生的key接近唯一。 IPC_PRIVATEIPC_PRIVATE本质上为0的宏定义.使用方法是直接使用IPC_PRIVATE作为key生成一个IPC对象。这种做法保证每次产生的都是全新的IPC对象。这种做法适用于在父进程fork前创建IPC对象，从而达到子进程继承IPC对象的目的。 ftok生成key函数原型:12#include &lt;sys/ipc.h&gt;key_t ftok(char* pathname, int proj); 函数功能:此函数的功能是根据pathname和proj的值生成key，该算法只使用proj的最低的8个有效位，应用程序必须确保pathname引用一个可以应用stat()的既有文件。否则该函数会返回-1。 在linux中，key_t一般是32位的值。它通过取proj参数的最低８个有效位，包含该文件所属的文件系统的设备的设备号的最低8个有效位以及pathname所引用文件的inode号的最低16个有效位组合而成，这样保证了唯一性。所以从上面可以看出，对于同意个文件的不同路径(inode值相同),proj值相同，此时产生的key是相同的。","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"ipc","slug":"ipc","permalink":"http://yoursite.com/tags/ipc/"},{"name":"key_t","slug":"key-t","permalink":"http://yoursite.com/tags/key-t/"}]},{"title":"UnixIPC 关联数据结构与对象权限","slug":"UnixIPC关联数据结构与对象权限","date":"2017-09-20T12:09:08.000Z","updated":"2017-09-24T11:34:39.183Z","comments":true,"path":"2017/09/20/UnixIPC关联数据结构与对象权限/","link":"","permalink":"http://yoursite.com/2017/09/20/UnixIPC关联数据结构与对象权限/","excerpt":"","text":"UnixIPC 关联数据结构与对象权限","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"ipc","slug":"ipc","permalink":"http://yoursite.com/tags/ipc/"},{"name":"ipc_perm","slug":"ipc-perm","permalink":"http://yoursite.com/tags/ipc-perm/"}]},{"title":"Linux中umask深入理解","slug":"Linux中umash深入理解","date":"2017-09-13T06:53:01.000Z","updated":"2017-09-13T06:53:32.983Z","comments":true,"path":"2017/09/13/Linux中umash深入理解/","link":"","permalink":"http://yoursite.com/2017/09/13/Linux中umash深入理解/","excerpt":"","text":"Linux中umask深入理解umask(user file-creatiopn mode mask)为用户文件创建掩码，是创建文件或文件夹时默认权限的基础。通常我们可以使用chmod修改linux中文件的权限.umask的作用与chmod的效果相反，具体看下面。 若没有文件掩码时，文件的默认权限为0666,文件夹的默认权限为0777。 原因: 创建文件一般是用来读写，所以默认情况下所有用户都具有读写权限，但是没有可执行权限，所以文件创建的默认权限为0666 而文件夹的x权限表示的是打开权限，所以这个权限必须要有，所以文件夹的默认权限为0777。 用户掩码作用上述的权限是在没有umask情况下的默认权限。但是系统为了保护用户创建文件和文件夹的权限,此时系统会有一个默认的用户掩码(umask)，大多数的Linux系统的默认掩码为022。用户掩码的作用是用户在创建文件时从文件的默认权限中去除掩码中的权限。所以文件创建之后的权限实际为:12＃文件创建权限默认权限(文件0666,文件夹0777)-umask 所以在用户不修改umask的情况下，创建文件的权限为：0666-0022=0644。创建文件夹的权限为：0777-0022=0755 查看与修改默认掩码查看用户掩码:1234#以数字方式查看掩码umask# 以符号形式查看掩码umask -S 可以使用umask命令直接修改掩码。1umask 0000 上述方法修改的掩码只在当前tty中生效.若要全局生效,可以讲umask值写在/etc/profile或者.bashrc中","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"umask","slug":"umask","permalink":"http://yoursite.com/tags/umask/"}]},{"title":"Unix高级编程之signal","slug":"Unix高级编程之signal","date":"2017-09-09T21:24:40.000Z","updated":"2017-09-10T10:56:47.947Z","comments":true,"path":"2017/09/10/Unix高级编程之signal/","link":"","permalink":"http://yoursite.com/2017/09/10/Unix高级编程之signal/","excerpt":"","text":"Unix高级编程之signalsignal函数相关的细节描述详见另外两篇篇博客，这里不详细赘述:https://langzi989.github.io/2017/09/08/C++%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0/https://langzi989.github.io/2017/05/04/Wait%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/ 显示信号的描述信号的个数可以用宏NSIG获取。 显示信号的描述有三种方法:123456789#include &lt;string.h&gt;//first methodchar* strsignal(int sig);//second method,void psignal(int sig, char* msg);//third memthodsys_siglist[sig]; 上述三种方法的区别sys_siglist是直接存储信号描述的数组，一般情况下，推荐使用strsignal。 strsignal和psignal函数对locale敏感，会打印出当地的语言。调用psignal会在本地的错误出输出流输出，msg:strsignalmsg； 如:12//此时错误数据流将会打印出:SIGINT:Interruptpsignal(SIGINT, &quot;SIGINT&quot;); 信号集许多相关的系统调用涉及到一组不同的信号，这时候需要信号集。linux中使用sigset_t结构体来表示信号集。一般情况，信号集是使用掩码实现的，但是可能有一些是其他实现方式。信号集结构体相关的函数.123456789101112131415161718192021222324252627282930#include &lt;signal.h&gt;//初始化空信号集。注意不可使用memset或者静态变量全局变量初始化信号集为空，这样会出问题。因为不是所有的信号集都是通过掩码实现的//0出错，1成功int sigemptyset(sigset_t* set);//初始化信号集包括所有的信号//0出错，1成功int sigfillset(sigset_t* set);//向信号集中添加信号//0出错，1成功int sigaddset(sigset_t* set, int sig);//从信号集中去除信号//0出错，1成功int sigdelset(sigset_t* set, int sig);//检查某一信号是不是在当前信号集中。返回1在,０不在int sigismember(const sigset_t* set, int sig);//以下三个为GNU C中的非标准函数，＃define _GNU_SOURCE//对两个信号集作交集存储于dest中int sigandset(sigset_t* dest, sigset_t* left, sigset_t* right);//对两个信号集做并集存储于dest中int sigorset(sigset_t* dest, sigset_t* left, sigset_t* right);//判断信号集是否为空int sigisemptyset(const sigset_t* set); 信号掩码(进程中阻塞信号传递)内核会为每个进程维护一个信号掩码(标识一组信号),当一个信号被传递到该进程的时候，若该信号在信号掩码中,进程会阻塞该信号的传递，直到将该信号从信号掩码中剔除。 向信号掩码中添加一个信号的方式有以下几种： 当调用信号处理器程序的时候，可将引发该调用的信号自动添加到信号掩码中，这取决于sigaction函数在安装信号时使用的标志。 使用sigaction函数建立信号处理程序时，可以指定一组额外信号,当调用该处理器程序时将阻塞。 使用sigprocmask函数修改进程的信号掩码。 sigprocmask函数12#include &lt;signal.h&gt;int sigprocmask(int how, const sigset_t* set, sigset_t* old); 参数: how : 指定修改信号掩码的方式,有三种方式 SIG_BLOCK : 向指定信号中添加指定信号. SIG_UNBLOCK: 将指定信号从原有的信号掩码中移除。若被移除的信号掩码不存在不报错 SIG_SETMASK: 直接设置(赋值),覆盖原有的值 set : 需要设置的新的信号掩码集 old: 旧的信号掩码集。可在设置信号掩码集之后回复原有的信号掩码。 12345678910111213141516171819202122#include &lt;unistd.h&gt;#include &lt;signal.h&gt;int main() &#123; time_t start = time(NULL); sigset_t new_set, pre; sigemptyset(&amp;new_set); sigaddset(&amp;new_set, SIGINT); if (sigprocmask(SIG_SETMASK, &amp;new_set, &amp;pre) == -1) &#123; std::cout&lt;&lt; \"sigprocmask set error\" &lt;&lt; std::endl; &#125; while (true) &#123; sleep(1); time_t end = time(NULL); if (end - start &gt;= 15) &#123; std::cout &lt;&lt; \"hahah 接触阻塞\" &lt;&lt; std::endl; sigprocmask(SIG_SETMASK, &amp;pre, NULL); &#125; &#125;&#125; sigpending获取正在等待状态的信号若进程接收信号被阻塞之后，我们希望获取被阻塞的信号，则可以使用sigpending函数 12#include &lt;signal.h&gt;int sigpending(sigset_t* set); 使用此函数的场景是:若某个进程接收到被阻塞的信号,如果希望这些信号被移出阻塞队列,此时可以通过sigpending获取被阻塞的信号，然后将此信号的处理器函数IGNORE,并将其剔除信号掩码即可。 在信号被阻塞的时候，不对信号做排队处理，即即使进程阻塞了100个SIGINT信号，此时当SIGINT从信号掩码中去除时，该进程接收的还是只是一个SIGINT信号。 sigaction函数除了signal函数之外,sigaction系统调用是设置信号处理的另一个选择。sigaction和signal函数相比更加灵活和具有可移植性。sigaction允许在不改变信号处理器程序的情况下获取信号的默认处理方式。","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"signal","slug":"signal","permalink":"http://yoursite.com/tags/signal/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"sigaction","slug":"sigaction","permalink":"http://yoursite.com/tags/sigaction/"}]},{"title":"Linux中ulimit命令简单使用","slug":"Linux中ulimit命令简单使用","date":"2017-09-09T02:05:01.000Z","updated":"2017-09-09T02:06:40.168Z","comments":true,"path":"2017/09/09/Linux中ulimit命令简单使用/","link":"","permalink":"http://yoursite.com/2017/09/09/Linux中ulimit命令简单使用/","excerpt":"","text":"linux中ulimit命令简单使用 系统性能是一个受关注的话题，如何通过最简单的设置来实现有效的性能调优，如何在有限资源的条件下保证程序的运作，ulimit是我们在处理问题的时候经常使用的一种手段。ulimit是一种linux系统内置的功能。下面将列举ulimit的一些常用关键字和简单用法。 ulimit命令参数ulimit参数命令 注意ulimit设置分软硬区别，加-H为硬,-S为软.默认查询是显示的是软，但使用ulimit进行设置的时候为软硬都作用。 参数 功能 示例 -H 设置硬资源限制，一旦设置不能增加。 ulimit – Hs 64；限制硬资源，线程栈大小为 64K。 -S 设置软资源限制，设置后可以增加，但是不能超过硬资源设置。 ulimit – Sn 32；限制软资源，32 个文件描述符。 -a 显示当前所有的 limit 信息。 ulimit – a；显示当前所有的 limit 信息。 -c 最大的 core 文件的大小， 以 blocks 为单位。 ulimit – c unlimited； 对生成的 core 文件的大小不进行限制。 -d 进程最大的数据段的大小，以 Kbytes 为单位。 ulimit -d unlimited；对进程的数据段大小不进行限制。 -f 进程可以创建文件的最大值，以 blocks 为单位。 ulimit – f 2048；限制进程可以创建的最大文件大小为 2048 blocks。 -l 最大可加锁内存大小，以 Kbytes 为单位。 ulimit – l 32；限制最大可加锁内存大小为 32 Kbytes。 -m 最大内存大小，以 Kbytes 为单位。 ulimit – m unlimited；对最大内存不进行限制。 -n 可以打开最大文件描述符的数量。 ulimit – n 128；限制最大可以使用 128 个文件描述符。 -p 管道缓冲区的大小，以 Kbytes 为单位。 ulimit – p 512；限制管道缓冲区的大小为 512 Kbytes。 -s 线程栈大小，以 Kbytes 为单位。 ulimit – s 512；限制线程栈的大小为 512 Kbytes。 -t 最大的 CPU 占用时间，以秒为单位。 ulimit – t unlimited；对最大的 CPU 占用时间不进行限制。 -u 用户最大可用的进程数。 ulimit – u 64；限制用户最多可以使用 64 个进程。 -v 进程最大可用的虚拟内存，以 Kbytes 为单位。 ulimit – v 200000；限制最大可用的虚拟内存为 200000 Kbytes。 ulimit参数作用范围 针对单个tty生效:在tty中直接运行ulimit命令的作用范围是只对当前tty生效 针对单个用户生效:将命令添加到.bashrc中,将对当前用户生效 针对所有用户生效:将命令添加到/etc/security/limits.conf中，可以设置针对特定用户或者所有用户的限制。","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"ulimit","slug":"ulimit","permalink":"http://yoursite.com/tags/ulimit/"}]},{"title":"C++函数指针学习","slug":"C++函数指针学习","date":"2017-09-08T09:47:20.000Z","updated":"2017-09-09T02:40:11.185Z","comments":true,"path":"2017/09/08/C++函数指针学习/","link":"","permalink":"http://yoursite.com/2017/09/08/C++函数指针学习/","excerpt":"","text":"C++函数指针学习使用函数指针的优点使用函数指针有助于我们设计出更优秀，更简洁更高效的程序。在下面的情景中我们常用到函数指针: 使用函数指针作为参数 使用函数指针作为返回值 使用函数指针作为回调函数 使用函数指针数组 类的静态方法和非静态方法的函数指针 使用函数指针实现动态绑定 在结构体中定义函数 使用函数指针提高函数的效率当通过switch case多用多个相同类型的函数的时候，这个时候使用函数指针可以大大简化函数代码并可以明显的提高程序的执行效率。例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;time.h&gt;#include &lt;string&gt;#include &lt;sys/time.h&gt;using namespace std;#define StartTime(id) struct timeval __now1105##id;\\ gettimeofday(&amp;__now1105##id, 0);#define EndTime(id) struct timeval __now21105##id; \\ gettimeofday(&amp;__now21105##id, 0); \\ printf(&quot;timer_%s spend time:%d us\\n&quot;,#id,(__now21105##id.tv_sec-__now1105##id.tv_sec)* 1000000 + (__now21105##id.tv_usec-__now1105##id.tv_usec));double add(double a, double b) &#123; return a + b;&#125;double sub(double a, double b) &#123; return a - b;&#125;double multi(double a, double b) &#123; return a * b;&#125;double div(double a, double b) &#123; return a/b;&#125;typedef double (*op)(double, double);void func1(double a, double b, int flag) &#123; switch(flag) &#123; case 0: add(a, b); break; case 1: sub(a, b); break; case 2: multi(a, b); break; case 3: div(a, b); break; default: break; &#125;&#125;//使用函数指针调用函数void func2(double a, double b, op cb) &#123; cb(a, b);&#125;int main() &#123; StartTime(func1); for (int i = 0; i &lt; 100000; i++) &#123; func1(0.2, 0.034, 3); &#125; EndTime(func1); StartTime(func2); for (int i = 0; i &lt; 100000; i++) &#123; func2(0.2, 0.034, multi); &#125; EndTime(func2);&#125; 由上面可以看出,由于上述switch,case中调用的函数类型（返回值类型，参数个数以及对应的类型）完全一致，我们将函数指针以参数的形式传到处理函数中。运行上述函数的结果如下: 12timer_func1 spend time:2861 ustimer_func2 spend time:2178 us 可以看出使用函数指针的效率远远高于switch case 函数指针用做回调函数 来源于wiki在计算机程序设计中，回调函数是指通过函数参数传递到其他代码的，某一块可执行代码的引用。这一设计允许底层代码调用在高层定义的子程序。如Linux C中的signal函数就是这样一个例子。 signal底层的其中一个实现版本如下:由其实现可以看出信号处理的回调函数的主要功能是将处理信号的函数指针替换为用户高层自定义的函数地址fun，从而达到当接收到该信号时底层代码调用高层定义代码的效果。 12345678910111213141516171819Sigfunc *signal(int signo, Sigfunc *func)&#123; struct sigaction act, oact; act.sa_handler = func; sigemptyset(&amp;act.sa_mask); act.sa_flags = 0; if (signo == SIGALRM) &#123;#ifdef SA_INTERRUPT act.sa_flags |= SA_INTERRUPT;#endif &#125; else &#123; act.sa_flags |= SA_RESTART; &#125; if (sigaction(signo, &amp;act, &amp;oact) &lt; 0) return(SIG_ERR); return(oact.sa_handler);&#125; 当我们使用signal函数的时候,如下：123456789101112#include &lt;signal.h&gt;#include &lt;stdio.h&gt;void signalcb(int signum) &#123; printf(&quot;this is the signal:%d&quot;, signum);&#125;int main() &#123; signal(SIGINT, signalcb); pause(); return 0;&#125; 函数指针的本质及声明方法以及赋值函数指针的本质函数指针类似于数据指针，其本质实质上是一类函数（返回值类型相同，参数个数以及对应的参数类型相同）的入口地址，即该可执行代码在内存中的起始地址。函数指针可以让我们通过函数地址去调用该函数。有利于实现函数的动态绑定，即在运行时才决定去调用哪个函数。 函数指针的声明方法函数指针的声明方法有两种，包括: 普通函数的函数指针和类静态成员函数的函数指针 类非静态成员函数的函数指针 普通函数的函数指针和类静态成员函数的函数指针:int (funptr)(int qa, int qb);类非静态成员函数的函数指针：int MyClass::(funptr)(int qa, int qb); 注意上述函数指针声明时(*funptr)中的括号不能省略，若省略，有可能会产生歧义，其意义就变成了返回值为int*的函数定义了 上述两种函数指针声明不兼容的原因如下:(《深度探索C++对象模型》)获取类的静态和非静态函数的函数指针的地址都是其在内存中实际的地址。那为什么非静态成员的指针需要绑定(指明类)？原因是类的非静态成员需要操作类的数据成员,所以类的非静态成员需要绑定this指针找到类的数据成员。故对nonstatic函数取地址是不完整的。 函数指针的赋值与使用函数指针赋值对于普通指针和类的静态成员指针，有两种赋值方式:12funptr = fnc1funptr = &amp;fun1 对于类的非静态成员指针，只能用上面第二种形式赋值。为了保证形式的一致性和避免二义性，一般统一使用取地址符号进行赋值可避免错误出现。1funptr = &amp;classInstance.func(); 函数指针使用函数指针的使用类似于赋值。对于普通指针和类的静态成员函数指针的调用，有两种调用方式:123funptr(1,2);(*funptr)(1,2); 对于类的静态成员函数，只能用上述第二种方式进行调用，为了保持一致性和避免二义性，一般统一使用使用*来解引用函数指针进行调用. 函数指针作为参数函数指针是一个类型，将函数指针作为参数传入函数中与其他参数类似。使用方式与上述函数指针用做回调函数中signal接收参数的方式相同。这里不再详解 函数指针作为返回值既然函数指针是函数的入口地址,所以函数指针也可以作为函数的返回值返回。不过函数指针作为函数的返回值的写反比较复杂。若一个函数func只有一个参数int, 其返回值类型是float (*) (float, float)；则其函数原型如下:1float (*func(int op)) (float, float); 函数指针作为函数返回值的原则是,将函数名以及参数写到*后，函数指针的返回值放在最前面，函数指针的参数放在最后面。 由上面的知识我们可以分析一下signal函数原型。1void (*signal)(int signo,void (*func)(int)))(int); 其定义了一个有两个参数分别为int和void (func)(int)，返回值为void (func)(int)的函数。 其本质上是将函数处理指针替换为用户自定义的函数指针。那为什么需要返回值为void (func)(int)呢?原因是*signal函数的返回值是旧的信号处理函数的指针，我们可以通过这个指针暂时改变signal函数处理信号的方式。之后可以通过返回的指针恢复该信号默认的处理方式。 注意:signal的信号处理其函数中的int参数的含义是:当信号到达的时候,内核将该信号以整形的方式传给处理器函数，即为void (*func)(int sig)中的sig. 使用typedef定义函数指针一般情况下，如果通过普通的方式定义函数指针，在使用的很不方便。这个时候我们可以通过typedef定义函数指针的新类型。通过typedef定义新类型时与普通类型定义新类型方式不同。对于普通类型，定义方式如下:1typedef int64_t int64; 但是对于函数指针，定义方式如下: 1234567//此处定义个名字为func的类型,它表示函数指针float (*func)(float, float)类型typedef float (*func)(float, float);float function(float a, floatb);//使用func定义变量func test = &amp;function;","raw":null,"content":null,"categories":[{"name":"C++ problems","slug":"C-problems","permalink":"http://yoursite.com/categories/C-problems/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"函数指针","slug":"函数指针","permalink":"http://yoursite.com/tags/函数指针/"},{"name":"回调函数","slug":"回调函数","permalink":"http://yoursite.com/tags/回调函数/"},{"name":"signal","slug":"signal","permalink":"http://yoursite.com/tags/signal/"}]},{"title":"makefile详解","slug":"makefile详解","date":"2017-08-31T09:22:57.000Z","updated":"2017-08-31T09:28:49.059Z","comments":true,"path":"2017/08/31/makefile详解/","link":"","permalink":"http://yoursite.com/2017/08/31/makefile详解/","excerpt":"","text":"makefile详解 makefile基础http://blog.csdn.net/ruglcc/article/details/7814546/ makefile依赖关系详解http://blog.chinaunix.net/uid-20682147-id-76330.htmlhttp://blog.csdn.net/aquester/article/details/48547685","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]},{"title":"Linux正则表达式以及Sed使用学习","slug":"Linux正则表达式","date":"2017-08-20T07:11:12.000Z","updated":"2017-08-20T11:58:41.638Z","comments":true,"path":"2017/08/20/Linux正则表达式/","link":"","permalink":"http://yoursite.com/2017/08/20/Linux正则表达式/","excerpt":"","text":"Linux正则表达式以及Sed使用学习正则表达式是熟悉和使用Linux系统的最重要的基础，其中grep,find,awk以及sed等对其依赖更大。本节将总结一下Linux中常用的正则表达式使用方法。 正则表达式中特殊字符 . : 表示任何单个字符 [] : 包含一个字符序列，表示匹配序列中其中一个字符 - : 出现在[]中,表示一个序列范围.如[a-z]表示26个小写的英文字母 ^ : 出现在[]中，表示对序列去反。如[^a-z]表示匹配不是a-z的其他字符 * : 匹配某一个字符的０个或1个或多个实例 ? : 匹配某一个字符的0个或1个实例 + : 匹配某一个字符的1个或多个实例 $ : 匹配行尾。如test$指匹配以test结尾的行 ^ : 匹配行首。如^test指匹配以test开始的行 \\&lt; : 匹配词首 > : 匹配词尾 \\ : 转移特殊字符,如果需要匹配上述特殊字符，用反斜杠转义 sed使用说明sed命令：1sed [OPTION]... &#123;script-only-if-no-other-script&#125; [input-file]... sed使用data文件内容1234this is a dog athis is a catthis is a moneythis is a fish 用s命令进行替换替换时若出现单引号，直接将脚本用双引号括起来即可。1.将一行中第一个匹配的特定字符串替换1sed &quot;s/a/an/&quot; data 注意不会改变原文件，只是会打印到标准输出流。若要保存可以重定向到新的文件中。 2.讲一行中所有匹配的特定字符串匹配，使用g参数1sed &quot;s/a/an/g&quot; data 3.使用-i参数直接修改文件内容1sed -i &quot;s/a/an/g&quot; data 4.在每一行的开头添加内容1sed &quot;s/^/#/&quot; data 5.在每一行的结尾添加内容1sed &quot;s/$/#/&quot; data 6.指定特定行替换,或指定特定范围内的行替换12sed &quot;3s/an/a/&quot; datased &quot;1,2s/an/a/&quot; data 7.只替换每一行的第一个a:1sed &quot;s/a/an/1&quot; data 8.只替换每一行的第二个a:1sed &quot;s/a/an/2&quot; data 9.只替换每一行第二个以后的所有a1sed &quot;s/a/an/2g&quot; data 多个匹配多个匹配可以用分好将匹配规则连接。1sed &quot;s/an/a/g;s/dog/cat/g&quot; data 上述命令等价于:1sed -e &quot;s/an/a/g&quot; -e &quot;s/dog/cat/g&quot; data 显示被匹配的变量&amp;可以表示被匹配的变量,即若被匹配的变量为”abc”,则&amp;代表abc。12#功能为在每个an外加[]sed -e &quot;s/an/[&amp;]/g&quot; data 圆括号匹配被圆括号括起来的匹配可以当做变量使用，注意圆括号匹配时括号需要”\\”转义。变量按顺序使用\\1,\\2指代。1sed &quot;s/this \\(.*\\) an \\(.*\\)/\\1:\\2/&quot; data 结果:1234is:dog anis:cantis:moneyis:fish sed命令data内容:1234this is a dog athis is a catthis is a moneythis is a fish N命令N命令的作用是把下一行的命令纳入当做缓冲区。也就是缓冲区包括两行.12#只匹配缓冲区的第一个thissed &quot;N;s/this/that/&quot; data 执行命令结果为:1234that is a dog athis is a catthat is a moneythis is a fish 1sed &quot;N;s/\\n/,/&quot; data 执行命令结果为:12this is a dog a,this is a catthis is a money,this is a fish a命令和i命令 i命令的作用是在指定行前面插入一行，行号写在i前面，中间空格可有可无；如果不写行号默认在所有行的前面插入 12#在第一行前面插入 this is my test ised &quot;1i this is my test i&quot; data a命令的作用是在指定行后追加内容,行号写在a前面，若不写表示所有行后。也可用$代表最后一行，不过一定要有空格. 12#在第一行后插入 this is my test ased &quot;1a this is my test a&quot; data 可以使用匹配来添加 12#若匹配到cat，则在当前行后追加一行 this is test match ased &quot;/cat/a this is test match a&quot; data c命令c命令是替换匹配的行12#替换第二行sed &quot;2 c this is test c&quot; data 结果:1234this is a dog athis is test cthis is a moneythis is a fish 12#用匹配替换sed &quot;/fish/c this is the test c&quot; data 结果:1234this is a dog athis is a catthis is a moneythis is the test c d命令d命令删除指定的行，可指定范围12#删除第２到3行sed &quot;2,3 d&quot; data 结果:12this is a dog athis is a fish 12#删除找到cat指定的行sed &quot;/cat/d&quot; data 结果:123this is a dog athis is a moneythis is a fish 12#删除第二行到结尾sed &quot;2,$ d&quot; data 结果:1this is a dog a p命令p命令的作用是打印匹配到的行.注意打印的时候使用-n参数。sed默认输出处理后的文本，使用-n参数阻止默认输出。 12#打印匹配到cat的行sed -n &quot;/cat/p&quot; data 12#打印符合从一个模式当另一个模式的行sed -n &quot;/dog/,/money/p&quot; data 结果:123this is a dog athis is a catthis is a money 12#打印从第一行到匹配到的哪一行sed -n &quot;1,/cat/p&quot; data 结果:12this is a dog athis is a cat =命令=参数用于打印匹配到的行号12#打印含有cat的行号sed -n &quot;/cat/=&quot; data 综合运用将下列中所有的100替换为当前行号 12345678910111213hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100hmset &apos;99_p_100&apos; &apos;m_19&apos; 100 &apos;t_19&apos; 100 &apos;semm_19&apos; 100 shell命令如下:1sed = data | sed &quot;N;s/\\([0-9]*\\)\\n\\(hmset &apos;99_p_\\)[0-9]*\\(&apos; &apos;m_19&apos; \\)[0-9]*\\( &apos;t_19&apos; \\)[0-9]*\\( &apos;semm_19&apos; \\)[0-9]*/\\2\\1\\3\\1\\4\\1\\5\\1/&quot; 结果如下:12345678910111213hmset &apos;99_p_1&apos; &apos;m_19&apos; 1 &apos;t_19&apos; 1 &apos;semm_19&apos; 1hmset &apos;99_p_2&apos; &apos;m_19&apos; 2 &apos;t_19&apos; 2 &apos;semm_19&apos; 2hmset &apos;99_p_3&apos; &apos;m_19&apos; 3 &apos;t_19&apos; 3 &apos;semm_19&apos; 3hmset &apos;99_p_4&apos; &apos;m_19&apos; 4 &apos;t_19&apos; 4 &apos;semm_19&apos; 4hmset &apos;99_p_5&apos; &apos;m_19&apos; 5 &apos;t_19&apos; 5 &apos;semm_19&apos; 5hmset &apos;99_p_6&apos; &apos;m_19&apos; 6 &apos;t_19&apos; 6 &apos;semm_19&apos; 6hmset &apos;99_p_7&apos; &apos;m_19&apos; 7 &apos;t_19&apos; 7 &apos;semm_19&apos; 7hmset &apos;99_p_8&apos; &apos;m_19&apos; 8 &apos;t_19&apos; 8 &apos;semm_19&apos; 8hmset &apos;99_p_9&apos; &apos;m_19&apos; 9 &apos;t_19&apos; 9 &apos;semm_19&apos; 9hmset &apos;99_p_10&apos; &apos;m_19&apos; 10 &apos;t_19&apos; 10 &apos;semm_19&apos; 10hmset &apos;99_p_11&apos; &apos;m_19&apos; 11 &apos;t_19&apos; 11 &apos;semm_19&apos; 11hmset &apos;99_p_12&apos; &apos;m_19&apos; 12 &apos;t_19&apos; 12 &apos;semm_19&apos; 12hmset &apos;99_p_13&apos; &apos;m_19&apos; 13 &apos;t_19&apos; 13 &apos;semm_19&apos; 13","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"sed","slug":"sed","permalink":"http://yoursite.com/tags/sed/"},{"name":"regex","slug":"regex","permalink":"http://yoursite.com/tags/regex/"}]},{"title":"Linux常用命令混淆点记录","slug":"Linux常用命令","date":"2017-08-20T06:25:01.000Z","updated":"2017-09-29T06:53:42.070Z","comments":true,"path":"2017/08/20/Linux常用命令/","link":"","permalink":"http://yoursite.com/2017/08/20/Linux常用命令/","excerpt":"","text":"Linux常用命令混淆点记录ls命令单位问题ls命令的默认单位为字节。若使用ls时需要指定单位显示的时候，需要添加参数-h或–block-size进行操作。具体操作方法如下: 1234567891011#-h表示human，即人可读的方式#它会按照文件的大小显示单位,#若文件小于1k，则不显示单位，表示字节#若文件大于1k但是小于1M，显示的单位为k#文件大于1M小于1G会显示单位为M，#以此类推ls -h ~/test#按照指定的单位显示#注意使用此参数需要注意一个问题。若文件小于1Gls --block-size=g ~/test #按照单位为g显示","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"ls","slug":"ls","permalink":"http://yoursite.com/tags/ls/"}]},{"title":"查找含有特定字符串的文件","slug":"Linux查找含有特定字符串的文件","date":"2017-08-20T06:25:01.000Z","updated":"2017-08-20T06:40:10.997Z","comments":true,"path":"2017/08/20/Linux查找含有特定字符串的文件/","link":"","permalink":"http://yoursite.com/2017/08/20/Linux查找含有特定字符串的文件/","excerpt":"","text":"Linux查找含有特定字符串的文件Linux查找含有特定字符串的文件命令为grep。以下为详细的使用方法 grepLinux命令:1234grep [OPTIONS] PATTERN [FILE...]#实例:递归查找当前文件夹下所有含有test的文件，并显示行号grep -rn &quot;test&quot; * 参数说明1234567891011-r 递归查找-n 显示行号-i 忽略大小写-w 只匹配整个单词，而不是字符串的字部分(如pattern为&quot;test&quot;, 不匹配&quot;test1&quot;或&quot;atest&quot;)-C num 显示匹配到的行上下n行 -l 只列出匹配成功的文件名-L 列出不匹配的文件名\\&lt; 标注单词的开头\\&gt; 标注单词的结尾^ 指匹配字符串在行首$ 指匹配字符串在行尾 常用实例123456789101112131415#显示匹配pattern1或pattern2的行grep pattern1 | pattern2 file# 显示即匹配pattern1又匹配pattern2的行grep pattern1 file | grep pattern2#只匹配test或testA，不匹配Atestgrep &quot;\\&lt;man&quot; *#只匹配test或Atest，不匹配testAgrep &quot;man\\&gt;&quot; *#只匹配test 不匹配testA和Atestgrep &quot;\\&lt;test\\&gt;&quot; *#匹配行首为test的行:grep -rn &quot;^test&quot; *#匹配行尾为test的行grep -rn &quot;test$&quot; *","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"grep","slug":"grep","permalink":"http://yoursite.com/tags/grep/"}]},{"title":"C中编码问题","slug":"C中编码问题","date":"2017-07-17T06:40:31.000Z","updated":"2017-07-17T12:20:47.012Z","comments":true,"path":"2017/07/17/C中编码问题/","link":"","permalink":"http://yoursite.com/2017/07/17/C中编码问题/","excerpt":"","text":"C中编码问题编码介绍在代码中我们通常不可避免的出现一些中文，这个时候我们就要考虑到中文的编码格式，如果不注意可能会导致乱码或者信息失真等问题。我们常用的中文编码有GBK,gb2312,Unicode等等。具体详细的介绍看下面几篇文章： http://www.cnblogs.com/lizhenghn/p/3690406.html http://docs.linuxtone.org/ebooks/C&amp;CPP/c/apas03.html C语言编码转换在C语言中，如果需要讲编码进行转换，可以使用iconv系列函数。头文件以及常用函数: 12345678#include &lt;iconv.h&gt;typedef void* iconv_t;extern iconv_t iconv_open(const char* to_code, const char* from_code);extern size_t iconv(iconv_t cd, char** restrict inbuf, size_t* in_left_buf, char** restrict outbuf, size_t* out_left_buf);extern int iconv_close(iconv_t cd); iconv_open函数说明此函数说明将要进行哪两种编码的转换，并返回一个转化句柄。 参数说明 tocode:目标编码 fromcode : 原编码 iconv1extern size_t iconv(iconv_t cd, char** restrict inbuf, size_t* in_left_buf, char** restrict outbuf, size_t* out_left_buf); 函数说明此函数用于从inbuf中读取数据并将转换到指定编码的的数据输出到outbuf中，若转换成功，则输出本次转化的字节数，否则返回sizeof_t(-1) 参数说明 cd : 转换描述符,由iconv_open获得 inbuf:输入缓冲区 in_left_buf :输入缓冲区还未转换的字符数 outbuf : 输出缓冲区 out_len_buf:输出缓冲区的剩余空间. iconv_close1extern int iconv_close(iconv_t cd); 用于关闭iconv_open打开的文件描述符 举例转换函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;iconv.h&gt;#include &lt;cstring&gt;#include &lt;errno.h&gt;using namespace std;string convertCode(const string&amp; p_str, const char* from, const char* to) &#123; char * sin, * sout; int lenin, lenout, ret; const int BUF_LEN = 10240; char bufOut[BUF_LEN]; string result(\"\"); memset(bufOut, 0x0, sizeof(bufOut)); iconv_t cd; if ((cd = iconv_open(to, from)) == (iconv_t)(-1)) &#123; std::cout &lt;&lt; \"open iconv error\" &lt;&lt; std::endl; return \"\"; &#125; lenin = p_str.length(); lenout = BUF_LEN; sin = (char*)p_str.c_str(); sout = bufOut;// std::cout &lt;&lt; sin &lt;&lt; std::endl; //std::cout &lt;&lt; lenin &lt;&lt; std::endl; //std::cout &lt;&lt; lenout &lt;&lt; std::endl; ret = iconv(cd, &amp;sin, static_cast&lt;size_t * &gt;(&amp;lenin), &amp;sout, static_cast&lt;size_t * &gt;(&amp;lenout)); //errno:84:Invalid or incomplate multibyte or wide character if (-1 == ret) &#123; std::cout &lt;&lt; strerror(errno) &lt;&lt; std::endl; if (errno != 84) &#123; return \"\"; &#125; &#125; std::cout &lt;&lt; \"bufout:\" &lt;&lt; bufOut &lt;&lt; std::endl; std::cout &lt;&lt; \"bufout end\" &lt;&lt; std::endl; iconv_close(cd); result.assign(bufOut, BUF_LEN - lenout); return result;&#125;int main() &#123; string s = \"哈哈\"; std::cout &lt;&lt; s.length() &lt;&lt; std::endl; s = convertCode(s, \"gbk\", \"utf-8//IGNORE\"); //std::cout &lt;&lt; s &lt;&lt; std::endl; std::cout &lt;&lt; s.length() &lt;&lt; std::endl;&#125; iconv函数出现段错误的原因使用iconv函数进行转换的时候可能会出现段错误，这里出现这个错误的主要原因是注意看iconv函数的函数原型:1extern size_t iconv(iconv_t cd, char** restrict inbuf, size_t* in_left_buf, char** restrict outbuf, size_t* out_left_buf); 长度为size_t的指针，int指针转换为size_t指针在一些系统的转换过程会出现问题，导致长度出现错误，内存越界，出现段错误。错误信息如下： 12345Program received signal SIGSEGV, Segmentation fault.from_gbk (irreversible=0x7fffffffb188, outend=0x61d7c0 &quot;&quot;, outptrp=&lt;synthetic pointer&gt;, inend=0xa7ffffffdb76 &lt;error: Cannot access memory at address 0xa7ffffffdb76&gt;, inptrp=0x7fffffffb2e8, step_data=0x6157d0, step=0x615030) at ../iconv/loop.c:325325 ../iconv/loop.c: No such file or directory. size_t与int类型size_t类型是在stddef.h文件中定义。size_t的类型与操作系统相关，在32位架构中被普遍定义为:1typedef unsigned int size_t; 在64为机器中被定义为:1typedef unsigned long size_t; int类型在32和64为机器上的长度都是4位，long在32位机器为4位，在64位机器为8位。所以在64为机器上,size_t和int指针转换的过程中一定会出现问题，在32为系统中的正整数指针不会指针，但是负整数也会出现问题。","raw":null,"content":null,"categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"编码","slug":"编码","permalink":"http://yoursite.com/tags/编码/"}]},{"title":"C++中find_if查找vector中的特定struct以及值域查询","slug":"C++中find_if查找vector中的特定struct以及值域查询","date":"2017-07-15T09:47:20.000Z","updated":"2017-07-15T10:30:01.726Z","comments":true,"path":"2017/07/15/C++中find_if查找vector中的特定struct以及值域查询/","link":"","permalink":"http://yoursite.com/2017/07/15/C++中find_if查找vector中的特定struct以及值域查询/","excerpt":"","text":"C++中find_if查找vector中的特定struct以及值域查询由于struct不是C++中的内置类型所以不能用std::find直接查找，而且find函数不能满足值域的查询。这个时候需要使用find_if来进行查询。 find_if函数find_if是一个模板函数，函数原型及函数定义：12345template &lt;class InputIterator, class Predicate&gt;InputIterator find_if(InputIterator first, InputIterator end, Predicate pred) &#123; while (first != last &amp;&amp; !pred(*first)) ++first; return first;&#125; 函数参数 first : 起始迭代器 end : 结束迭代器 pred : 用于比较数值的函数或者函数对象(仿函数)。遍历条件即为pred()为真. 函数返回值若有满足pred条件的元素，返回该元素的迭代器，否则返回end. 函数说明该函数最重要的环节是pred，它的核心环节是重载()运算符，因为每个容器迭代器的*运算符得到的结果都是该容器的value_type的值，所以改重载函数的参数类型是value_type的引用类型。 find_if函数应用在struct的vector中查找特定的对象.特别注意的是：仿函数的参数类型是值的const引用，但是finder的构造参数是实际要比较的值的类型，在使用过程中,向构造函数中传的值是要比较的值。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct book&#123; int m_iID; string m_strName; book(int t_id, string t_name):m_iID(t_id), m_strName(t_name) &#123;&#125;&#125;;struct book_finder&#123; int m_iID; book_finder(int t_id):m_iID(t_id) &#123;&#125; bool operator() (const book&amp; t) &#123;return t.m_iID == m_iID;&#125;&#125;;int main() &#123; vector&lt;book&gt; bookVc; book book1(0, \"书0\"); book book2(1, \"书1\"); book book3(2, \"书2\"); book book4(3, \"书3\"); bookVc.push_back(book1); bookVc.push_back(book2); bookVc.push_back(book3); bookVc.push_back(book4); book target(1, \"书\"); if (std::find_if(bookVc.begin(), bookVc.end(), book_finder(target.m_iID)) != bookVc.end()) &#123; cout &lt;&lt; \"存在1\" &lt;&lt; std::endl; &#125; else &#123; cout &lt;&lt; \"不存在1\" &lt;&lt; std::endl; &#125; target.m_iID = 10; if (std::find_if(bookVc.begin(), bookVc.end(), book_finder(target.m_iID)) != bookVc.end()) &#123; cout &lt;&lt; \"存在10\" &lt;&lt; std::endl; &#125; else &#123; cout &lt;&lt; \"不存在10\" &lt;&lt; std::endl; &#125;&#125;","raw":null,"content":null,"categories":[{"name":"C++ problems","slug":"C-problems","permalink":"http://yoursite.com/categories/C-problems/"}],"tags":[{"name":"vector","slug":"vector","permalink":"http://yoursite.com/tags/vector/"},{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"struct","slug":"struct","permalink":"http://yoursite.com/tags/struct/"}]},{"title":"rapidjson创建型","slug":"rapidjson创建型","date":"2017-06-21T12:35:00.000Z","updated":"2017-07-03T02:44:44.112Z","comments":true,"path":"2017/06/21/rapidjson创建型/","link":"","permalink":"http://yoursite.com/2017/06/21/rapidjson创建型/","excerpt":"","text":"rapidjson创建型12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &quot;rapidjson/document.h&quot;#include &quot;rapidjson/stringbuffer.h&quot;#include &quot;rapidjson/writer.h&quot;#include &lt;string&gt;using namespace std;using namespace rapidjson;int main() &#123; Document d; d.SetObject(); std::string s = &quot;123&quot;; rapidjson::Document::AllocatorType&amp; allocator = d.GetAllocator(); //生成含有数组的document，注意在rapidjson中所有的数据都是一个Value，数组的本质也是一个Array; rapidjson::Value arr(rapidjson::kArrayType); arr.PushBack(&quot;1&quot;, allocator); arr.PushBack(&quot;2&quot;, allocator); arr.PushBack(rapidjson::StringRef(s.c_str()), allocator); //生成数组中包含有多个obj的数组 rapidjson::Value o1; o1.SetObject(); o1.AddMember(&quot;o1&quot;, 1, allocator); arr.PushBack(o1, allocator); rapidjson::Value o2; o2.SetObject(); o2.AddMember(&quot;o2&quot;, 2, allocator); arr.PushBack(o2, allocator); d.AddMember(&quot;arr&quot;, arr, allocator); rapidjson::StringBuffer buffer; rapidjson::Writer&lt;StringBuffer&gt; writer(buffer); d.Accept(writer); std::cout &lt;&lt; buffer.GetString() &lt;&lt; std::endl; return 0;&#125;","raw":null,"content":null,"categories":[{"name":"rapidjson学习","slug":"rapidjson学习","permalink":"http://yoursite.com/categories/rapidjson学习/"}],"tags":[{"name":"rapidjson","slug":"rapidjson","permalink":"http://yoursite.com/tags/rapidjson/"},{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"}]},{"title":"Unix网络编程之socket异步编程","slug":"Unix网络编程之socket异步编程","date":"2017-06-15T01:48:43.000Z","updated":"2017-06-15T03:20:13.063Z","comments":true,"path":"2017/06/15/Unix网络编程之socket异步编程/","link":"","permalink":"http://yoursite.com/2017/06/15/Unix网络编程之socket异步编程/","excerpt":"","text":"Unix网络编程之socket异步编程ioctl我们常用ioctlsocket的FIONBIO模式对socket进行设置是否启用异步。1int ioctlsocket(int sockfd, long cmd, unsigned long* args); ioctlsocket函数的作用是获取与套接字sockfd相关的操作参数，可用于任何状态的任一套接字，与具体的协议无关. 参数说明 sockfd : 待操作的socket描述符 cmd : 对sockfd的做操类型,包括以下几种 FIONBIO : 允许或者禁止套接字sockfd的费阻塞模式，若args为1，则是允许非阻塞模式；若args为0，禁止非阻塞模式。 FIONREAD : 确定套接字sockfd自动读入设为数量，arg存储ioctlsocket的返回值.若sockfd是SOCKET_STREAM类型，则FIONREAD返回一次recv所接受的所有的数据量，这通常与套接字中排队的数据总量相同。如果sockfd是SOC_DGRAM类型,则FIONREAD返回套接字上排队的第一个数据报的大小。 SIOCATMARK : 确定是否所有的带外数据都已经被读入，这个类型只适用于SOCK_STREAM套接字接口。 args : 指示参数","raw":null,"content":null,"categories":[{"name":"Unix网络编程","slug":"Unix网络编程","permalink":"http://yoursite.com/categories/Unix网络编程/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"},{"name":"ioctlsocket","slug":"ioctlsocket","permalink":"http://yoursite.com/tags/ioctlsocket/"}]},{"title":"Unix网络编程之读写相关函数","slug":"Unix网络编程之读写相关函数","date":"2017-06-14T13:37:41.000Z","updated":"2017-06-14T13:48:18.796Z","comments":true,"path":"2017/06/14/Unix网络编程之读写相关函数/","link":"","permalink":"http://yoursite.com/2017/06/14/Unix网络编程之读写相关函数/","excerpt":"","text":"Unix网络编程之读写相关函数socket编程中常用的输入输出函数(读写函数)总共有五对,它们都是默认阻塞的，这就意味着当发出一个不能立即完成的套接字调用的时候，其进程将被投入睡眠，等待相应的进程操作完成，函数才返回继续往下执行。常用的函数如下： read, write readv, writev recv, send recvfrom, sendto recvmsg, sendmsg read/write函数read和write函数的详细用法已经在Unix文件IO中已经讲解，在socket编程中的使用方法与文件IO使用方法相同。","raw":null,"content":null,"categories":[{"name":"Unix网络编程","slug":"Unix网络编程","permalink":"http://yoursite.com/categories/Unix网络编程/"}],"tags":[{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"},{"name":"write","slug":"write","permalink":"http://yoursite.com/tags/write/"},{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"},{"name":"readv","slug":"readv","permalink":"http://yoursite.com/tags/readv/"},{"name":"writev","slug":"writev","permalink":"http://yoursite.com/tags/writev/"},{"name":"recv","slug":"recv","permalink":"http://yoursite.com/tags/recv/"},{"name":"send","slug":"send","permalink":"http://yoursite.com/tags/send/"},{"name":"recvfrom","slug":"recvfrom","permalink":"http://yoursite.com/tags/recvfrom/"},{"name":"sendto","slug":"sendto","permalink":"http://yoursite.com/tags/sendto/"},{"name":"recvmsg","slug":"recvmsg","permalink":"http://yoursite.com/tags/recvmsg/"},{"name":"senfmsg","slug":"senfmsg","permalink":"http://yoursite.com/tags/senfmsg/"}]},{"title":"Unix网络编程之基础函数(一)","slug":"Unix网络编程之基础函数(一)","date":"2017-06-13T02:17:56.000Z","updated":"2017-06-14T13:15:42.279Z","comments":true,"path":"2017/06/13/Unix网络编程之基础函数(一)/","link":"","permalink":"http://yoursite.com/2017/06/13/Unix网络编程之基础函数(一)/","excerpt":"","text":"Unix网络编程之基础函数(一)TCP客户端与服务器之间交互过程在程序实现上的体现如下图所示,注意思考这个过程中TCP状态的变化(参考TCP状态转换图)： 服务器首先调用socket函数创建socket，通过bind函数将socket与主机地址及端口绑定，然后调用listen函数对主机端口进行监听，然后调用accept函数接收客户端发来的请求，若没有客户端请求，服务端将阻塞在此。客户端建立socket，然后调用connect函数与服务器三次握手建立连接，发送请求给服务器，服务器接收到请求之后对其进行处理并将处理结果返回给客户端，这个过程一直持续下去，一直到客户端与服务器断开连接，服务器接下来将关闭连接或继续等待下一个客户端的连接。 socket函数为了执行网络IO,无论是客户端还是服务器，一个进程首先要做的事情就是调用socket函数创建一个socket，并指定socket的协议族，类型以及协议。 函数原型123#include &lt;sys/socket.h&gt;int socket(int family, int type, int protocol); 参数说明 family : 协议族，对应于sockaddr_in中的sin_family，IPv4协议时值为AF_INET. type : 套接字类型，套接字类型有多种，TCP一般使用SOCK_STREAM,UDP使用SOCK_DGRAM SOCK_STREAM : 字节流套接字，是一种有序可靠双向的面向连接字节流的套接字 SOCK_DGRAM : 数据报套接字,是一种长度固定,无连接的不可靠的套接字。 SOCK_SEQPACKET : 有序分组套接字，是一种长度固定，有序，可靠的面向连接的有序分组套接字。 SOCK_RAW : 原始套接字 protocal : 链接层传输协议，包括TCP,UDP,SCTP传输协议 IPPROTO_TCP : TCP传输协议 IPPROTO_UDP : UDP传输协议 IPPROTO_SCTP : SCTP传输协议 一般情况下，我们在使用socket函数的时候，可以只指定前两个参数，将第三个参数设为0，这个时候socket会将protocol设置为默认值，如当family=AF_INET,type=SOCK_STREAM时，这个时候默认的协议为IPv4 TCP协议。但是，注意有些组合是不可用的，组合如下： AF_TNET AF_INET6 AF_LOCAL AF_ROUTE AF_KEY SOCK_STREAM TCP/SCTP TCP/SCTP 是 SOCK_DGRAM UDP UDP 是 SOCK_SEQPACKET SCTP SCTP 是 SOCK_RAW IPv4 IPv6 是 是 返回值说明socket函数与open函数类似，若成功，返回一个较小的非负整数,称为套接字描述符，若失败返回-1; connect函数TCP客户端通过connect函数来与服务器建立连接,注意客户在调用connect函数之前不必调用bind函数将sockfd与本机的IP端口绑定，因为如果需要的话，内核会确定源IP地址，并选择一个可用的临时端口作为端口号。 客户端调用connect函数的时候会激发三次握手连接建立。而且只在连接建立成功或失败时返回，否则会一直阻塞在connect函数处。 connect函数出错的情况包括以下几种： 若TCP在调用connect之后没有接收到syn分节，则返回ETIMEOUT错误。这种情况通常发生在目的主机不存在情况下。这时客户端会隔一段时间发送一次请求，若等待时间超过一定时间(这个过程客户端被阻塞)，返回ETIMEOUT错误。 若T客户端收到RST分节(复位)，则返回ECONNREFUSED错误，这种情况发生在目的主机存在，但是主机上没有进程监听指定端口。 若客户端发送的分节在某个路由器上返回destination unreachable，此时返回EHOSTUNREACH，这种情况发生在目的主机和端口存在，但是中间路由出现问题。 从TCP状态图可以看出，connect函数可以使得socket状态从closed转移到SYN_SENT状态,若成功，转换到ESTABLISHED状态。若套接字失败不可用，必须关闭。然后重新调用socket函数。 函数原型1int connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen); 参数说明 sockfd : 此参数为调用sock函数的返回值，即套接字描述符 servaddr : 指向服务器套接字地址结构的指针,套接字地址结构中必须含有Ip地址以及端口。 addrlen : 上述套接字的长度。 返回值说明连接失败，返回-1，并将错误码写入errno中;若连接成功，则返回0. bind函数在建立socket之后，我们通常会将socket与一个套接字绑定，即将一个协议地址赋予给socket，bind函数的作用就是将socket与socket地址绑定。socket协议地址是32位的IPv4地址或128位的IPv6和16位的TCP或UDP端口的组合。 一般情况下，客户端一般不调用bind函数进行绑定socket地址(可调用),当其调用connect函数的时候，内核会获取主机的IP作为源IP，并选择一个可用的端口作为源端口，当然，客户端可以调用bind为socket指定源端口和IP；服务端一般要调用bind端口，为socket指定监听的端口和IP，因为一般情况下服务器是对外提供服务的，如http的80端口,https的443端口等等。 注意：socket绑定的端口必须是进程所在主机上的网络接口之一，不能是其他主机的IP，否则会出现“Cannot assign requested address”,也不能绑定已经在使用的端口。 函数原型123#include &lt;sys/socket.h&gt;//函数参数与connect函数中的参数及意义相同。int bind(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen); bind函数可以只绑定IP，只绑定端口，也可以两者都绑定，也可以两者都不绑定，具体的制定规则如下： IP地址 端口 说明 统配地址(INAAR_ANY) 0 内核选择IP地址和端口 统配地址(INADDR_ANY) 非0 内核选择IP地址，进程指定地址 本地IP地址 0 进程指定IP,内核选择端口 本地IP地址 0 进程指定IP和端口 一般情况下，INADDR_ANY的值为0,将其转化为s_addr的时候使用htonl函数(将主机字节序转化为网络字节序)，若是IPv6则不能使用htonl，因为IPv6的地址是一个128位的地址。需要使用另一种方式，具体参考《Unix网络编程卷一第三版》83页。 若设置为内核选定端口，则必须调用getsockname函数获取系统选定的端口。从bind函数返回的一个常见的错误是:EADDRINUSE : address already in use; listen函数函数原型12#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog); listen函数仅由TCP服务器调用,一般在调用socket和bind函数之后调用 .当进程调用socket函数创建套接字之后，这个套接字被默认假设为主动套接字，(主动套接字的意思是将会调用connect去和TCP服务器建立连接)。listen函数主要有以下两个作用： 将一个未连接的套接字转化为主动套接字，指示内核应该接收指向该套接字的连接请求。调用listen成功之后TCP从CLOSED状态转变为LISTEN状态。 指定内核应该为相应套接字排队的最大连接数。即backlog指定，下面两个队列的和不能超过backlog.若查过backlog还有连接请求，服务器将直接发送RST复位拒绝连接。一般不要吧backlog值设为0，因为不同系统实现对0的解释不同;一般讲backlog的值设为5,因为这是4.2BSD支持的最大值。 内核为任何一个给定的监听套接字维护两个队列: 未完成连接队列 ：当服务器收到客户端发来的请求之后，数据还没有处理完，此时会进入SYN_RECV状态，这个时候将进入未完成连接队列，也叫SYN队列 已完成连接队列:服务器与客户端之间建立连接之后，进入ESTABLISHED状态，此时进入已完成连接队列，也叫accept队列。 accept函数accept函数的作用是从已经完成连接的队列头返回下一个已经完成的连接，如果已完成的连接为空，则进程进入睡眠状态(阻塞)。 函数原型12#include &lt;sys/socket.h&gt;int accept(int servsockfd, struct sockaddr* cliaddr, socklen_t* addr_len); 参数说明 servsockfd : 监听的套接字描述符 cliaddr : 客户端的sockaddr，如果对客户端的来源不感兴趣，可以将其设置为NULL; addr_len : aliaddr的字节数。即客户端sockaddr的地址长度。 返回值说明若出错返回-1;如果accept成功，返回一个新的socket描述符。其代表与所返回的客户端之间的TCP连接，它是一个连接套接字,之后服务端接收和发送数据都将使用这个描述符进行操作. Invalid argument常见原因在accept的时候,我们常会遇到Invalid argument的错误，出现这个错误的原因有很多，主要是在accept之前的准备工作出了问题。 socket创建不成功，在socket函数后检查一下errno值 绑定socket地址不成功，检查一下返回值，同时检查一下errno 没有listen，或者listen出问题。 以上三步有一步出问题或者漏掉一步都有可能出现Invalid argument错误。 close函数我们知道，关闭文件描述符我可使用close函数，同样的close函数也能用来关闭socket文件描述符。12#include &lt;unistd.h&gt;int close(int sockfd); 通常情况下,close一个TCP套接字只是将该socket描述符标记为不可用，这个时候其将不能作为read和write的第一个参数进行数据的发送和接收,然而TCP尝试发送已经排队等待的所有需要发送到对端的数据，发送完毕之后将执行正常的TCP连接终止流程关闭TCP连接.","raw":null,"content":null,"categories":[{"name":"Unix网络编程","slug":"Unix网络编程","permalink":"http://yoursite.com/categories/Unix网络编程/"}],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}]},{"title":"Unix网络编程之主机字节序与网络字节序","slug":"Unix网络编程之主机字节序与网络字节序","date":"2017-06-12T11:20:46.000Z","updated":"2017-06-12T11:33:25.934Z","comments":true,"path":"2017/06/12/Unix网络编程之主机字节序与网络字节序/","link":"","permalink":"http://yoursite.com/2017/06/12/Unix网络编程之主机字节序与网络字节序/","excerpt":"","text":"Unix网络编程之主机字节序与网络字节序在各种计算机体系中，对于字节，字等的存储机制有所不同，但是在网络通信过程中，如果双方交流的信息存储结构不一致，则会导致通信失败的结果。当前计算机中通常采用的字节存储机制主要有两种:大端规则与小端规则。网络通信的过程中的存储机制统一为大端规则。 字节序 参考：http://www.cppblog.com/tx7do/archive/2015/12/14/71276.html","raw":null,"content":null,"categories":[{"name":"Unix网络编程","slug":"Unix网络编程","permalink":"http://yoursite.com/categories/Unix网络编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"},{"name":"主机字节序","slug":"主机字节序","permalink":"http://yoursite.com/tags/主机字节序/"},{"name":"网络字节序","slug":"网络字节序","permalink":"http://yoursite.com/tags/网络字节序/"}]},{"title":"Unix网络编程基础之套接字结构","slug":"Unix网络编程基础之套接字结构","date":"2017-06-12T08:57:47.000Z","updated":"2017-06-13T02:14:26.431Z","comments":true,"path":"2017/06/12/Unix网络编程基础之套接字结构/","link":"","permalink":"http://yoursite.com/2017/06/12/Unix网络编程基础之套接字结构/","excerpt":"","text":"Unix网络编程基础之套接字结构大多数的套接字函数都使用到了套接字地址，它们以套接字地址的指针作为参数。每个协议族都定义了自己的套接字地址结构，这些套接字地址结构均以sockaddr_开头，以协议族唯一的后缀结尾。 IPv4套接字地址结构IPv4的套接字以sockaddr_in命名，其具体定义如下：1234567891011121314#include &lt;netinet/in.h&gt;struct in_addr &#123; in_addr_t s_addr;&#125;;struct sockaddr_in &#123; uint8 sin_len; //套接字的长度,sizeof(struct sockaddr_in) sa_family_t sin_family; //协议族 in_port_t sin_port; //套接字端口 struct in_addr sin_addr; //套接字地址 char sin_zero[8]; //保留位&#125; sin_len : 套接字的长度字段，类型为uint8_t,sizeof(struct sockaddr_in),不是所有的系统都支持。长度字段简化了可变长度的套接字的处理。在使用过程中无需设置和检查它，除非涉及路由套接字。 sin_family : 协议族，IPv4的协议族为AF_INET.类型为无符号整形，其长度受系统的影响。若sockaddr_in中含有sin_len字段，其大小为16位，若含有长度字段，其大小为8位。 sin_port : 套接字端口, 一般为uint16_t类型。 sin_addr : 套接字Ip，其类型为in_addr，in_addr中的s_addr类型为uint32_t. sin_zero : 不常用，若需要在套接字中加入额外字段，使用到此字段，若不使用将其置为0，一般使用sockaddr_in首先将整个结构置0。 注意：套接字地址结构仅在本机上使用，虽然结构中的某些字段用在不同主机之间的通信，但是结构体本身不在主机之间传递。 协议族参数说明网络通信过程中有不同的协议族，通常我们在socket地址的sin_family中指出当前通信使用的协议族，不同协议族对应不同的参数，其对应参数如下所示： sin_family 协议说明 AF_INET IPv4协议 AF_INET6 IPv6协议 AF_LOCAL Unix域协议 AF_ROUTE 路由套接字协议 AF_KEY 密钥套接字 通用套接字地址结构套接字函数以套接字地址结构指针作为参数的过程中，由于在C中没有继承的机制，这个时候向套接字函数传递参数的时候，由于不同协议的套接字地址不同，会出现问题。这个时候有一种解决办法就是传递void*指针给socket函数，但是void空指针的出现在socket函数之后，所以这个方案不可行。这个时候的解决方案是 定义一个通用的套接字函数，socket函数的参数为通用套接字地址的指针，传递参数的时候我们将特定的套接字指针强制转换为通用套接字地址指针。 如bind函数的函数原型为:1int bind(int, struct sockaddr*, socklen_t); 通用套接字地址的定义如下： 12345struct sockaddr &#123; uint8_t sa_len; sa_family_t sa_family; char sa_data[14];&#125;; Ubuntu16.04中sockaddr_in的定义Ubuntu16.04中sockaddr_in的定义在/usr/include/netinet/in.h，注意其不支持sin_len字段，为了保持与通用套接字字符串兼容，其保留字符串的长度直接用通用套接字的大小减去其他字段。 123456789101112struct sockaddr_in &#123; __SOCKADDR_COMMON (sin_); in_port_t sin_port; // Port number. struct in_addr sin_addr; // Internet address. //Pad to size of struct sockaddr unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)]; &#125;;","raw":null,"content":null,"categories":[{"name":"Unix网络编程","slug":"Unix网络编程","permalink":"http://yoursite.com/categories/Unix网络编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"},{"name":"socket","slug":"socket","permalink":"http://yoursite.com/tags/socket/"}]},{"title":"Unix时间相关函数总结.md","slug":"Unix时间相关函数总结-md","date":"2017-06-11T12:09:08.000Z","updated":"2017-07-10T08:02:30.703Z","comments":true,"path":"2017/06/11/Unix时间相关函数总结-md/","link":"","permalink":"http://yoursite.com/2017/06/11/Unix时间相关函数总结-md/","excerpt":"","text":"Unix时间相关函数总结在进行Unix编程的过程中，我们不可避免的会遇到需要时间相关的操作，如文件的创建修改时间，数据库中字段插入或更新的时间。 Unix时间相关的类型 time_t struct timeb struct timeval struct timespec struct tm clock_t time_ttime_t是一个有符号的整数类型，表示的含义是从1970年1月1日到某一个时间点的秒数。若为32位系统，由int类型的范围可以推算出，time_t可以表示的时间范围是1901-12-13 20:45:52到2038-０1-19 03:14:07。 struct ime_btime_b结构体是一个精确到毫秒的结构体，其有四个成员，成员列表如下：123456struct timeb&#123; time_t time; unsigned short millitm; short timezone; //时区标志 short dstflag; //夏令时标志&#125;; 可以通过下列函数获取当前的timeb:1int ftime(struct timeb* tb); struct timevaltimeval是一个精确到微妙的结构体。其中主要包含两个成员：1234struct timeval&#123; time_t tv_sec; suseconds tv_usec;&#125;; 此值通常通过gettimeofday获取12#include &lt;sys/time.h&gt;int gettimeofday(struct timeval* tv, struct timezone* tz); //timezone参数已废弃，一般设为NULL， struct timespectimespec是一个精确到纳秒的结构体。其主要包含两个成员1234struct timespec&#123; time_t tv_sec; //秒 long tv_nsec; //纳秒&#125; 此结构体一般通过下列函数获取：12#include &lt;sys/time.h&gt;long clock_gettime(clockid_t which_clock, struct timespec* tp); 上述参数中which_clock用于标识那种时钟时间，可选值如下 CLOCK_REALTIME : 系统当前时间,1970-1-1开始 CLOCK_MONOTONIC : 系统的启动时间，不能被设置 CLOCK_PROCESS_CPUTIME_ID : 进程运行时间 CLOCK_THREAD_CPUITME_ID : 线程运行时间 CLOCK_REALTIME_HR : CLOCK_REALTIME的高精度版本 CLOCK_MONOTONIC_HR : CLOCK_MONOTONIC的高精度版本 struct tmstruct tm被称为一种分解时间，日期和时间被分解成多个独立字段。其形式如下：1234567891011struct tm &#123; int tm_sec; //秒 (0-60) int tm_min; //分 (0-59) int tm_hour; //时 (0-23) int tm_mday; //日 (1-31) int tm_mon; //月 (0-11) int tm_year; //年 (1900-) int tm_wday; //一周中的周几(周日为0) int tm_yday; //一年中的第几天。(1月1号为0) int m_isdst; //DST大于0表示为夏令时时间。&#125; Unix时间相关函数Unix时间相关的函数除了上面已经提到的函数还包括以下函数 time(time_t timep) ctime gmtime localtime mktime asctime strftime strptime time函数原型12#include &lt;time.h&gt;time_t time(time_t* timep); time函数返回当前时间的时间戳，此时间戳为从1970年1月1日到当前时间的时间戳，此值不受时区和夏令时(DST)。此函数的返回值为当前的时间戳，函数参数为time_t指针，当前时间除了返回值之外，还将此时间放入timep中。所以使用time函数时我们将timep设置为NULL即可。 ctime函数原型12#include &lt;time.h&gt;char* ctime(const time_t* timep); 函数功能ctime函数的功能为将time_t转化为打印字符串格式。把一个指向time_t的指针timep传入函数ctime,将返回一个长度为26字节的字符串，包含\\0和换行符。ctime进行转换的时候，会考虑时区和夏令时，所以返回的时间字符串为当地时间。返回时间的格式如下：1Wed Jun 8 14:22:34 2011 特别注意返回的字符串是经由静态分配的，若多次调用此函数，之前获取的时间会受影响。SuSv3规定，调用ctime(),gmtime(),localtime()以及asctime()中的任意一个函数，都可能覆盖其他函数返回的结果。 静态分配的意思是这些函数返回的数据都是般存在同一个静态变量中，所以下一次的结果会覆盖上一次的数据。如果需要对之前的数据保存，此时需要将结果拷贝到自己分配的内存中。 ### gmtime和localtime 函数原型123#include &lt;time.h&gt;struct tm* gmtime(time_t* timep);struct tm* localtime(time* timep); 函数功能gmttime和localtime的作用是将time_t值转换为分解时间struct tm类型。他们的主要区别是gmtime转换为对应于UTC的分解时间，而localtime考虑时区和夏令时。 mktime函数原型12#include &lt;time.h&gt;time_t mktime(struct tm* timeptr); #### 函数功能mktime的作用是将一个本地时区的分解时间转化为time_t类型。需要注意的是，mktime可能改变timeptr所指的内容。若分解时间不符合要求，mktime将其自动转换为有效时间。如秒为61,此时会将其变成1并讲分加１。 asctime函数原型123#incude &lt;time.h&gt;char* asctime(const struct tm* timeptr); 函数功能asc的功能是将分解时间转化为打印时间，特别注意的是asctime转化的过程中不考虑时区和夏令时，返回的数据也是静态分配的。 strftime函数原型12#include &lt;time.h&gt;size_t strftime(char* outstr, size_t maxsize, const char* format, const struct tm* timeptr); 函数功能此函数的功能是将分解时间转换为打印时间，并可以指定打印时间的格式为format。不同于ctime和asctime，strftime结果不包含换行符。若返回的字符串超过了maxsize大小，函数返回0指示为转换错误。定义的格式中其格式化字符串可以参考预定义的格式。参考《Linux/Unix系统编程手册.上册》第158页。","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"timestap","slug":"timestap","permalink":"http://yoursite.com/tags/timestap/"},{"name":"分解时间","slug":"分解时间","permalink":"http://yoursite.com/tags/分解时间/"}]},{"title":"C语言宏定义相关","slug":"C语言宏定义相关","date":"2017-06-11T08:39:20.000Z","updated":"2017-06-11T08:53:17.656Z","comments":true,"path":"2017/06/11/C语言宏定义相关/","link":"","permalink":"http://yoursite.com/2017/06/11/C语言宏定义相关/","excerpt":"","text":"C语言宏定义相关C语言宏定义在代码编写中很常见，它常会带来一些很高的性能和很方便的写法，在看Linux源码中sockaddr_in的时候遇到宏定义中##。特地在此记录. 宏定义中##用法问题背景Linux中sockaddr_in的定义在文件/netinet/in.h文件中。具体如下：12345678910111213141516/* Structure describing an Internet socket address. */struct sockaddr_in &#123; __SOCKADDR_COMMON (sin_); in_port_t sin_port; // Port number. struct in_addr sin_addr; // Internet address. // Pad to size of struct sockaddr. unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)]; &#125;;#define __SOCKADDR_COMMON(sa_prefix)\\ sa_family_t sa_prefix##family 从上面可以看出，__SOCKADDR_COMMON的宏定义中出现了##的使用方法。那它在宏定义中的意思是什么呢？ ##详解##是一种分隔连接方式。它的作用是先分隔，然后进行强制连接。 在普通的宏定义中，预处理器一般吧空格解释为分段标志，然后进行相应的替换工作。但是这样做的结果是被替换的段之间会出现空格。如果我们不希望这些空格出现，可以使用##来代替空格。 如：12#define type1(type,name) type name_##type##_type#define type2(type,name) type name##_##type##_type 上述type1(int,c)将被替换为：int name_int_type上述type2(int,c)将被替换为：int c_int_type 故我们再回去看SOCKADDR_COMMON的宏定义. SOCKADDRCOMMON (sin);将被解释为sa_family_t sin_family;","raw":null,"content":null,"categories":[{"name":"C++ problems","slug":"C-problems","permalink":"http://yoursite.com/categories/C-problems/"}],"tags":[{"name":"宏定义","slug":"宏定义","permalink":"http://yoursite.com/tags/宏定义/"}]},{"title":"protobuffer中string和bytes类型","slug":"protoBuffer中string与byte类型区别","date":"2017-06-07T10:04:59.000Z","updated":"2017-06-07T10:33:18.528Z","comments":true,"path":"2017/06/07/protoBuffer中string与byte类型区别/","link":"","permalink":"http://yoursite.com/2017/06/07/protoBuffer中string与byte类型区别/","excerpt":"","text":"protobuffer中string和bytes类型从上一节protobuffer的介绍中我们知道字符串类型在protobuffer中有string和bytes两种类型，那这两种类型有什么区别呢,什么时候用string,什么时候用bytes。在C++中两种类型分别对应的是什么类型.下面将揭开迷雾 string与bytes区别按照经验我们知道bytes一般适用于存储二进制数据的，但在C++中,string既可以存储ASCII文本字符串，也能存储任意多个\\0的二进制序列，那两者的区别在哪里呢？ string类型（protobuffer中的string，与C++区别开）不能存储非法的UTF-8字符，如果遇到该字符，序列化的时候将会出错。 [libprotobuf ERROR google/protobuf/wire_format.cc:1091] String field ‘str’ contains invalid UTF-8 data when serializing a protocol buffer. Use the ‘bytes’ type if you intend to send raw bytes. ###出现上述错误的原因这里从ProtoBuf的源码进行分析。protoBuf在序列化的过程中，都会调用SerializeFieldWithCachedSizes这个函数。我们看一下序列化string和bytes在序列化过程中的区别。 对于string类型：1234567891011case FieldDescriptor::TYPE_STRING: &#123; string scratch; const string&amp; value = field-&gt;is_repeated() ? message_reflection-&gt;GetRepeatedStringReference( message, field, j, &amp;scratch) : message_reflection-&gt;GetStringReference(message, field, &amp;scratch); VerifyUTF8StringNamedField(value.data(), value.length(), SERIALIZE, field-&gt;name().c_str()); WireFormatLite::WriteString(field-&gt;number(), value, output); break;&#125; 对于bytes类型：123456789case FieldDescriptor::TYPE_BYTES: &#123; string scratch; const string&amp; value = field-&gt;is_repeated() ? message_reflection-&gt;GetRepeatedStringReference( message, field, j, &amp;scratch) : message_reflection-&gt;GetStringReference(message, field, &amp;scratch); WireFormatLite::WriteBytes(field-&gt;number(), value, output); break;&#125; 从上面可以看到，序列化string和bytes的区别主要在于:string类型序列化调用了VerifyUTF8StringNamedField函数检验string中是否有非法的UTF-8字符。其中VerifyUTF8StringNamedField实现如下：1234567891011121314151617181920212223242526void WireFormat::VerifyUTF8StringFallback(const char* data, int size, Operation op, const char* field_name) &#123; if (!IsStructurallyValidUTF8(data, size)) &#123; const char* operation_str = NULL; switch (op) &#123; case PARSE: operation_str = \"parsing\"; break; case SERIALIZE: operation_str = \"serializing\"; break; // no default case: have the compiler warn if a case is not covered. &#125; string quoted_field_name = \"\"; if (field_name != NULL) &#123; quoted_field_name = StringPrintf(\" '%s'\", field_name); &#125; // no space below to avoid double space when the field name is missing. GOOGLE_LOG(ERROR) &lt;&lt; \"String field\" &lt;&lt; quoted_field_name &lt;&lt; \" contains invalid \" &lt;&lt; \"UTF-8 data when \" &lt;&lt; operation_str &lt;&lt; \" a protocol \" &lt;&lt; \"buffer. Use the 'bytes' type if you intend to send raw \" &lt;&lt; \"bytes. \"; &#125;&#125; string和bytes类型在C++和Java中的区别protobuf类型在C++和java中的类型对应如下： 在C++中，string和bytes的实现都是std::string类型。 在Java中string和bytes类型的实现分别是String和ByteString。 为什么bytes类型可以描述string类型，还需要string呢？ 根据论坛上说的，string类型在Java中有较多的API可供使用，而bytes较少，所以能定义为string的尽量定义为string，如果字段值确定或者可能含有非法的utf-8编码，则使用bytes类型。","raw":null,"content":null,"categories":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://yoursite.com/categories/序列化与反序列化/"}],"tags":[{"name":"protobuffer","slug":"protobuffer","permalink":"http://yoursite.com/tags/protobuffer/"},{"name":"数据类型","slug":"数据类型","permalink":"http://yoursite.com/tags/数据类型/"}]},{"title":"Linux Regex正则表达式库","slug":"linux正则表达式库","date":"2017-06-04T09:08:00.000Z","updated":"2017-06-11T08:07:21.669Z","comments":true,"path":"2017/06/04/linux正则表达式库/","link":"","permalink":"http://yoursite.com/2017/06/04/linux正则表达式库/","excerpt":"","text":"Linux Regex正则表达式库标准的C/C++库不支持正则表达式。在Posix函数库中包含了正则表达式库。 ## 正则表达式匹配框架 标准的正则表达式匹配框架： 编译正则表达式. 匹配正则表达式. 释放正则表达式. 编译正则表达式12#include &lt;regex.h&gt;int Regcomp(regex_t* preg, const char* regex, int cflags); 参数说明 preg : 用来保存编译之后的结果 regex : 正则表达式字符串，表示被编译的正则表达式。 cflags : 编译控制参数 REG_EXTENDED : 使用扩展正则表达式模式 REG_ICASE : 对规则中字符串不区分大小写 REG_NOSUB : 只检查是否有符合规则的子串。 返回值编译成功返回0,否则返回非0 匹配正则表达式12345678910typedef struct &#123; regoff_t rm_so; regoff_t rm_eo;&#125; regmatch_t;int regexec(const regex_t* preg, const char* string, size_t nmatch, regmatch_t pmatch[], int eflags); 参数说明 preg : 上述编译之后的正则表达式regex_t指针。 string : 被匹配的字符串。 match : 被匹配的个数。告诉函数regexec最多可以把多少个匹配结果写入pmatch，一般为pmatch数组的长度。 pmatch : 匹配结果数组。 rm_so : 满足子串在string中的起始偏移量 rm_eo : 满足子串在string中的结束偏移量 eflags : 匹配的特性 REG_NOTBOL : 是否为第一行 REG_NOTEOL : 是否是最后一行 返回值0表示匹配成功，1表示REG_NOMATCH。 报错信息1size_t regerror(int errcode, const regex_t* preg, char* buf, size_t buffer_size); 参数说明 errcode : 来自regcomp和regexec的错误码。 preg : 编译后的正则表达式 buf : 缓冲区错误信息字符串 buffer_size : 缓冲区最大长度。 释放正则表达式12//释放reget_t指针，无返回值。void regfree(reget_t* preg); 实例123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;regex.h&gt;#include &lt;stdlib.h&gt;int main() &#123; regex_t preg; int iErr = 0; regmatch_t subs[256]; char acReg[] = \"[0-9a-zA-Z]+$\"; iErr = regcomp(&amp;preg, acReg, REG_EXTENDED); if (iErr) &#123; printf(\"compile reg error\\n\"); exit(1); &#125; iErr = regexec(&amp;preg, \"12345\", 256, subs, 0); if (REG_NOMATCH == iErr) &#123; printf(\"no match\\n\"); &#125; else &#123; printf(\"match\\n\"); &#125;&#125; 参考资料: http://crocodile.blog.51cto.com/2691566/967202 http://crocodile.blog.51cto.com/2691566/967202 http://crocodile.blog.51cto.com/2691566/967202","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"regex","slug":"regex","permalink":"http://yoursite.com/tags/regex/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"Unix标准IO库相关函数总结之读写流(二)","slug":"Unix标准IO库函数之读写流(二)","date":"2017-06-03T08:04:00.000Z","updated":"2017-06-04T11:34:24.842Z","comments":true,"path":"2017/06/03/Unix标准IO库函数之读写流(二)/","link":"","permalink":"http://yoursite.com/2017/06/03/Unix标准IO库函数之读写流(二)/","excerpt":"","text":"Unix标准IO库相关函数总结之读写流(二)读写流的三种方式一旦一个流被打开，则可以选择三种方式对其进行读写。 每次一个字符的IO，一次读或者写一个字符，如果流是带缓冲的,则标准IO函数处理所有的缓冲。 每次一行的IO。每次读写一行数据，可以使用fgets和fputs函数，但是要说明最大行的长度。 直接IO。通常使用fread和fwrite函数。 一个字符的IO输入函数通常使用以下三个函数进行一个字符的读。1234#include &lt;stdio.h&gt;int getc(FILE*);int fgetc(FILE*);int getchar(); 区别与联系这三个函数都用于一个字符的读取。其区别和联系如下： getchar()相当于getc(stdin)。即每次从标准输入流读入一个字符。实质上getc是宏。 getc和fgetc的区别是getc可以被实现为宏，而fgetc不能被实现为宏。这就意味着: getc的参数不能是具有副作用的表达式，因为它的值可能被计算多次。 fgetc是一个函数，可以获得其地址， 这就允许将fgetc作为参数传递给另一个函数。 调用fgetc时间比getc时间长，因为调用宏的时间更短。 有副作用的表达式是指：表达式的作用本质是用于计算的，原则上只返回一个计算结果，而不会改变表达式中的变量的值。这种不改变表达式中变量值的表达式叫做无副作用的表达式。如：x+y，y-z等。除此之外，若表达式中变量的值被改变则成为有副作用的表达式，如x++，y+=2; 由于在宏中宏可能出现在程序的很多位置，也就是表达式会被计算多次，这个时候若表达式有副作用就会GG。 返回值这三个函数的返回值都是int类型，这三个函数在返回下一个字符的时候，将其unsigned char类型转换为int。说明无符号的理由是，如果最高位为1，也不会使返回值为负。返回整形的理由是这样既可以返回所有的字符，也可以返回出错或到达文件为的指示值。 注意不管是到达文件为还是出错，这个时候三个函数的返回值都一样。为了区分这两种情况，常调用ferror或feof函数。 1234567#include &lt;stdio.h&gt;//用于判断流fp是否遇到读取错误，若读取错误，返回非零值，否则返回0。int ferror(FILE* fp);//用于判断流是否遇到文件结尾，若到达文件结尾，返回非零值，否则返回0.int feof(FILE* fp);void clearerr(FILE* fp); 在大多数的实现中，为每个流在FILE对象中维护了两个标志： 出错标志 文件结束标志 调用clearerr可以清除这两个标志。 压送字符到流中。从流中读取字符以后，可以使用ungetc将字符押送回流中，压回的字符又可以从流中读出，读出的顺序与压送的顺序相反。压送的字符不会被写到流中。12#include &lt;stdio.h&gt;int ungetc(int c, FILE* fp); ###输出函数输出函数为以下三个，与输入对应，区别与联系和输入函数相同。1234#include &lt;stdio.h&gt;int putc(int c, FILE* fp);int fputc(int c, FILE* fp);int putchar(int c); 实例12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; FILE* test = fopen(\"test.txt\", \"rw\"); char a; while ((a =getc(test)) != EOF) &#123; putc(a, stdout); putc('\\n', stdout); &#125; ungetc('1', test); ungetc('2', test); putc(getc(test), stdout); putc(getc(test), stdout); if (ferror(test)) &#123; printf(\"this is the read error\\n\"); &#125; if (feof(test)) &#123; printf(\"this is the eof\\n\"); &#125; fclose(test);&#125; 一行的IO输入标准IO中提供了一下两个函数进行一行的读取：123#include &lt;stdio.h&gt;char* fgets(char* restrict buf, int n, FILE* fp);char* gets(char* buf); 返回值若读取成功返回buf，若读取失败或者读取到文件结尾返回NULL. 区别与联系 对于fgets必须指定缓冲区的长度n.此函数一直读到下一个换行符为止，但是不能超过n-1个字符，读入的字符将被送入缓冲区，该缓冲区以null结尾。若改行包含换行符超过了n-1个字符，fgets只返回一个不完整的行。下一次读取的时候将继续从该行继续往下读。 gets函数用于从标准输入读取，但是gets不包含缓冲区的长度，所以在读取的时候可能会出现缓冲区溢出的情况。一般最好不要用gets函数. gets函数不将换行符存入缓冲区，而fgets将换行符存入缓冲区。 虽然ISO要求提供gets函数，但一般使用fgets不要使用gets函数。 输出对应的，标准IO提供了以下连个函数进行输出：123#include &lt;stdio.h&gt;int fputs(const char* restrict buf, FILE* restrict fp);int puts(const char* buf); 返回值成功返回非负值，失败返回EOF。 区别 fputs将一个以null结尾的字符串写到指定的流，但是null不写出，注意这不是每次输出一行，而取决于缓冲区中的内容。 puts将一个以null结尾的字符串写到指定的流，null不写出，但是在最后又添加了一个换行符。 一般情况下使用fgets和fputs，不适用gets和puts函数。 实例12345678910#include &lt;stdio.h&gt;int main() &#123; FILE* fp = fopen(\"test.txt\", \"rw\"); char buf[5]; while (fgets(buf, 5, fp)) &#123; printf(\"%s\", buf); &#125; return 0;&#125; 直接IO直接IO通常用于对二进制文件的读写，除此之外也可以对文本文件进行读写。其中对二进制文件的读写只能用直接IO的方式，因为二进制文件中可能含有null字符，会导致使用行或者字符获取时出现错误。直接IO进行读写的两个函数如下：1234#include &lt;stdio.h&gt;size_t fread(void* restrict ptr, size_t size, size_t nobj, FILE* fp);size_t fwrite(const void* restrict ptr, size_t size, size_t nobj, FILE* fp); 参数说明 ptr：为缓冲区指针 size：为一个结构体（类型）的大小 nobj：结构体的个数，若在fread中说明将要写入nobj个大小为size的结构体(类型)，若为fwrite，则为要从流fp中读取nobj个大小为size的数据 fp：文件指针 返回值返回值为实际读取或写入的对象的个数。对于fread，若文件出错或者读到文件结尾处都可以少于nobj，对于fwrite，若返回值小于nobj，则写入出错。 注意使用这两个函数存在一个问题就是，他们只能用于读写在同一个系统上已写的数据。若是通过网络挂载的文件则不可行。fread,fwrie可移植，而read,write不可移植。 格式化输出格式化输出有以下几个函数:1234567#include &lt;stdio.h&gt;int printf(const char* restrict format, ...);int fprintf(FILE* restrict fp, const char* restrict format, ...);int dprintf(int fd, const char* restrict format, ...);int sprintf(char* restrict buf, const char* restrict format, ...);int snprintf(char* restrict buf, size_t n, const char* restrict format, ...); 返回值前三个函数若输出成功，则返回输出字符的个数；若输出出错，则返回负值。 sprintf和snprintf若执行成功，则返回存入buf中的字符串的长度，否则返回负值。 函数说明 printf：向标准输出输出字符串。 fprintf:向标准文件流输fp出字符串。 dprintf：向文件描述符所指向的文件输出字符串。 sprintf:向缓冲区buf写入字符串。 snprintf:安全的向缓冲区buf写入字符串并指定缓冲区的最大长度.一般用此函数代替sprintf 格式化字符串format的格式12//其中[]表示可选部分，converter不可选%[flags][fldwidth][precision][lenmodifier]converter flags ： 是该输出的标志，其包含如下几个值： ‘ : 将整数按千位分组字符。 : 在字段内左对齐输出。 : 总是显示正负号 (空格) : 如果第一个字符不是正负号，则在其前面加上一个空格 : 指定另一种转换形式，如对于16进制，在前面加0x 0 ： 添加前导0进行填充 fldwidth : 说明最小字段宽度，若参数字段小于此宽度，多余位置用空格填充。 precision : 浮点数精度。前导为. 注意：fldwidth可以用*作为占位符，然后在后面对其进行指定。12345678#include &lt;stdio.h&gt;int main () &#123; // 10.10 printf(\"%10.2lf\", 10.1); //与上面写法等效。 printf(\"%*.*lf\", 10, 2, 10.1);&#125;","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"标准IO","slug":"标准IO","permalink":"http://yoursite.com/tags/标准IO/"},{"name":"FILE","slug":"FILE","permalink":"http://yoursite.com/tags/FILE/"},{"name":"fopen","slug":"fopen","permalink":"http://yoursite.com/tags/fopen/"},{"name":"freopen","slug":"freopen","permalink":"http://yoursite.com/tags/freopen/"}]},{"title":"Unix标准IO库相关函数总结之打开关闭流(一)","slug":"Unix标准IO库函数之打开关闭流(一)","date":"2017-05-31T12:04:00.000Z","updated":"2017-06-03T12:35:41.271Z","comments":true,"path":"2017/05/31/Unix标准IO库函数之打开关闭流(一)/","link":"","permalink":"http://yoursite.com/2017/05/31/Unix标准IO库函数之打开关闭流(一)/","excerpt":"","text":"Unix标准IO库相关函数总结之打开关闭流(一)Unix标准IO类型FILE在Unix相关的文件IO中几乎所有的函数都用到了文件描述符，文件描述符是打开一个文件时返回的一个可用的最小的文件描述标识。相应的在Unix标准IO相关的函数中，几乎每个函数都用到了FILE数据类型。本小结简单介绍一下FILE结构体的内容。 FILE实际上是一个struct的typedef,可以在/usr/include/stdio.h中找到它的定义为：1typedef _IO_FILE FILE; _IO_FILE_的定义在文件/usr/include/libio.h中，我们可以看到它的具体定义为：12345678910111213141516171819202122232425262728293031323334353637383940414243struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ #define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 从上面的struct中可以观察到FILE中是有文件描述符标志的，即为fileno参数。 打开标准IO流打开标准文件IO流的方法有如下三个：12345FILE* fopen(const char* restrict pathname, const char* restrict type);FILE* freopen(const char* restrict pathname, const char* restrict type, FILE* restrict fp);FILE* fdopen(int fd, const char* type); 上述三个函数区别以及使用场景说明: fopen的作用是打开一个指定文件路径的文件流。 freopen的作用是在一个指定的留上打开一个指定文件。如果当前流已经打开，则先关闭该流；若该流被重定向，则清除重定向。该函数常用于将一个指定的文件打开为一个默认的流，如若想使用printf函数将打印出来的内容输出到一个指定文件中，此时可以讲stdout重定向到指定的文件路径并指定打开模式。 fdopen的作用是将一个已经打开的文件描述符(该文件描述符可能是open,dup,socket等获取的)绑定到一个标准IO流上。此函数常用于由管道和网络通信通道函数返回的文件描述符，因为这些无法显式的指定文件。 参数说明： pathname: 文件路径，相对或绝对 type： 打开模式（r,w,a,r+,w+,a+以及所有后面加b） 打开模式说明： r : 读模式 w : 写模式，在写之前将原有文件内容全部清楚 a : 追加模式，offset为文件结尾 r+ : 读写模式(不删除文件原有内容，offset初始为文件开头)。如原有文件内容为”123456”,若以此模式打开文件并写入”abc”，此时写入之后的结果是”abc456”。 w+ : 读写模式(删除文件原有内容，offset为文件开头).如原有文件内容为”123456”,若以此模式打开文件并写入”abc”，此时写入之后的结果是”abc”。 a+ : 读写模式(offset为文件结尾).如原有文件内容为”123456”,若以此模式打开文件并写入”abc”，此时写入之后的结果是”123456abc”。 上述所有的模式后面都加上b表示对二进制文件的操作(rb,wb,ab,rb+,wb+,ab+)。 注意：对于fdopen函数由于文件已经由文件描述符打开，此时w模式时将不清除文件内容，追加模式不常见文件。 当以读写模式打开文件时候，将有一些限制。如果中间没有fflush,fseek,fsetpos以及rewind函数，标注输出之后不能直接进行输入;如果没有fseek,fsetpos或者rewind，或者一个输入没有到达文件尾，则输入操作之后不能跟输出操作。 关闭标准文件流一般情况下在关闭文件流之前通常先使用fflush刷新缓冲区防止数据丢失，关闭标准文件流使用的函数为:12#include &lt;stdio.h&gt;int fclose(FILE* fp);","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"标准IO","slug":"标准IO","permalink":"http://yoursite.com/tags/标准IO/"},{"name":"FILE","slug":"FILE","permalink":"http://yoursite.com/tags/FILE/"},{"name":"fopen","slug":"fopen","permalink":"http://yoursite.com/tags/fopen/"},{"name":"freopen","slug":"freopen","permalink":"http://yoursite.com/tags/freopen/"}]},{"title":"TCP状态转换图","slug":"Unix网络编程之TCP状态转换图","date":"2017-05-30T09:01:00.000Z","updated":"2017-06-13T13:27:23.398Z","comments":true,"path":"2017/05/30/Unix网络编程之TCP状态转换图/","link":"","permalink":"http://yoursite.com/2017/05/30/Unix网络编程之TCP状态转换图/","excerpt":"","text":"TCP状态转换图TCP涉及连接建立和连接终止的操作可以用状态转换图来说明。 TCP为一个连接定义了11中状态，并且规定了如何基于当前状态以及该状态下接收的分节(TCP报文段)从一个状态转换为另一个状态。其状态转换图如下所示： 具体转化过程和转换条件如上图所示。","raw":null,"content":null,"categories":[{"name":"Unix网络编程","slug":"Unix网络编程","permalink":"http://yoursite.com/categories/Unix网络编程/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"},{"name":"状态转换图","slug":"状态转换图","permalink":"http://yoursite.com/tags/状态转换图/"}]},{"title":"TCP的连接与建立","slug":"Unix网络编程之TCP的连接与建立过程","date":"2017-05-30T08:43:00.000Z","updated":"2017-06-13T13:27:47.414Z","comments":true,"path":"2017/05/30/Unix网络编程之TCP的连接与建立过程/","link":"","permalink":"http://yoursite.com/2017/05/30/Unix网络编程之TCP的连接与建立过程/","excerpt":"","text":"TCP的连接与建立最常用的传输层协议包括TCP和UDP两种，当然除此之外还有其他协议。UDP是一种既不面向连接有不可靠的传输层协议，而TCP是一种面向连接的可靠的传输层协议，为了达到这个目的，其在设计上使用了差错检测，重传，累计确认，定时器以及用于序号和确认好的字段等等。 TCP的特点TCP协议有以下特点： 面向连接：TCP的连接不是一条电路的或者虚电路，其连接状完全保留在两个端系统中。 可靠传输：TCP连接在传输消息的过程中保证了数据的可靠性，即保证数据在传输过程中不会丢失。 点对点：一条TCP连接只能连接两个端点。 全双工：如果一台主机上的进程A和另一台主机上的进程B建立了一条TCP连接，那么应用层数据就可以从A进程发送到B进程的同时，B进程也可以发送数据到A进程。 TCP报文段结构TCP报文段是由首部字段和一个数据字段组成的，数据字段中包含应用程序需要发送的数据。通常报文段中通过MSS(max segment size)来限制报文段数据字段的最大长度。报文段的结构如下： 说明： 源端口号与目的端口号指的是客户端和服务器端应用程序分别使用的端口号。用于识别主机上某一个特定的应用程序。 序号(seq)为TCP报文段中数据其实字节的序号。 确认号字段为(ACK)期待接收的下一个TCP报文段中数据的序号。 首部长度：首部长度表示当前TCP报文的首部的长度，一般为20，即可以看到表中报文首部的长度为20个字节。但是有时选项中有一些内容，这个时候首部长度大于20。 保留字：NULL 标志位：当某一些标志位被设置的时候表达一些特定的含义。 UGR标识报文段中存在着紧急数据。其中紧急数据的指针字段存放在后面16位的紧急数据指针中。 ACK标识确认号字段生效，一般连接建立之后的内个报文段的ACK被会被设置 PSH:不常用 SYN:连接建立时的客户端发送的服务端的第一个报文段和服务端响应客户端的报文段中被设置，标识当前为建立连接的过程。 FIN：与SYN类似，它是在断开连接时被设置。 互联网检验和：用于错误检测 紧急数据指针：即为上述当UGR标志被设置时标识紧急数据的指针。 选项：应用程序中自定义的首部的其他内容。 数据：应用程序发送的真正数据。 TCP建立连接（三次握手）TCP连接的过程可以简单描述为以下几个过程： 第一次握手：客户端发送请求连接报文段到服务器。此报文段中SYN被设置为1，同时随机或者指定一个起始序号x。此时客户端进入SYN_SENT（同步已发送）状态。 第二次握手：服务端收到请求报文段之后，向客户端发送确认报文段。确认报文段中ACK设置为1,SYN设置为1,确认号为x+1，同时为自己生成一个序号y。此时服务端进入SYN_RECV状态（同步接受到）。 第三次握手：客户端收到服务端的确认报文段之后，还要给服务端发送一个确认报文段。这个报文段中ACK被设置为1，确认号为y+1。此报文段可以携带数据。 经过上述三个步骤之后，TCP连接建立成功。客户端进入连接建立状态(ESTABLISHED)。然后就可以相互发送数据了。 为什么要经过三次握手？ 三次握手的目的是为了防止失效的报文段突然传送到服务端而出现问题。 上述已经失效的报文段是指：如果客户端在发送第一次连接请求的过程中，由于网络原因导致此报文段在某个网络节点滞留较长时间，这个时候TCP传输协议会视为此报文段已经丢失，于是重传。若此滞留的报文段在连接断开之后才到达服务器，这个时候就会出现问题。 若不是使用三次握手，服务器收到失效的报文段之后会建立连接，故之后无法释放TCP资源。导致资源浪费以致于长期会使服务器宕机。 三次握手过程中服务器和客户端程序的行为 服务器必须准备好接受外来的连接，调用socket(),bind()以及listen三个函数来完成，我们称为被动打开。 客户端通过调用connect发起主动打开连接，向服务器发送SYN(同步)包，connect函数阻塞。 服务器通过accept接收到客户端来送的TCP包，需要进行确认同事发送自己的SYN包，此时accept函数阻塞， 客户端收到服务器的SYN包，connect函数返回，并向服务器发送确认。服务器接收到确认之后accept函数返回。 TCP连接断开（四次挥手）由于TCP连接是全双工的，因此每个方向都必须单独的关闭，也就是发送方和接收方都需要FIN和ACK。客户端和服务器都可以首先主动发送连接终止的报文。当其中一方发送完数据之后即可向另一方发出连接断开的请求。当收到FIN意味着这一方向上没有数据流动，但是一方收到FIN之后仍然可以发送数据。四次挥手的具体过程如下： 此时TCP连接两端都处于ESTABLISHED的状态，客户端停止发送数据，并发出一个FIN报文段。首部FIN设置为1,序号seq=u(u为客户端传输数据的字后一个字节的序号加1)。客户端进入FIN_WAIT-1状态。 服务端回复确认报文段，确认号为ack=u+1，序号为seq=v(v为服务端传输数据的最后一个字节序号加1)，服务端进入close_wait状态。现在TCP连接处于半关闭状态，服务端如果继续发送数据，客户端依然接收。 客户端收到确认报文段,进入FIN_WAIT-2状态，服务端发送完数据之后，发出FIN报文段，FIN被置位1，确认号为ack=u+1，然后进入LAST_ACK状态。 客户端回复确认报文段。ACK=1，确认号为sck=w+1(w为半开半闭时收到的最后一个字节数据的编号)，序号为seq=u+1，然后进入TIME_WAIT状态。 一段时间(大约4分钟)之后等待状态结束，连接两端进入CLOSED状态。 参考链接： 计算机网络 自顶向下方法 Unix网络编程 http://blog.csdn.net/whuslei/article/details/6667471/ http://blog.csdn.net/wenqian1991/article/details/39667131 https://cnbin.github.io/blog/2015/07/01/chuan-shu-ceng-:tcp-xie-yi/","raw":null,"content":null,"categories":[{"name":"Unix网络编程","slug":"Unix网络编程","permalink":"http://yoursite.com/categories/Unix网络编程/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"},{"name":"三次握手","slug":"三次握手","permalink":"http://yoursite.com/tags/三次握手/"},{"name":"四次挥手","slug":"四次挥手","permalink":"http://yoursite.com/tags/四次挥手/"},{"name":"传输层协议","slug":"传输层协议","permalink":"http://yoursite.com/tags/传输层协议/"}]},{"title":"硬链接与软链接的区别","slug":"硬链接和软链接的区别","date":"2017-05-27T01:45:00.000Z","updated":"2017-05-27T01:46:50.555Z","comments":true,"path":"2017/05/27/硬链接和软链接的区别/","link":"","permalink":"http://yoursite.com/2017/05/27/硬链接和软链接的区别/","excerpt":"","text":"硬链接与软链接的区别https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/","raw":null,"content":null,"categories":[{"name":"Linux笔记","slug":"Linux笔记","permalink":"http://yoursite.com/categories/Linux笔记/"}],"tags":[{"name":"链接，硬链接，软连接","slug":"链接，硬链接，软连接","permalink":"http://yoursite.com/tags/链接，硬链接，软连接/"}]},{"title":"rapidjson Stream","slug":"rapidJsonStream","date":"2017-05-27T01:36:00.000Z","updated":"2017-05-27T01:40:41.516Z","comments":true,"path":"2017/05/27/rapidJsonStream/","link":"","permalink":"http://yoursite.com/2017/05/27/rapidJsonStream/","excerpt":"","text":"rapidjson Stream(待更新) 本系列文章以例子的方式进行呈现。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include \"rapidjson/rapidjson.h\"#include \"rapidjson/document.h\"#include \"rapidjson/stringbuffer.h\"#include \"rapidjson/writer.h\"#include \"rapidjson/filereadstream.h\"#include \"cstdio\"using namespace std;using namespace rapidjson;int main() &#123; const char json[] = \"[1, 2, 3]\"; StringStream s(json); Document document; document.ParseStream(s); for (int i = 0; i &lt; 3; i++) std::cout &lt;&lt; document[i].GetInt() &lt;&lt; std::endl; StringBuffer SB; Writer&lt;StringBuffer&gt; writer(SB); document.Accept(writer); std::cout &lt;&lt; SB.GetString() &lt;&lt; std::endl; FILE* fp = fopen(\"test.json\", \"rb\"); char readBuffer[65535]; FileReadStream is(fp, readBuffer, sizeof(readBuffer)); document.ParseStream(is); fclose(fp); for (Value::ConstMemberIterator it = document.MemberBegin(); it != document.MemberEnd(); it++) std::cout &lt;&lt; (it-&gt;name).GetString() &lt;&lt; std::endl;&#125;","raw":null,"content":null,"categories":[{"name":"rapidjson学习","slug":"rapidjson学习","permalink":"http://yoursite.com/categories/rapidjson学习/"}],"tags":[{"name":"rapidjson","slug":"rapidjson","permalink":"http://yoursite.com/tags/rapidjson/"},{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"},{"name":"stream","slug":"stream","permalink":"http://yoursite.com/tags/stream/"}]},{"title":"rapidjson Schema","slug":"rapidjsonSchema","date":"2017-05-27T01:35:00.000Z","updated":"2017-05-27T01:41:30.650Z","comments":true,"path":"2017/05/27/rapidjsonSchema/","link":"","permalink":"http://yoursite.com/2017/05/27/rapidjsonSchema/","excerpt":"","text":"rapidjson Schema 本系列文章以例子的方式进行呈现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** JsonSchema本质上是一个json，其作用是用于校验Json，使用schema对json进行校验，* 可以让代码安全的去当问DOM，而不需要去检查类型或者键值的存在等等。这也能确保输* 出的json符合特定的schema。*/#include \"rapidjson/schema.h\"#include \"rapidjson/stringbuffer.h\"#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;string.h&gt;using namespace std;using namespace rapidjson;/*使用JsonSchema校校验json格式的流程:* 1. 将schema(模板)解析成一个Document* 2. 然后将Document编译成一个SchemaDocument* 3. 通过上述SchemaDocument创建一个SchemaValidator。* 4. 然后通过document.Accept(validator)去校验一个json，获取校验结果。*注意：* 1. 一个SchemaDocument能被多个SchemaValidator引用，他不会被SchemaValidator修改。* 2. 可以重复使用SchemaValidator校验多个文件。在校验其他文件之前，必须先调用validator.Reset()。*JsonSchema的格式：* 1. JsonSchema实质上是一个json数据。* 2. JsonSchema与其他json数据不同的是它在每一个对象和元素中定义了他们的类型type，属性(如object的properties，以及integer的minimum等等)，* 同时，我们可以通过JsonSchema对json的值的类型以及取值范围等进行限定。schema中必须的值需要显示的声明在required中。*/bool ValidateJson() &#123; string testSchema = \"&#123;\\\"type\\\":\\\"object\\\", \\\"properties\\\":&#123;\\\"code\\\":&#123;\\\"type\\\":\\\"string\\\"&#125;, \\\"int\\\":&#123;\\\"type\\\":\\\"integer\\\", \\\"minimum\\\":0&#125;&#125;, \\\"required\\\":[\\\"int\\\",\\\"code\\\"]&#125;\"; Document sd; if (sd.Parse(testSchema.c_str()).HasParseError()) &#123; printf(\"jsonSchema is not valid : %s\", testSchema.c_str()); return false; &#125; //创建SchemaDocument SchemaDocument schema(sd); Document d; if (d.Parse(\"&#123;\\\"code\\\":123, \\\"int\\\":1&#125;\").HasParseError()) &#123; printf(\"Document is not a valid json\"); return false; &#125; SchemaValidator validator(schema); if (!d.Accept(validator)) &#123; StringBuffer sb; validator.GetInvalidSchemaPointer().StringifyUriFragment(sb); printf(\"Invalid schema: %s\\n\", sb.GetString()); printf(\"Invalid keyword: %s\\n\", validator.GetInvalidSchemaKeyword()); sb.Clear(); validator.GetInvalidDocumentPointer().StringifyUriFragment(sb); printf(\"Invalid document:%s\\n \", sb.GetString()); return false; &#125; else &#123; printf(\"符合schemas模式\\n\"); return true; &#125;&#125;int main() &#123; ValidateJson();&#125;","raw":null,"content":null,"categories":[{"name":"rapidjson学习","slug":"rapidjson学习","permalink":"http://yoursite.com/categories/rapidjson学习/"}],"tags":[{"name":"rapidjson","slug":"rapidjson","permalink":"http://yoursite.com/tags/rapidjson/"},{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"}]},{"title":"rapidjson指针","slug":"rapidjson指针","date":"2017-05-27T01:35:00.000Z","updated":"2017-05-27T01:41:40.054Z","comments":true,"path":"2017/05/27/rapidjson指针/","link":"","permalink":"http://yoursite.com/2017/05/27/rapidjson指针/","excerpt":"","text":"rapidjson指针 本系列文章以例子的方式进行呈现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include \"rapidjson/document.h\"#include \"rapidjson/pointer.h\"#include &lt;iostream&gt;using namespace rapidjson;/** Json Pointer* 一个Json Pointer有一串（0至多个）token所组成，每个token之前都有/前缀。每个token* 可以是字符串或者数字。例如，给定一个json:&#123;* \"foo\":[\"bar\", \"baz\"],* \"pi\":3.414* &#125;* JsonPointer解析为:* 1. \"/foo\"-&gt;[\"bar\", \"baz\"]* 2.\"/foo/0\"-&gt;\"bar\"* 3.\"/foo/1\"-&gt;\"baz\"* 4.\"pi\"-&gt;3.414* 特别注意：一个空Json Pointer\"\"解析为整个json*/int main()&#123; Document d; /* 创建、修改、访问dom元素 * 创建dom元素的方法: (两种都可以自动生成父值，可以同时创建几级) * 1.Pointer(\"/Key\").Set(document, \"value\"); key对应值为value * 2.Pointer(\"/Key\").Create(document). 此时创建出来的key对应的值为null * 获取Dom元素的pointer： * 1.Value* vptr = Pointer(\"/Key\").Get(document) * 2.Value&amp; vref = Pointer(\"/Key\").GetWithDefault(document, \"defaultValue\"); * 注意返回的是引用，如值不存在，则创建此键并深拷贝默认值。 * 交换: * Pointer(\"/Key\").Swap(document, value); //注意交换的是Value，不能为其他类型 * 删除： * Pointer(\"/Key\").Erase(document); */ /* 针对上述函数的辅助函数 * SetValueByPointer(document, \"/Key\", \"KeyValue\"); * CreateValueByPointer(document, \"/Key\"); * GetValueByPointer(document, \"/Key\"); * GetValueByPointerWithDefault(document, \"/default\", \"defaultValue\"); * SwapValueByPointer(document, \"/Key\", Value); //必须为Value * EraseValueByPointer(document, \"/Key\"); */ /* Pointer相关函数说明 * 1.Pointer::Get() 或 GetValueByPointer() 函数并不修改 DOM。 * 若那些 token 不能匹配 DOM 里的值，这些函数便返回 nullptr。 * 使用者可利用这个方法来检查一个值是否存在。 * 2. Create()、GetWithDefault()、Set()、Swap()都会改变Dom. * 若一些父值不存在，就会创建它们。若父值类型不匹配 token， * 也会强行改变其类型。改变类型也意味着完全移除其 DOM 子树的内容 */ /* * Pointer中负号解析 * 1.在Get中,负号永远都是Key的名字 * 2.在Set中，若负号在数组的后面，则表示数组最后一个元素的下一个 * 否则表示数组名。例： * d.Parse(\"&#123;\\\"foo\\\":[123]&#125;\"); * SetValueByPointer(d, \"/foo/-\", 456); // &#123; \"foo\" : [123, 456] &#125; * SetValueByPointer(d, \"/-\", 789); // &#123; \"foo\" : [123, 456], \"-\" : 789 &#125; */ /* 字符串化 * 可以将一个Pointe字符串化，存储于字符串或者其他输出流。 * 如： * Pointer p(...); * StringBuffer sb; * p.StringFy(sb); * std::cout &lt;&lt; sb.GetString() &lt;&lt; std::endl; */ Pointer(\"/project\").Set(d, \"RapidJson\"); Pointer(\"/stars\").Set(d, 10); std::cout &lt;&lt; d[\"project\"].GetString() &lt;&lt; std::endl; std::cout &lt;&lt; d[\"stars\"].GetInt() &lt;&lt; std::endl; if (Value* stars = Pointer(\"/stars\").Get(d)) &#123; stars-&gt;SetInt(stars-&gt;GetInt() + 1); &#125; std::cout &lt;&lt; d[\"stars\"].GetInt() &lt;&lt; std::endl; Pointer(\"/default\").GetWithDefault(d, \"defaultValue\"); if (d.HasMember(\"default\")) std::cout &lt;&lt; d[\"default\"].GetString() &lt;&lt; std::endl; Value swapValue(\"SwapValue\"); Pointer(\"/default\").Swap(d, swapValue); std::cout &lt;&lt; d[\"default\"].GetString() &lt;&lt; std::endl; Pointer(\"/default\").Erase(d); if (!d.HasMember(\"default\")) std::cout &lt;&lt; \"d Erase default successful\" &lt;&lt; std::endl;&#125;","raw":null,"content":null,"categories":[{"name":"rapidjson学习","slug":"rapidjson学习","permalink":"http://yoursite.com/categories/rapidjson学习/"}],"tags":[{"name":"rapidjson","slug":"rapidjson","permalink":"http://yoursite.com/tags/rapidjson/"},{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"}]},{"title":"rapidjson查询操作基本用法","slug":"rapidjson查询操作基本用法","date":"2017-05-27T01:32:00.000Z","updated":"2017-06-16T11:43:27.003Z","comments":true,"path":"2017/05/27/rapidjson查询操作基本用法/","link":"","permalink":"http://yoursite.com/2017/05/27/rapidjson查询操作基本用法/","excerpt":"","text":"rapidjson查询操作基本用法 本系列文章以例子的方式进行呈现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226#include \"rapidjson/document.h\"#include &lt;iostream&gt;int main()&#123; const char* test = \"&#123;\\\"num\\\":123, \\\"hello\\\":null, \\\"type\\\": \\\"object\\\",\\\"properties\\\": &#123;\\\"oid\\\": &#123;\\\"type\\\": \\\"string\\\"&#125;, \\\"username\\\": &#123;\\\"type\\\": \\\"string\\\"&#125;,\\\"creid\\\": &#123;\\\"type\\\": \\\"string\\\"&#125;&#125;,\\\"required\\\": [\\\"oid\\\", \\\"username\\\",\\\"creid\\\"]&#125;\"; rapidjson::Document document; //Parse(const char*). 从c-string解析为Document json格式 document.Parse(test); //GetString().从Document json中取出string std::cout &lt;&lt; \"type = \" &lt;&lt; document[\"type\"].GetString() &lt;&lt; std::endl; /* 函数原型 函数功能 * IsNull() 判断当前键对应的值是不是null * IsNumber() 判断当前键对应的值是不是number * IsInt() 判断当前键对应的值是不是int * IsDouble() 判断当前键对应的值是不是double * IsString() 判断当前键对应的值是不是string * IsBool() 判断当前键对应的值是不是bool * IsArray() 判断当前键对应的值是不是array * ... */ std::cout &lt;&lt; \"hello is \" &lt;&lt; (document[\"hello\"].IsNull() ? \"null\" : \"not null\") &lt;&lt; std::endl; std::cout &lt;&lt; \"num is \" &lt;&lt; (document[\"num\"].IsNumber() ? \"number\" : \"not number\") &lt;&lt; std::endl; std::cout &lt;&lt; \"required is \" &lt;&lt; (document[\"required\"].IsArray()? \"array\" : \"not array\") &lt;&lt; std::endl; /* 访问Array的两种方法 * 1. 通过下标访问 //使用引用来连续访问，方便之余还更高效。 * 2. 通过迭代器访问 * 注意问题 * 1.索引使用SizeType类型，而不是size_t类型，缺省情况下，SizeType是unsigned的typedef * 2.对于String类型使用GetInt是非法的，这个时候会导致程序崩溃 */ const rapidjson::Value &amp;a = document[\"required\"]; assert(a.IsArray()); for (rapidjson::SizeType i = 0; i &lt; a.Size(); i++) std::cout &lt;&lt; a[i].GetString() &lt;&lt; std::endl; for (rapidjson::Value::ConstValueIterator it = a.Begin(); it != a.End(); it++) &#123; std::cout &lt;&lt; it-&gt;GetString() &lt;&lt; std::endl; std::cout &lt;&lt; it-&gt;GetStringLength() &lt;&lt; std::endl; &#125; /* 访问object的方法 * 1.使用迭代器进行访问 * 2.使用键对应的下标进行当问 如:document[\"required\"] * 注意问题 * 1.在使用下标访问之前，最好先调用HasMember()检查一下当前键是否存在，若存在再往下继续。否则会出现段错误。 */ static const char* kTypeNames[] = &#123;\"Null\", \"False\", \"True\", \"Object\", \"Array\", \"String\", \"Number\"&#125;; for (rapidjson::Value::ConstMemberIterator it = document.MemberBegin(); it != document.MemberEnd(); it++) &#123; std::cout &lt;&lt; it-&gt;name.GetString() &lt;&lt; \" is type : \" &lt;&lt; kTypeNames[it-&gt;value.GetType()] &lt;&lt; std::endl;; &#125; /* 查询Number * 说明:Json只提供一种数值类型---Number。Number可以是实数也可以是整数 * Dom提供了5中数值类型。包括unsigned,int,uint_64,int_64,double * 类型检查 数值提取 * IsUint() GetUint() * IsInt() GetInt() * IsUint64() GetUint64() * IsInt64() GetInt64() * IsDouble() GetDouble() * * 查询String * 说明：除了getString(), Value类也有一个GetStringLength();原因是rapidjson的String需要支持Unicode字符，如\\u0000.问题是C/C++字符串是 * 空字符结尾的字符串，，这种字符串会把'\\0'作为结束符号。为了符合RFC4627，若要处理这些带有unicode的字符串， * 需要使用GetStringLength获取正确的字符串长度 * 函数 功能 * const char* getString() 获取C字符串 * SizeType GetStringLength()const 获取字符串的长度, */ rapidjson::Document d1; d1.Parse(\"&#123;\\\"s\\\":\\\"a\\\\u0000b\\\", \\\"num\\\":123&#125;\"); std::cout &lt;&lt; d1[\"s\"].GetString() &lt;&lt; std::endl; std::cout &lt;&lt; d1[\"s\"].GetStringLength() &lt;&lt; std::endl; std::cout &lt;&lt; strlen(d1[\"s\"].GetString()) &lt;&lt; std::endl; /* * 比较两个Value的值 * 1.使用==和!=比较两Value的值，当且仅当两个Value的类型和内容相等才算相等。 * 2.可以将Value与原始值进行比较 * 3.若被比较的两个Value的类型不同，直接返回false。 * 4.可以比较不同Object的值 */ std::cout &lt;&lt; (document[\"num\"] == document[\"hello\"]) &lt;&lt; std::endl; std::cout &lt;&lt; (document[\"num\"] == d1[\"num\"]) &lt;&lt; std::endl; /* * 创建/修改值 * 1.改变Value的类型:当使用默认构造函数创建一个Value或者Document的时候，它的类型默认为 * NULL,要改变其类型，使用SetXXX()。如 * rapidjsons::Document d; * d.SetObject()； //将d的类型修改为Object * rapidjson::Value v; * v.SetInt(1); //或者v = 1; * 2.构造函数的重载 * rapidjson::Value b(false); * rapidjson::Value n(10); * * 3.特别注意Value的转移语义。 Value重载operator=()时使用了转移语义。 * rapidjson::Value a(123); * rapidjson::Value b(456); * a = b; //此时b变为null,a为456 * 4.使用move()函数实现函数参数中的转移语义 * rapidjson::Value a(0); * test(a.move()); * */ rapidjson::Value testa(10); rapidjson::Value testb(10); testa = testb; std::cout &lt;&lt; testa.GetInt() &lt;&lt; std::endl; if (testb.IsNull()) &#123; std::cout &lt;&lt; \"testb is moved to a, and now testb is null\" &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; testb.GetInt() &lt;&lt; std::endl; &#125; /* * 创建String * rapidjson提供两种string的存储策略: * 1.copy-string(深拷贝)：分配缓冲区，然后把来源数据复制至它 * 2.const-string(浅拷贝)：简单的存储字符串指针 * 说明： * 1.copy-string总是安全的,因为它拥有数据的克隆 * 2.当数据源发生改变，const-string中的数据也会受到影响 * 上面两种字符串的创建方式: * 1.copy-string创建方式需要给API传递一个Allocator参数,这个做法避免了给每一个 * Value都保存一个Allocator。另外还需要一个length参数，保存长度信息，故 * 此函数可以处理带有空字符的字符串。 * 2.const-string创建方式不需要长度信息和Allocator参数，它默认字符串以\\0结束. * 一般用于常量字符串或者具有安全生存周期的字符串上 */ rapidjson::Value autor; char buffer[50]; int len = sprintf(buffer, \"%s %s\", \"Milo\", \"Yip\"); autor.SetString(buffer,len, document.GetAllocator()); memset(buffer, 0x0, sizeof(buffer)); std::cout &lt;&lt; autor.GetString() &lt;&lt; std::endl; rapidjson::Value testString; testString = \"testString\"; std::cout &lt;&lt; testString.GetString() &lt;&lt; std::endl; /** 修改Array * 函数 功能 * clear() 清空Array中的内容 * Reserve(SizeType, Allocator&amp;) 申请指定大小空间，单不插入数据 * Value&amp; PushBack(Value&amp;, Allocator&amp;) 添加元素 * template &lt;typename T&gt; GenericValue&amp; PushBack(T, Allocator&amp;) 添加元素 * Value&amp; PopBack() 删除最后一个元素 * ValueIterator Erase(ConstValueIterator pos) 删除指定位置元素 * ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) 删除指定范围元素 */ rapidjson::Value testArray(rapidjson::kArrayType); rapidjson::Document::AllocatorType&amp; testAllocator = document.GetAllocator(); for (int i = 0; i &lt; 5; i++) &#123; testArray.PushBack(i, testAllocator); &#125; testArray.PushBack(\"lua\", testAllocator).PushBack(\"Mio\", testAllocator); for (rapidjson::SizeType i = 0;i &lt; 5; i++) std::cout &lt;&lt; testArray[i].GetInt() &lt;&lt; std::endl; std::cout &lt;&lt; testArray[5].GetString() &lt;&lt; std::endl; std::cout &lt;&lt; testArray[6].GetString() &lt;&lt; std::endl; /* 修改Object * 说明：每个Object都是键值对的集合。每个键必须为String。 * 添加成员的函数： * 1.Value&amp; AddMember(Value&amp;, Value&amp;, Allocator&amp; allocator) * 2.Value&amp; AddMember(StringRefType, Value&amp;, Allocator&amp;) * 3.template &lt;typename T&gt; Value&amp; AddMember(StringRefType, T value, Allocator&amp;) * * 补充说明：1.使用StingRefType作为name参数的重载版本与字符串的SetString()类似。这些重载是为了避免复制name字符串 * 因为jsonObject中经常会使常数键名。 * 2.如果你需要从非常数字符串或者生命周期不足的字符串创建键名，需要使用copy-string API。 * 为了避免中间变量，可以使用临时值 * * 移除成员函数： * 1.bool RemoveMember(const Ch* name)：使用键名来移除成员（线性时间复杂度）。 * 2.bool RemoveMember(const Value&amp; name)：除了 name 是一个 Value，和上一行相同。 * 3.MemberIterator RemoveMember(MemberIterator)：使用迭代器移除成员（_ 常数 _ 时间复杂度）。 * 4.MemberIterator EraseMember(MemberIterator)：和上行相似但维持成员次序（线性时间复杂度）。 * 5.MemberIterator EraseMember(MemberIterator first, MemberIterator last)：移除一个范围内的成员，维持次序（线性时间复杂度）。 */ rapidjson::Value contact(rapidjson::kObjectType); contact.AddMember(\"name\", \"milo\", document.GetAllocator()); contact.AddMember(\"married\", false, document.GetAllocator()); std::cout &lt;&lt; \"contact[name] is:\"&lt;&lt;contact[\"name\"].GetString() &lt;&lt; std::endl; std::cout &lt;&lt; \"contact[married] is:\" &lt;&lt; contact[\"married\"].GetBool() &lt;&lt; std::endl; contact.AddMember(rapidjson::Value(\"copy\", document.GetAllocator()).Move(), // copy string rapidjson::Value().Move(), // null value document.GetAllocator()); /* 深复制Value * 方法： * 1.含有Allocator的构造函数 * 2.含有Allocator的CopyFrom * 交换Value * 方法： Swap() 无论两颗Dom树多复杂，交换时间为常数 */ rapidjson::Value testCopy1(123); rapidjson::Value testCopy2(testCopy1, document.GetAllocator()); rapidjson::Value testCopy3; testCopy3.CopyFrom(testCopy1, document.GetAllocator()); testCopy1.Swap(testCopy3);&#125;`","raw":null,"content":null,"categories":[{"name":"rapidjson学习","slug":"rapidjson学习","permalink":"http://yoursite.com/categories/rapidjson学习/"}],"tags":[{"name":"rapidjson","slug":"rapidjson","permalink":"http://yoursite.com/tags/rapidjson/"},{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"}]},{"title":"protobuffer学习总结","slug":"protobuffer学习总结","date":"2017-05-26T11:48:59.000Z","updated":"2017-07-05T08:05:01.184Z","comments":true,"path":"2017/05/26/protobuffer学习总结/","link":"","permalink":"http://yoursite.com/2017/05/26/protobuffer学习总结/","excerpt":"","text":"protobuffer学习总结protobuffer是google开发的一种数据描述语言，它能够将结构化的数据序列化，并切可以将序列化的数据进行反序列化恢复原有的数据结构。一般用于数据存储以及通信协议方面。 如果是第一次使用protobuffer,我们可以将其与json或者xml进行类比，其实它与json或xml类似都可以作为数据的存储方式，不同的是json和xml是文本格式，而protobuffer是二进制格式。二进制格式不利于使用者直观的阅读，但是与json以及xml相比它有更多的优点。 protoBuffer相比于xml的优点 更加简介 体积小：消息大小只需要xml的1/10~1/3 解析速度快：解析速度比xml快20~100倍 使用proto Buffer的编译器，可以生成方便在编程中使用的数据访问代码. 具有更好的兼容性，很好的支持向上或向下兼容的特性 提供多种序列化的出口和入口,如文件流，string流,array流等等 protobuffer语法消息类型实例：1234567891011121314151617181920Package example;message Person&#123; required string name = 1; required int32 id = 2; optional string email = 3; enum PhoneType&#123; mobile = 1; home = 2; work = 3; &#125; message PhoneNumber&#123; required string number = 1; optional PhoneType type = 2; &#125; repeated PhoneNumber phone = 4;&#125; 指定字段规则protobuffer中字段规则包括一下三种： required：实例中必须包含的字段 optional：实例中可以选择性包含的字段，若实例没有指定，则为默认值，若没有设置该字段的默认值，其值是该类型的默认值。如string默认值为””，bool默认值为false,整数默认值为0。 repeated: 可以有多个值的字段，这类变量类似于vector，可以存储此类型的多个值。 由于一些历史原因，基本数值类型的repeated的字段并没有被尽可能地高效编码。在新的代码中，用户应该使用特殊选项[packed=true]来保证更高效的编码。一般情况下慎重使用required字段，当此字段一定是必要的时候才使用。 repeated使用实例：12345678message Person &#123; required int32 age = 1; required string name = 2; &#125; message Family &#123; repeated Person person = 1; &#125; 12345678910111213141516171819202122232425262728293031323334353637int main(int argc, char* argv[]) &#123; GOOGLE_PROTOBUF_VERIFY_VERSION; Family family; Person* person; // 添加一个家庭成员，John person = family.add_person(); person-&gt;set_age(25); person-&gt;set_name(\"John\"); // 添加一个家庭成员，Lucy person = family.add_person(); person-&gt;set_age(23); person-&gt;set_name(\"Lucy\"); // 添加一个家庭成员，Tony person = family.add_person(); person-&gt;set_age(2); person-&gt;set_name(\"Tony\"); // 显示所有家庭成员 int size = family.person_size(); cout &lt;&lt; \"这个家庭有 \" &lt;&lt; size &lt;&lt; \" 个成员，如下：\" &lt;&lt; endl; for(int i=0; i&lt;size; i++) &#123; Person psn = family.person(i); cout &lt;&lt; i+1 &lt;&lt; \". \" &lt;&lt; psn.name() &lt;&lt; \", 年龄 \" &lt;&lt; psn.age() &lt;&lt; endl; &#125; getchar(); return 0; &#125; 数据类型protobuffer中的数据类型与C++数据类型之间的关联如下图： protobuffer类型 C++类型 double double float float int32 int32 int64 int64 uint32 uint32 uint64 uint64 sint32 int32 sint64 int64 fixed32 uint32 fixed64 uint64 sfixed32 uint32 sfixed64 uint64 bool bool string string bytes string 枚举当需要定义一个消息类型的时候，我们可能想为某一个字段指定预定义列表中的值。这个时候就需要用到枚举 如：123456789101112131415message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3 [default = 10]; enum Corpus &#123; UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; &#125; optional Corpus corpus = 4 [default = UNIVERSAL];&#125; 变量标识号在proto数据结构中，每一个变量都有唯一的数字标识。这些标识符的作用是在二进制格式中识别各个字段的，一旦开始使用就不可再改变。 此处需要注意的是1-15之内的标号在存储的时候只占一个字节，而大于15到162047之间的需要占两个字符，所以我们尽量为频繁使用的字段分配1-15内的标识号。另外19000-19999之内的标识号已经被预留，不可用。最大标识号为2^29-1。 嵌套protobuffer中的消息可以嵌套消息，也就是在一个message中定义另一个message。如上面实例可以看出。 扩展我们可以通过扩展对proto文件进行扩展，而不需要直接区编辑原文件。 例如有原文件:1234message Foo&#123; //... extensions 100 to 199;&#125; 上述extensions 100 to 199表示此范围内的标识号被保留为扩展用。我们在扩展文件中就可以使用这些标识号了。123extend Foo&#123; optional int32 bar = 126;&#125; 上述为扩展。当用户的Foo消息被编码的时候，数据的传输格式与用户在Foo里定义新字段的效果是完全一样的。然而，要在程序代码中访问扩展字段的方法与访问普通的字段稍有不同——生成的数据访问代码为扩展准备了特殊的访问函数来访问它。例如，下面是如何在C++中设置bar的值： 12Foo foo;foo.SetExtentions(bar, 15); 注释与c++注释风格相同。双斜杠 向上且向下兼容更新消息当在需求不断增加的过程中，数据结构也会不断变化，这个时候就需要我们去更新消息。怎么才能做到更新消息不会影响之前的数据和代码。这个时候我们更新消息需要遵循以下几个原则： 不要更改任何已有的字段的数值标识 所添加的字段必须是optional或者repeated。 包名称解析为了防止消息明明冲突，我们往往会在文件的开始出生命包，包的作用相当于命名空间。在编译成C++代码时也是namespace。例如：1234package foo.bar;message open&#123; ///...&#125; 在C++对open进行访问的时候的访问方式为: 1foo::bar::open test; protobuffer编译为C++代码的常用接口对于C++来说，编译器会为每个.proto文件生成一个.h文件和.cc文件。.proto文件中的每一个消息对应一个类。protobuffer中常用的函数： has_name() :判断是否有当前成员 clear_name() :清空该成员变量值 name() :获取成员的变量值 set_name(string) :设置变量值 set_name(const char*):设置变量值 set_name(int) :设置变量值 clear() :清空所有元素为空状态 void CopyFrom(person):从给定的对象复制。 mutable_name() :获取变量name的指针 add_name() :为repeated变量增加值 ByteSize() :获取变量所占的字节数若有元素data属性为repeated，其行为类似于vector,则此时则可用下列函数： add_data() : 添加data元素，返回值为Date*类型。 data_size() : 获取repeated元素size，即元素的个数。 data(i) : 获取data中地i个元素。 ByteSize() : 获取序列化之后的protobuff对象的长度。常用的序列化方法 C数组的序列化与反序列化的API如果想将其序列为char并通过socket进行传输，这是使用SerializeToArray来达到目的。*除了下述的SerializeToArray方法之外，还有方法SerializePartialToArray，两者用法相同，其中唯一的区别在于SerializePartialToArray允许忽略required字段，而前者不允许 123456789101112131415161718192021void* parray = (char*)malloc(256);//APIbool ParseFromArray(const void* data, int size);bool SerializeToArray(void* data. int size);void set_people() &#123; wp.set_name(\"sealyao\"); wp.set_id(123456); wp.set_email(\"sealyaog@gmail.com\"); wp.SerializeToArray(parray,256); &#125; void get_people() &#123; rap.ParseFromArray(parray,256); cout &lt;&lt; \"Get People from Array:\" &lt;&lt; endl; cout &lt;&lt; \"\\t Name : \" &lt;&lt;rap.name() &lt;&lt; endl; cout &lt;&lt; \"\\t Id : \" &lt;&lt; rap.id() &lt;&lt; endl; cout &lt;&lt; \"\\t email : \" &lt;&lt; rap.email() &lt;&lt; endl; &#125; C++ String的序列化与反序列化API除了下述的SerializeToString方法之外，还有方法SerializePartialToString，两者用法相同，其中唯一的区别在于SerializePartialToString允许忽略required字段，而前者不允许 1234567891011121314151617181920//C++string序列化和序列化API bool SerializeToString(string* output) const; bool ParseFromString(const string&amp; data); //使用： void set_people() &#123; wp.set_name(\"sealyao\"); wp.set_id(123456); wp.set_email(\"sealyaog@gmail.com\"); wp.SerializeToString(&amp;pstring); &#125; void get_people() &#123; rsp.ParseFromString(pstring); cout &lt;&lt; \"Get People from String:\" &lt;&lt; endl; cout &lt;&lt; \"\\t Name : \" &lt;&lt;rsp.name() &lt;&lt; endl; cout &lt;&lt; \"\\t Id : \" &lt;&lt; rsp.id() &lt;&lt; endl; cout &lt;&lt; \"\\t email : \" &lt;&lt; rsp.email() &lt;&lt; endl; &#125; 文件描述符序列化与反序列化API123456789101112131415161718192021222324252627282930313233//文件描述符的序列化和序列化API bool SerializeToFileDescriptor(int file_descriptor) const; bool ParseFromFileDescriptor(int file_descriptor); //使用: void set_people() &#123; fd = open(path,O_CREAT|O_TRUNC|O_RDWR,0644); if(fd &lt;= 0)&#123; perror(\"open\"); exit(0); &#125; wp.set_name(\"sealyaog\"); wp.set_id(123456); wp.set_email(\"sealyaog@gmail.com\"); wp.SerializeToFileDescriptor(fd); close(fd); &#125; void get_people() &#123; fd = open(path,O_RDONLY); if(fd &lt;= 0)&#123; perror(\"open\"); exit(0); &#125; rp.ParseFromFileDescriptor(fd); std::cout &lt;&lt; \"Get People from FD:\" &lt;&lt; endl; std::cout &lt;&lt; \"\\t Name : \" &lt;&lt;rp.name() &lt;&lt; endl; std::cout &lt;&lt; \"\\t Id : \" &lt;&lt; rp.id() &lt;&lt; endl; std::cout &lt;&lt; \"\\t email : \" &lt;&lt; rp.email() &lt;&lt; endl; close(fd); &#125; C++ stream 序列化和反序列化API1234567891011121314151617181920212223242526//C++ stream 序列化/反序列化API bool SerializeToOstream(ostream* output) const; bool ParseFromIstream(istream* input); //使用： void set_people() &#123; fstream fs(path,ios::out|ios::trunc|ios::binary); wp.set_name(\"sealyaog\"); wp.set_id(123456); wp.set_email(\"sealyaog@gmail.com\"); wp.SerializeToOstream(&amp;fs); fs.close(); fs.clear(); &#125; void get_people() &#123; fstream fs(path,ios::in|ios::binary); rp.ParseFromIstream(&amp;fs); std::cout &lt;&lt; \"\\t Name : \" &lt;&lt;rp.name() &lt;&lt; endl; std::cout &lt;&lt; \"\\t Id : \" &lt;&lt; rp.id() &lt;&lt; endl; std::cout &lt;&lt; \"\\t email : \" &lt;&lt; rp.email() &lt;&lt; endl; fs.close(); fs.clear(); &#125; 参考链接： http://blog.csdn.net/mycwq/article/details/19622571http://colobu.com/2015/01/07/Protobuf-language-guide/https://worktile.com/tech/share/prototol-buffershttp://tech.meituan.com/serialization_vs_deserialization.htmlhttp://blog.csdn.net/weiwangchao_/article/details/16797763","raw":null,"content":null,"categories":[{"name":"序列化与反序列化","slug":"序列化与反序列化","permalink":"http://yoursite.com/categories/序列化与反序列化/"}],"tags":[{"name":"protobuffer","slug":"protobuffer","permalink":"http://yoursite.com/tags/protobuffer/"},{"name":"序列化","slug":"序列化","permalink":"http://yoursite.com/tags/序列化/"}]},{"title":"makefile常用相关函数","slug":"makefile常用相关函数","date":"2017-05-25T11:48:59.000Z","updated":"2017-05-25T12:05:57.683Z","comments":true,"path":"2017/05/25/makefile常用相关函数/","link":"","permalink":"http://yoursite.com/2017/05/25/makefile常用相关函数/","excerpt":"","text":"makefile常用相关函数makefile中函数的用法与变量类似，变量的用法是在变量前面加上$，函数的用法一样，也是使用$开头，$之后加一个括号，括号中的第一个参数是函数名，后面紧跟此函数需要的参数，用逗号分隔。下面介绍几个常用的函数。 wildcard函数 参数: 一个正则表达式 wildcard的中文意思是通配符，它的功能类似于正则表达式，用于展开一列所有符合其参数描述的文件名，文件之间用空格分割。 实例: 1SOURCE=$(wildcard *.cpp) 此时SOURCE的值为所有的以.cpp为后缀的文件集合，以空格隔开。 patsubst函数其功能是一个匹配替换的函数(pattern substitute)。 参数：第一个是需要匹配的样式，第二个是表示用什么替换它，第三个被处理的以空格隔开的字符串。 实例:1TARGET = $(patsubst *.cpp, *.o, $(SOURCE)) TARGET表示与SOURCE中同名的目标文件. $@,$&lt;, $^上述几个变量的含义： $@ 表示目标的文件名 $&lt; 表示依赖中的第一个文件名 $^ 表示依赖中所有的文件名 实例：1all: library.cpp main.cpp 其中$@标识all, $&lt;表示library.cpp ，$^表示library.cpp main.cpp","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"makefile","slug":"makefile","permalink":"http://yoursite.com/tags/makefile/"}]},{"title":"Unix标准IO文件流及缓冲类型","slug":"Unix标准IO缓冲类型","date":"2017-05-24T13:14:10.000Z","updated":"2017-05-25T01:45:32.860Z","comments":true,"path":"2017/05/24/Unix标准IO缓冲类型/","link":"","permalink":"http://yoursite.com/2017/05/24/Unix标准IO缓冲类型/","excerpt":"","text":"Unix标准IO文件流及缓冲类型Unix标准IO文件流在文件IO相关函数的一节中,我们所有的I/O函数都是围绕着文件描述符来操作的，当打开一个文件的时候，即返回一个文件描述符，然后该文件描述符用于后续的文件操作。而对于标准IO库，对于文件的操作都是围绕这 文件流 file stream进行的。当我们使用标准IO库打开或创建一个文件的时候，我们已经使一个流和一个文件进行关联。 文件流由于历史原因，C语言中原来表示流的数据结构是FILE，而不是叫做流。由于大多数的库函数使用到了FILE类型，有的时候在使用FILE指针的时候也叫其为流，这导致后来很多数据把FILE和流搞得十分混乱。实际上流就是标准IO库中程序与文件交互的一种方式。 标准IO函数fopen打开一个文件时返回一个指向FILE对象的指针，该对象通常是一个结构，它包含了标准IO库为管理该流所需要的所有信息，包括该文件的文件描述符，用于指向该流缓冲区的指针，缓冲区的长度，当前缓冲区中的字符数以及出错标志等等。 标准输入，标准输出以及标准错误标准库中对于每一个进程都预定义了三个流，分别是stdin,stdout以及stderr，他们分别对应与Linux文件IO中的STDIN_FILENO,STDOUT_FILENO和STDERR_FILENO。它们的定义在stdio.h中 I/O文件流的缓冲类型标准IO提供缓冲的目的是为了通过减少使用read和write调用的次数来提高IO读写的效率，它对每个IO流自动的进行缓冲处理，从而避免了用户程序在使用read和write需要考虑的这一点。 标准IO流提供了三种缓冲。分别是全缓冲(fully buffering)，行缓冲(line Buffering)以及无缓冲(nonBuffering)。 全缓冲在使用全缓冲的情况下，当数据填满整个缓冲区之后才进行实际的IO操作。对于驻留在磁盘上的文件的读写通常是使用全缓冲。通常如果不给文件流指定缓冲区的情况下，标准IO函数会首先调用malloc函数获取所需要的缓冲区。 行缓冲在使用行缓冲的情况下，每当输入输出遇到换行或者缓冲区满了的情况下才会进行实际的IO操作，当涉及到终端输入输出的时候通常使用行缓冲。 对于行缓冲有两个限制。1.由于接收行缓冲的缓冲区的长度是固定的，所以只要填满了缓冲区，即使还没有遇到换行符，也会进行IO操作。2.任何时候，只要通过IO库要求从一个不带缓冲的流或者一个行缓冲的流得到输入数据，那么就会冲洗所有缓冲输出流。 ###不带缓冲此时标准IO库不对字符进行缓冲存储。这就使得输入流要求IO立即进行，如标准错误流，若果出现错误，会立马输出。 flush一个流即刷新缓冲区有两个含义。 在IO库方面，flush意味着将缓冲区中的内容写到磁盘上，该缓冲区可能还没有满 在终端驱动方面表示丢弃已经存储在缓冲区中的内容。 ##标准文件流与缓冲类型之间的关系 当标准输入输出指向的是交互式设备（如终端）的时候，它们是行缓冲的，若不是则是全缓冲的。 标准错误永远是无缓冲的。 与缓冲相关的函数我们可以通过一下两个函数对将缓冲关闭或者改变缓冲的类型。其中这些函数应该在流被打开之后调用，而且也应该在对流进行一切操作之前调用。 123#include &lt;stdio.h&gt;void setbuf(FILE* restrict fd, char* restrict buf);int setvbuf(FILE* restrict fd, char* restrict buf, int mode, size_t size); 使用setbuf函数打开或者关闭缓冲，当buf是一个有效缓冲区时，此时缓冲打开，若流指向的是终端设备，则此时该流是行缓冲的，否则该流是全缓冲的；当buf为NULL的时候，表示关闭该缓冲。 使用setvbuf可以精确的说明缓冲的类型，这里是使用mode来说明的，mode的值包括以下几个： _IOFBF 全缓冲 _IOLBUF 行缓冲 _IONBUF 无缓冲 如果指定一个不带缓冲的流,则忽略buf和size参数。如果指定缓冲，则buf和size分别指定一个缓冲区域和缓冲区域的长度。若此时buf为NULL，则标准IO库将自动制定一个适合长度的缓冲区。 上述函数与缓冲之间的关系 函数 mode buf 缓冲区及长度 缓冲类型 setbuf 非空 长度为size的缓冲区buf 全缓冲或行缓冲 setbuf NULL 无缓冲区 不带缓冲 setvbuf _IOFBF 非空 长度为size的缓冲区buf 全缓冲 setvbuf _IOFBF NULL 合适长度的缓冲区buf 全缓冲 setvbuf _IOLBF 非空 长度为size的缓冲区buf 行缓冲 setvbuf _IOLBF NULL 合适长度的缓冲区buf 行缓冲 setvbuf _IONBF 忽略 无缓冲区 不带缓冲 我们还可以通过fflush强制冲洗一个流，此函数使该流所有未写的数据都被传送到内核。作为一种特殊的情况，当流的NULL时，所有的流将被冲洗：12#include &lt;stdio.h&gt;int fflush(FILE* fd);","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"标准IO","slug":"标准IO","permalink":"http://yoursite.com/tags/标准IO/"},{"name":"缓冲","slug":"缓冲","permalink":"http://yoursite.com/tags/缓冲/"}]},{"title":"CprintNULL","slug":"CprintNULL","date":"2017-05-22T15:55:20.000Z","updated":"2017-05-22T15:56:04.607Z","comments":true,"path":"2017/05/22/CprintNULL/","link":"","permalink":"http://yoursite.com/2017/05/22/CprintNULL/","excerpt":"","text":"printf %s情况下字符串为NULL的输出结果遇到问题12printf(\"this%s\\n\", s);printf(\"%s\\n\", s); 当s为NULL的时候，执行上面三个语句两个语句执行结果分别为:12this(null)segment fault 问题分析在ANSI C中没有对printf时字符串为NULL的情况进行明确的定义，所以当出现这种情况时往往是未定义行为。所以上面第一种情况会出现segment fault的情况是一种未定义行为，可能在其他编译器上不会出现段错误。 上面出现段错误的行为我们可以通过反汇编进行查看。 反汇编的结果如下： 12345804842d: c7 04 24 20 85 04 08 movl $0x8048520,(%esp)8048434: e8 0b ff ff ff call 8048344 &lt;printf@plt&gt;8048439: c7 04 24 00 00 00 00 movl $0x0,(%esp)8048440: e8 df fe ff ff call 8048324 &lt;puts@plt&gt;8048445: 83 c4 14 add $0x14,%esp 从上面可以看出第一个执行被汇编成真正的printf指令，而第二个简单的printf NULL的指令被汇编成puts。所以才出现了上面的结果。","raw":null,"content":null,"categories":[{"name":"C++ problems","slug":"C-problems","permalink":"http://yoursite.com/categories/C-problems/"}],"tags":[{"name":"print","slug":"print","permalink":"http://yoursite.com/tags/print/"}]},{"title":"Unix环境变量","slug":"Unix环境变量","date":"2017-05-22T15:53:53.000Z","updated":"2017-05-24T12:20:42.749Z","comments":true,"path":"2017/05/22/Unix环境变量/","link":"","permalink":"http://yoursite.com/2017/05/22/Unix环境变量/","excerpt":"","text":"Unix环境变量概述在Unix中，每个进程都有自己的一组环境变量，这些环境变量，要么是一组全局字符串，要么是子进程从父进程继承而来的,如果子进程不对其修改则与父进程的环境变量一模一样。Unix内核并不查看这些字符串，它们的解释权完全取决于各个应用程序。例如shell是Unix中一个可执行程序，通常shell的启动文件中会对环境变量进行设置。所以当我们进入shell之后可以查看path等环境变量。在当前shell中启动的进程会继承其父进程shell的环境变量，也就可以查看path等环境变量，环境变量可以在登录的时候自动设置，也可以由用户自行设置。 环境变量相关变量每个程序都会接收到一张环境表。与参数表一样，环境表也是一个字符指针数组。其中每个指针都包含一个以NULL结尾的字符串的地址。全局变量environ指向了这个数组的地址。 代码如下:12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;extern char **environ;if (environ!= NULL) &#123; for (i = 0; environ[i] != NULL; i++) &#123; printf(&quot;env: %s\\n&quot;, environ[i]); &#125;&#125; 环境变量相关的函数与环境变量相关的函数包括以下几种：取环境变量的值，添加环境变量、修改环境变量、以及删除环境变量. 12345678910111213141516171819202122232425262728293031#include &lt;stdlib.h&gt;//获取环境变量的值char* getenv(const char* name); //若包含此key返回对应的值，否则返回NULL/** function: 修改环境变量的值 前面两个分别为键值对，最后一个表示是否需要删除原有的定义重写。* params：键没有存在，则创建此键值对。若键已经存在：rewrite=0时不覆盖原来的值；rewrite!=0覆盖原来的值* return：成功返回0， 出错返回非0。*/int setenv(const char* name, const char* value, int rewrite);/** function： 添加环境变量，若存在则删除原有的，添加新的，不存在则直接添加* params: 参数为一个键值对字符串，如&quot;name=test&quot;* return: 成功返回0,不成功返回-1*/int putenv(char *str);/** function: 删除name的定义，即使不存在也不出错。* params: 参数为键* return：出错返回-1,不出错返回0*/int unsetenv(const char*name);/** function: 清除所有的环境变量* return: 成功返回0, 失败返回-1。*/int clearenv(); putenv和setenv的区别putenv可以使用程序中已经定义的且形如”name=value”的字符串作为参数。此时系统不再为该环境变量分配内存，环境变量将使用程序中定义变量的内存。并将该字符串的地址保存在环境变量中。所以要使用putenv一定要用全局变量作为参数，否则程序退出栈内存被释放，再次访问环境变量将会出现未定义行为，导致环境变量不可用。 putenv也可用字符串常量做参数，这个时候系统将为其分配内存。 但是setenv去设置环境变量系统将会先malloc出一块内存给环境变量使用，所以此时不需要担心环境不可用的情况。 环境变量在进程空间中的存储位置环境变量和环境字符串通常放在进程存储空间的顶部，也就是栈内存之上。12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;extern char **environ;int main() &#123; int i; printf(&quot;the address of the environment: %p\\n&quot;, environ); printf(&quot;the adress of first i: %p\\n&quot;, &amp;i);&#125; 环境变量中进行增删改操作的实现机制删除环境变量比较容易，当增加或者修改环境变量的时候由于环境表和环境字符串通常占用的是进程地址空间的顶部，所以它不能再向高地址（向上）扩展，同时也不能在移动在它之下的各栈帧，所以也不能向下扩展。两者的组合使得该空间的长度不能再增加。 删除环境变量：删除环境变量时只需要先找到该指针，然后将所有后续指针都向环境表的首部顺序移一个位置。 修改环境变量: 若新的环境变量value长度小于或者等于原有的值，则直接将其复制到旧值。 否则，先调用malloc在堆上分配一块内存，然后将新字符串指向该空间，接着使环境变量表中针对name的指针指向新分区。 增加环境变量： 增加新环境变量比较复杂。必须首先通过调用malloc为新的name=value分配内存空间，然后将字符串复制到此空间中。 如果该name是第一次增加，则必须调用malloc为新的指针表分配内存空间，然后将原来的环境表复制到新的内存，并将指向新的name=value字符串的指针存放在该指针表的表尾，然后将空指针放在其后面。最后使environ指向新的环境表。这样就导致原来位于栈顶之上的环境表移到了堆内存中。但是大多数的环境指针仍然指向栈顶之上的name=value字符串。 如果不是第一次新增加一个name，可知之前已经将环境表迁移到堆内存中，所以只需要调用realloc，以分配比原空间多存放一个指针的空间。然后将指针指向name=value字符串的指针，最后是一个NULL指针。","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"setenv","slug":"setenv","permalink":"http://yoursite.com/tags/setenv/"},{"name":"putenv","slug":"putenv","permalink":"http://yoursite.com/tags/putenv/"},{"name":"unsetenv","slug":"unsetenv","permalink":"http://yoursite.com/tags/unsetenv/"},{"name":"clearenv","slug":"clearenv","permalink":"http://yoursite.com/tags/clearenv/"}]},{"title":"Unix文件IO相关函数","slug":"Unix文件IO相关函数","date":"2017-05-22T15:31:31.000Z","updated":"2017-06-14T13:31:28.805Z","comments":true,"path":"2017/05/22/Unix文件IO相关函数/","link":"","permalink":"http://yoursite.com/2017/05/22/Unix文件IO相关函数/","excerpt":"","text":"Unix文件IO相关函数Unix中大多数文件的操作只需要用到五个函数open、read、write、lseek、和close。本章将详细讲解这些函数的用法以及参数详解。 文件描述符对于内核而言，所有打开的文件都是通过文件描述符进行引用。文件描述符是一个非负整数。当打开或者创建一个文件的时候，内核向进程返回一个文件描述符。当对这个文件进行读写的时候，将这个参数传递给read或write。LINUX用于IO的数据结构一章中讲了STDIN_FILENO、STDOUT_FILENO以及STDERR_FILENO所对应的文件描述符。 为了保证系统资源的合理使用和安全性，Unix系统对于系统和用户能打开的文件描述符的格式都做了一定的限制。通过一下命令我们可以进行查看： 12sysctl -a | grep fs.file-max //查看系统级限制的文件描述符的个数ulimit -n //查看用户（进程）级别限制的文件描述符的个数， 文件描述符与文件指针的关系文件描述符：内核会为每一个运行中的进程在进程控制块(pcb)中维护一个打开文件的记录表，每个表项都有一个指针指向打开的文件，文件描述符就是记录表的索引。 文件指针：C语言使用文件指针而不是文件描述符作为文件IO的句柄，文件指针是指向进程的用户空间中的一个FILE结构的数据结构，FILE结构中包括一个IO缓冲区和一个文件描述符，而文件描述符是文件描述符表的一个索引，从某种意义上可以将文件指针理解为文件句柄的句柄。 12345678910typedef struct &#123; char* _ptr; int _cnt; char* _base; int _flag; int _file; int _charbuf; int _bufsiz; char* _tmpfname;&#125; FILE; 文件指针相比于文件描述符是高级的接口. 文件指针使用fread()和fwrite()函数进行操作,文件描述符使用write()和read()函数进行操作 文件指针具有缓冲区，是较高级别的IO，读写时具有缓冲，具有错误指示和EOF检测；文件描述符没有 文件指针具有移植性，文件描述符不能移植到除Unix之外的系统。 fopen在stdio.h中，open在fcntl.h中 fopen是标准C中定义的，而open是posix中定义的。 fwrite/fread处理的速度快于read/write，但是在内存方面read/write性能较好。 函数open()和openat()函数原型12int open(const char* path, int oflag, .../*mode_t mode*/);int openat(int fd, const char* path, int oflag, .../*mode_t mode*/) 返回值说明若文件打开失败返回-1，打开失败原因可以通过errno或者strerror(errno)查看; 若成功将返回最小的未用的文件描述符的值。 参数说明 path为要打开的文件的文件路径 oflag为文件打开模式. …为可变参数，可以视情况添加 文件打开模式文件打开模式标识当前进程对打开文件的操作权限。通常用一个或者多个权限的或来表示。权限列表如下： flag 含义 O_RDONLY 只读权限 O_WRONLY 只写权限 O_RDWR 读写权限 O_EXEC 可执行权限 O_SEARCH 搜索权限(针对目录) O_APPEND 每次写都追加到文件的末端 O_CLOEXEC 把close_on_exec设置为文件描述符标识 O_CREATE 若文件不存在，则创建它。使用此选项的时候，需要使用第三个参数指定该新文件的访问权限位 O_DIRECTORY 如果path不是目录则出错 O_EXCL 若同时执行了O_CREATE，若文件存在则出错，可以用此选项测试文件是否存在 O_NOCTTY 如果PATH引用的是终端设备，则不将该终端设备作为该进程的控制终端 O_NOFOLLOW 若PATH引用的是符号链接，则出错 O_NONBLOCK 如果path引用的是FIFO,一个块特殊文件或者一个字符特殊文件，则将文本打开操作和后续的IO设置为非阻塞模式 O_SYNC 使每次write等待物理IO完成，包括该write属性引起的文件属性更新需要的IO O_TRUNC 如果文件存在，且打开模式为只写或者读写，则将文件内容截断为0 O_TTY_INIT 如果打开一个还未打开的终端设备，设置非标准termios参数值，使其符合Single Unix Specification O_DSYNC 每次write要等待物理IO操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需要等待文件属性被更新 O_RSYNC 使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作完成 文件访问权限mode_tmode的值表示了对文件的访问权限。这个访问权限与使用shell命令chmod去修改文件的权限的含义相同，文件的权限包括三大类，分别是当前文件对于文件所有者(u)，文件所有者所在的组(g)以及其他用户(o)而言,对这三种角色又分别具有读写可执行的权限。所以这个参数只有在创建文件的时候才用到，用来指定当前创建的文件所对应的权限。 mode 含义 S_IRUSR 用户读 S_IWUSR 用户写 S_IXUSR 用户可执行 S_IRGRP 组读 S_IWGRP 组写 S_IXGRP 组可执行 S_IROTH 其他读 S_IWOTH 其他写 S_IXOTH 其他可执行 需要注意的是，目录的可执行权限以及读权限与文件的相应权限完全不同。目录的可执行权限表示搜索位，即可搜索权限，若目录不具有可执行权限则不能cd进入文件；目录的读权限是可以查看目录中文件内容的权限，若文件夹不具有读权限，则ls不能显示目录内的内容。 open与openat的区别open和openat的区别主要在fd上 path参数指定的是绝对路径名，在这种情况下，open与openat相同，fd忽略. path参数是相对路径名，fd参数指出了相对路径名在文件系统中的开始地址。fd参数通过打开相对路径名所在的文件目录获取。即此时fd为打开相对路径所获取的文件描述符。 path参数为相对路径，fd参数为AT_FDCWD，此时相对路径为当前目录，作用于open相同。 函数create()函数原型1int create(const char *path, mode_t mode); 返回值说明若文件创建失败返回-1;若创建成功返回当前创建文件的文件描述符。 参数说明参数与open中对应的参数含义相同 函数功能说明create(path, mode)函数功能为创建新文件，与open(path, O_CREATE|O_TRUNC|O_WRONLY)功能相同。 函数close()函数原型1int close(int fd); 返回值说明文件关闭成功返回0,关闭失败返回-1. 函数功能介绍该函数的作用是关闭指定文件描述符的文件，关闭文件时还会释放该进程加在该文件上的所有的记录锁。当一个进程终止时，内核自动关闭它所有打开的文件。很多程序都是利用这一功能而不是close函数关闭打开的文件。但是对于长期运行的函数，最好还是使用close关闭打开的文件。 lseek()函数每个打开的文件在文件表项中存在着对应的当前文件的偏移量(current file offset)，通常为非负整数。文件的读写操作都是从当前偏移量开始，并在操作后将偏移量增加相应的字节数。当打开文件模式为O_APPEND时，该文件的offset是文件末尾，除此之外，其他情况都被初始化为0. 函数原型1int lseek(int fd, off_t offset, int whence); 返回值说明成功则返回新的文件的偏移量；失败则返回-1. 函数功能使用lseek()函数显式的为一个打开的文件设置偏移量。lseek仅将文件的偏移量记录在内核中，并不引起IO开销。 参数说明参数offset的解释与whence相关。 若whence为SEEK_SET，则将该文件的偏移量设置为距离当前文件开始处offset字节。 若whence为SEEK_CUR，则将该文件的偏移量设置为距离当前偏移量加offset个字节,此时offset可正可负。 若whence为SEEK_END，则将该文件的偏移量设置为当前文件长度加offser个字节，此时offset可正可负。 123456789101112131415#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;int main() &#123; int fd = open(\"./data\", O_WRONLY | O_CREAT | O_TRUNC); lseek(fd, 20, SEEK_END); write(fd, \"haha\", 4); //可以用这种方法查看打开文件的当前偏移量。 //这种方法可以用来确定当前文件是否可以设置偏移量 //若文件是管道、FIFO或者网络套接字，则lseek返回-1，并将errno设置为ESPIPE off_t currpos; currpos = lseek(fd, 0, SEEK_CUR);&#125; 注意一般情况下文件的偏移量不能为负值，但是一些特殊的文件允许偏移量为负值，如在FreeBSD上运行的设备/dev/kmem支持负的偏移量。因为偏移量可能为负值，所以在比较偏移量的时候不能直接判断其是否小于0，而是要判断其是否等于-1. 文件的偏移量允许大于文件的长度，这时会在文件中出现一些空洞，但是是被允许的。文件中的空洞并不在文件中占磁盘块（block）。 read()函数函数原型123#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes); 返回值说明若读取成功，读到文件末尾返回0，未读到文件末尾返回当前读的字节数。若读取失败，返回-1。 参数说明fd为要读取文件的文件描述符。buf为读取文件数据缓冲区，nbytes为期待读取的字节数，通常为sizeof(buf)。 注意read函数默认读入多行，遇到换行不会停止读入，直到读到文件末尾，下一次读取返回值为0. write()函数函数原型123#include &lt;unistd.h&gt;ssize_t write(int fd, const void* buf, size_t ntyes); 返回值说明若写入成功则返回写入的字节数；失败返回-1. 参数说明buf为写入内容的缓冲区，ntyes为期待写入的字节数，通常为sizeof(buf)。一般情况下返回值与ntypes相等，否则写入失败。 当指定O_APPEND选项，内容将从文件末尾写入，否则从文件开始写入。一般情况下将缓冲区的长度设置为磁盘块的大小可以最大程度的提升程序读写的性能。","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"open","slug":"open","permalink":"http://yoursite.com/tags/open/"},{"name":"openat","slug":"openat","permalink":"http://yoursite.com/tags/openat/"},{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"},{"name":"write","slug":"write","permalink":"http://yoursite.com/tags/write/"},{"name":"close","slug":"close","permalink":"http://yoursite.com/tags/close/"},{"name":"lseek","slug":"lseek","permalink":"http://yoursite.com/tags/lseek/"}]},{"title":"Unix错误处理","slug":"Unix错误处理","date":"2017-05-22T15:24:40.000Z","updated":"2017-05-22T15:29:25.024Z","comments":true,"path":"2017/05/22/Unix错误处理/","link":"","permalink":"http://yoursite.com/2017/05/22/Unix错误处理/","excerpt":"","text":"Unix错误处理当Unix系统函数出错的时候，通常会返回一个负值，同时整型变量errno通常被设置为具有特定信息的值。例如当使用open打开文件的时候，若当前文件不存在，此时open的返回值为-1,errno被设置为2(ENOENT)。系统函数出错的返回值不一定为负数，是根据具体函数具体定义的，如当系统函数返回一个指针时，若出错，将会返回NULL。 Linux系统中errno.h中定义了一系列的错误宏，他们之处了不同错误对应的错误ID，为整型变量，可被赋值。 关于errno需要注意的两点： 如果没出错，errno将不会被进程设置，所以一般当利用函数返回值确认已经出错的时候，再去查看相应的errno 任何函数不会讲errno的值设置为0,而且在errno.h中定义的所有宏定义都不为0 Unix错误处理的两个相关函数strerror函数函数原型123#include &lt;string.h&gt;char* strerror(int errno); 函数功能此函数的功能为将errno转化为其对应的具体错误信息。 示例代码1234567891011#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;int main() &#123; int fd = open(\"data\"); if (fd == -1) &#123; printf(\"%s\", strerror(errno)); &#125;&#125; perror函数函数原型12#include &lt;stdio.h&gt;void perror(const char* msg); 函数功能perror基于当前errno的值，在标准错误流上输出一个出错信息。输出内容首先输出msg所指的字符串，然后一个冒号，空格，接着是errno对应的错误字符串，最后是一个换行符。 示例代码12345678910111213#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]) &#123; int fd = open(\"data\"); if (fd == -1) &#123; printf(\"%s\", strerror(errno)); perror(argv[0]); &#125;&#125; 一些特殊的错误EAGAIN，EWOULDBLOCK和EINTR 在Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。 从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。 例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返 回， read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。 又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。 EAGAIN：Linux - 非阻塞socket编程处理EAGAIN错误 在linux进行非阻塞的socket接收数据时经常出现Resource temporarily unavailable，errno代码为11(EAGAIN)，这是什么意思？ 这表明你在非阻塞模式下调用了阻塞操作，在该操作没有完成就返回这个错误，这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。 对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。 另外，如果出现EINTR即errno为4，错误描述Interrupted system call，操作也应该继续。 最后，如果recv的返回值为0，那表明连接已经断开，我们的接收操作也应该结束。 错误恢复我们可以将errno.h中定义的错误分为两种，分别是致命的和非致命的，对于致命性错误，无法执行恢复操作。对于非致命性错误，大多数来说是暂时的。 对于非致命性错误，最常用的做法就是延迟一段时间，然后重试。例如当错误表示网络不可用，这时我们将可以通过延迟一段时间，进行重新连接。 errno宏定义及相应解释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 EMEDIUMTYPE Wrong medium type 123 ENOMEDIUM No medium found 122 EDQUOT Disk quota exceeded 121 EREMOTEIO Remote I/O error 120 EISNAM Is a named type file 119 ENAVAIL No XENIX semaphores available 118 ENOTNAM Not a XENIX named type file 117 EUCLEAN Structure needs cleaning 116 ESTALE Stale NFS file handle 115 EINPROGRESS +Operation now in progress 114 EALREADY Operation already in progress 113 EHOSTUNREACH No route to host 112 EHOSTDOWN Host is down 111 ECONNREFUSED Connection refused 110 ETIMEDOUT +Connection timed out 109 ETOOMANYREFS Too many references: cannot splice 108 ESHUTDOWN Cannot send after transport endpoint shutdown 107 ENOTCONN Transport endpoint is not connected 106 EISCONN Transport endpoint is already connected 105 ENOBUFS No buffer space available 104 ECONNRESET Connection reset by peer 103 ECONNABORTED Software caused connection abort 102 ENETRESET Network dropped connection on reset 101 ENETUNREACH Network is unreachable 100 ENETDOWN Network is down 99 EADDRNOTAVAIL Cannot assign requested address 98 EADDRINUSE Address already in use 97 EAFNOSUPPORT Address family not supported by protocol 96 EPFNOSUPPORT Protocol family not supported 95 EOPNOTSUPP Operation not supported 94 ESOCKTNOSUPPORT Socket type not supported 93 EPROTONOSUPPORT Protocol not supported 92 ENOPROTOOPT Protocol not available 91 EPROTOTYPE Protocol wrong type for socket 90 EMSGSIZE +Message too long 89 EDESTADDRREQ Destination address required 88 ENOTSOCK Socket operation on non-socket 87 EUSERS Too many users 86 ESTRPIPE Streams pipe error 85 ERESTART Interrupted system call should be restarted 84 EILSEQ Invalid or incomplete multibyte or wide character 83 ELIBEXEC Cannot exec a shared library directly 82 ELIBMAX Attempting to link in too many shared libraries 81 ELIBSCN .lib section in a.out corrupted 80 ELIBBAD Accessing a corrupted shared library 79 ELIBACC Can not access a needed shared library 78 EREMCHG Remote address changed 77 EBADFD File descriptor in bad state 76 ENOTUNIQ Name not unique on network 75 EOVERFLOW Value too large for defined data type 74 EBADMSG +Bad message 73 EDOTDOT RFS specific error 72 EMULTIHOP Multihop attempted 71 EPROTO Protocol error 70 ECOMM Communication error on send 69 ESRMNT Srmount error 68 EADV Advertise error 67 ENOLINK Link has been severed 66 EREMOTE Object is remote 65 ENOPKG Package not installed 64 ENONET Machine is not on the network 63 ENOSR Out of streams resources 62 ETIME Timer expired 61 ENODATA No data available 60 ENOSTR Device not a stream 59 EBFONT Bad font file format 57 EBADSLT Invalid slot 56 EBADRQC Invalid request code 55 ENOANO No anode 54 EXFULL Exchange full 53 EBADR Invalid request descriptor 52 EBADE Invalid exchange 51 EL2HLT Level 2 halted 50 ENOCSI No CSI structure available 49 EUNATCH Protocol driver not attached 48 ELNRNG Link number out of range 47 EL3RST Level 3 reset 46 EL3HLT Level 3 halted 45 EL2NSYNC Level 2 not synchronized 44 ECHRNG Channel number out of range 43 EIDRM Identifier removed 42 ENOMSG No message of desired type 40 ELOOP Too many levels of symbolic links 39 ENOTEMPTY +Directory not empty 38 ENOSYS +Function not implemented 37 ENOLCK +No locks available 36 ENAMETOOLONG +File name too long 35 EDEADLK +Resource deadlock avoided 34 ERANGE +Numerical result out of range 33 EDOM +Numerical argument out of domain 32 EPIPE +Broken pipe 31 EMLINK +Too many links 30 EROFS +Read-only file system 29 ESPIPE +Illegal seek 28 ENOSPC +No space left on device 27 EFBIG +File too large 26 ETXTBSY Text file busy 25 ENOTTY +Inappropriate ioctl for device 24 EMFILE +Too many open files 23 ENFILE +Too many open files in system 22 EINVAL +Invalid argument 21 EISDIR +Is a directory 20 ENOTDIR +Not a directory 19 ENODEV +No such device 18 EXDEV +Invalid cross-device link 17 EEXIST +File exists 16 EBUSY +Device or resource busy 15 ENOTBLK Block device required 14 EFAULT +Bad address 13 EACCES +Permission denied 12 ENOMEM +Cannot allocate memory 11 EAGAIN +Resource temporarily unavailable 10 ECHILD +No child processes 9 EBADF +Bad file descriptor 8 ENOEXEC +Exec format error 7 E2BIG +Argument list too long 6 ENXIO +No such device or address 5 EIO +Input/output error 4 EINTR +Interrupted system call 3 ESRCH +No such process 2 ENOENT +No such file or directory 1 EPERM +Operation not permitted 0 Success","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"errno","slug":"errno","permalink":"http://yoursite.com/tags/errno/"},{"name":"错误处理","slug":"错误处理","permalink":"http://yoursite.com/tags/错误处理/"}]},{"title":"Unix体系结构","slug":"Unix基础知识","date":"2017-05-22T15:18:36.000Z","updated":"2017-06-13T13:27:17.258Z","comments":true,"path":"2017/05/22/Unix基础知识/","link":"","permalink":"http://yoursite.com/2017/05/22/Unix基础知识/","excerpt":"","text":"Unix基础知识Unix体系结构从严格意义上讲，可以将操作系统定义为一种软件，它相当于一种控制计算机硬件资源，为程序提供运行环境的软件。我们通常将这种软件叫做内核，因为它相对比较小，并且位于环境的核心。Unix体系结构如下图: 内核的接口被称为系统调用（system Call），公共库函数建立在系统调用接口之上，应用程序既可以使用公共函数库，也可以使用系统调用。shell是一个特殊的应用程序，为运行其他应用程序提供了接口。 Unix文件和目录文件系统Unix文件系统是文件和目录的一种层次结构，所有文件的起点都是根目录(root)，名称为”/“. 目录是一个包含目录项的文件。逻辑上，可以认为每个目录项都包含一个文件，同时还说明该文件属性的信息。文件属性包括文件类型(普通文件还是目录)、文件权限、；链接到改文件的进程数、文件所有者、文件所有者所在的组 文件大小以及文件最后修改的时间等。stat和fstat函数返回一个文件属性的信息结构。 12345678910111213141516171819202122232425262728293031323334#include &lt;sys/stat.h&gt;//通过文件名获取文件信息，并保存在buf所指的结构体stat中//返回值：成功返回0，失败-1，错误码存在errno中int stat(const char* file_name, struct stat* buf);数据类型：struct stat &#123;dev_t st_dev; /* ID of device containing file -文件所在设备的ID*/ ino_t st_ino; /* inode number -inode节点号*/ mode_t st_mode; /* protection -保护模式?*/ nlink_t st_nlink; /* number of hard links -链向此文件的连接数(硬连接)*/ uid_t st_uid; /* user ID of owner -user id*/ gid_t st_gid; /* group ID of owner - group id*/ dev_t st_rdev; /* device ID (if special file) -设备号，针对设备文件*/ off_t st_size; /* total size, in bytes -文件大小，字节为单位*/ blksize_t st_blksize; /* blocksize for filesystem I/O -系统块的大小*/ blkcnt_t st_blocks; /* number of blocks allocated -文件所占块数*/ time_t st_atime; /* time of last access -最近存取时间*/ time_t st_mtime; /* time of last modification -最近修改时间*/ time_t st_ctime; /* time of last status change - */ &#125; 使用C语言实现ls功能 涉及到的相关函数： 文件夹操作函数opendir，readdir,closedir opendir返回指向dir结构的指针，将该指针传递给readdir,无需关心dir结构中存在什么数据，直接读取即可。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;dirent.h&gt;#include &lt;stdlib.h&gt;void err_quit(const char* message) &#123; printf(\"%s\\n\", message); exit(0);&#125;int main(int argc, char *argv[])&#123; if (argc &lt; 2) &#123; err_quit(\"usage: ls directory_name\\n\"); exit(0); &#125; DIR *dp; struct dirent *dirp; if ((dp = opendir(argv[1])) == NULL) err_quit(\"can not open file\\n\"); while ((dirp = readdir(dp)) != NULL) printf(\"%s\\n\", dirp-&gt;d_name); closedir(dp); return 0;&#125; 输入和输出文件描述符文件描述符是一个很小的非负整数，内核用文件描述符来标识一个特定进程正在访问的文件。当内核打开或创建文件时，他都会返回一个文件描述符。在读写文件时，都可以使用这个描述符（根据打开时的模式赋予权限）. 标准输入、标准输出和标准错误流按照惯例，每当运行一个新程序的时候，所有的shell都会为改程序默认打开三个文件描述符，即标准输入，标准输出和标注错误。如果不做特殊处理，这三个描述符都连接到终端，也可以将其重定向到文件。如ls &gt; test.data","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Unix体系结构","slug":"Unix体系结构","permalink":"http://yoursite.com/tags/Unix体系结构/"}]},{"title":"函数dup与dup2","slug":"函数dup","date":"2017-05-21T15:31:31.000Z","updated":"2017-05-22T15:42:45.892Z","comments":true,"path":"2017/05/21/函数dup/","link":"","permalink":"http://yoursite.com/2017/05/21/函数dup/","excerpt":"","text":"函数dup与dup2函数原型1234#include &lt;unistd.h&gt;int dup(int fd);int dup2(int fd, int fd2); 函数功能这两个函数的功能都是用来复制一个现有的文件描述符。返回的文件描述符与原有的文件描述符共用同一个文件表项，但是文件描述符标志将被清除，即当进程调用exec时文件描述符将不会被关闭。 返回值dup返回当前可用的最小的文件描述符。dup2返回fd2，若fd2所表示的文件已经打开，则将该文件描述符先关闭，然后再将fd复制到fd2上返回。若fd2与fd相同，则直接返回fd、. 等效函数dup函数与fcntl的F_DUPFD功能相同。 dup(fd)等效于fcntl(fd, F_DUPFD, 0) dup2(fd, fd2)等效于close(fd), fcntl(fd, F_DUPFD, fd2) 但是dup2是原子的上述先关闭然后在复制不是原子操作。 作用及用途dup函数常用来重定向进程的stdin、stdout以及stderr。原理与CGI类似，即将标准输入标准输出重定向到一个文件或者socket流等。 重定向标准输出12345678910111213141516171819#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;int main() &#123; int fd = dup(STDIN_FILENO); if (fd &lt; 0) &#123; printf(\"dup error\\n\"); exit(1); &#125; char buf[] = \"this is a test of dup\\n\"; write(fd, buf, sizeof(buf)); return 0;&#125;","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"dup","slug":"dup","permalink":"http://yoursite.com/tags/dup/"},{"name":"dup2","slug":"dup2","permalink":"http://yoursite.com/tags/dup2/"}]},{"title":"cgi原理","slug":"cgi原理","date":"2017-05-04T12:36:55.000Z","updated":"2017-06-13T13:25:20.010Z","comments":true,"path":"2017/05/04/cgi原理/","link":"","permalink":"http://yoursite.com/2017/05/04/cgi原理/","excerpt":"","text":"CGI原理CGI（Common Gateway Interface）通用网关接口，CGI描述了服务器和请求处理程序之间传输数据局的一种标准。在理解的过程中我们需要区分CGI和CGI程序，CGI是一种数据传输的标准，而CGI程序是实际处理业务的一个程序。webserver每请求一次，CGI程序就会fork出一个子进程进行处理。CGI程序的参数通过环境变量和标准输入获得，它的相应通过标准输出传递给webServer。 CGI的工作原理是： 客户端通过http将请求发送到web服务器 web服务器接收并收集用户请求，然后交给CGI程序进行处理 CGI程序把处理后的结果发送给服务器 服务器将结果传送给浏览器 其中上述第二步web服务器通过环境变量或标准输入将请求发送给CGI程序，第三步CGI通过标准输出将结果发送给webServer CGI接口标准：标准输入,环境变量以及标准输出 借口标准 介绍 标准输入 CGI程序像其他可执行程序一样,可通过标准输入(stdin)从Web服务器得到输入信息,如Form中的数据,这就是所谓的向CGI程序传递数据的POST方法。这意味着在操作系统命令行状态可执行CGI程序,对CGI程序进行调试。POST方法是常用的方法。 环境变量 操作系统提供了许多环境变量,它们定义了程序的执行环境,应用程序可以存取它们。Web服务器和CGI接口又另外设置了自己的一些环境变量,用来向CGI程序传递一些重要的参数。CGI的GET方法还通过环境变量QUERY-STRING向CGI程序传递Form中的数据。 标准输出 CGI程序通过标准输出(stdout)将输出信息传送给Web服务器。传送给Web服务器的信息可以用各种格式,通常是以纯文本或者HTML文本的形式,这样我们就可以在命令行状态调试CGI程序,并且得到它们的输出。 ###常用的环境变量Linux中的环境变量是一系列的键值对集合，它们的值可以通过shell设置，也可以被其他进程或程序设置和访问，它们是web服务器传递给CGI程序的一种最简单的方式，之所以叫做环境变量是因为它们是全局变量，任何程序都可以存取它们。 key 意义 SERVER_NAME CGI脚本运行时的主机名和IP地址 SERVER_SOFTWARE 你的服务器的类型如： CERN/3.0 或 NCSA/1.3. GATEWAY_INTERFACE 运行的CGI版本. 对于UNIX服务器, 这是CGI/1.1 SERVER_PROTOCOL 服务器运行的HTTP协议. 这里当是HTTP/1.0. SERVER_PORT 服务器运行的TCP口，通常Web服务器是80. REQUEST_METHOD POST 或 GET, 取决于你的表单是怎样递交的 HTTP_ACCEPT 浏览器能直接接收的Content-types, 可以有HTTP Accept header定义. HTTP_USER_AGENT 递交表单的浏览器的名称、版本 和其他平台性的附加信息。 HTTP_REFERER 递交表单的文本的 URL，不是所有的浏览器都发出这个信息，不要依赖它 PATH_INFO 附加的路径信息, 由浏览器通过GET方法发出. PATH_TRANSLATED 在PATH_INFO中系统规定的路径信息. SCRIPT_NAME 指向这个CGI脚本的路径, 是在URL中显示的(如, /cgi-bin/thescript). QUERY_STRING 脚本参数或者表单输入项(如果是用GET递交). QUERY_STRING包含URL中问号后面的参数 REMOTE_HOST 递交脚本的主机名，这个值不能被设置. REMOTE_ADDR 递交脚本的主机IP地址. REMOTE_USER 递交脚本的用户名. 如果服务器的authentication被激活，这个值可以设置。 REMOTE_IDENT 如果Web服务器是在ident (一种确认用户连接你的协议)运行, 递交表单的系统也在运行ident, 这个变量就含有ident返回值. CONTENT_TYPE 如果表单是用POST递交, 这个值将是 application/x-www-form-urlencoded. 在上载文件的表单中, content-type 是个 multipart/form-data. CONTENT_LENGTH 对于用POST递交的表单,标准输入口的字节数. CGI的工作原理图","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"cgi","slug":"cgi","permalink":"http://yoursite.com/tags/cgi/"}]},{"title":"Wait函数详解","slug":"Wait函数详解","date":"2017-05-04T07:40:48.000Z","updated":"2017-09-09T03:42:33.336Z","comments":true,"path":"2017/05/04/Wait函数详解/","link":"","permalink":"http://yoursite.com/2017/05/04/Wait函数详解/","excerpt":"","text":"Wait函数详解kill头文件sys/types.hsignal.h 函数功能注意此函数的功能是向指定进程发送信号。而不是杀死某个进程.名字为kill的原因是早期的Unix系统对信号的默认处理方式大部分是终止进程。 函数原型int kill(pid_t pid, int sig); 返回值：执行成功返回0，执行失败返回-1。 参数说明pid为进程ID,sig标识要发送的信号。 kill()函数的作用是用来向指定的进程或进程组发送信号。其中pid有一下几种类型: pid &gt; 0： 发送信号给进程标识为pid的进程 pid = 0： 发送信号给当前进程相同进程组的所有进程 pid = -1：发送信号给系统内除了1号进程以外的所有进程 pid &lt; -1：发送信号给进程组标识为-pid的进程。 当sig=0时没有信号发出，但是系统会执行错误检查，通常会利用sig值为0来检查某个进程是否在执行。 若进程不存在,errno为ESRCH 若errno为EPERM(无权向目标进程发送信号，但是存在)或调用成功，表示进程存在。 Example相关知识：WIFSIGNALED和WIFEXITED两个宏是用来判断当前程序的子进程的退出方式，是接收到信号异常退出还是正常调用exit()或return退出。 WIFEXITED: 调用exit()或return退出 WIFSIGNALED:接收到信号异常退出 此时可以使用WTERMSIG(status)获取其接受信号的内容。 123456789101112131415161718192021222324#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;main()&#123; pid_t pid; int status; if(!(pid= fork())) &#123; printf(\"Hi I am child process!\\n\"); sleep(10); return; &#125; else &#123; printf(\"send signal to child process (%d) \\n\", pid); sleep(1); kill(pid, SIGABRT); wait(&amp;status); if(WIFSIGNALED(status)) printf(\"chile process receive signal %d\\n\", WTERMSIG(status)); &#125;&#125; raise和killpg函数除了kill函数可以向进程发送信号外,还可以通过raise和killpg函数发送信号。 函数原型int raise(int sig);int killpg(pid_t pgrpid, int sig); 函数功能raise函数的功能是向进程自身发送信号.在单线程程序中，调用raise函数相当于调用kill(getpid(), sig).对于支持线程的系统，一般将raise实现为:1pthread_kill(pthread_self(), sig); 此时信号只发送给当前进程的当前线程。而不影响其他线程。 killpg函数的作用是向同组的所有进程发送信号。相当于:1kill(-pgrpid, sig); 函数返回值raise函数的错误返回值只有一个,即EINVAL，表示信号无效。其他时候返回都为成功。而killpg的返回值与kill类似。 wait()与waitpid()头文件sys/wait.h 函数原型pid_t wait(int status);pid_t waitpid(pid_t pid, int status, int options); 函数说明父进程创建子进程之后，父进程使用wait和waitpid具有监视子进程的运行状态的能力。这两个函数用于等待子进程的状态发生变化回调并且获取状态发生变化的信息，所能获取的状态变化包括：子进程运行结束,子进程被信号量暂停，子进程被信号量回复运行。 父进程执行wait函数之后，父进程会被阻塞在此处，如果子进程状态发生变化，则wait函数会立即返回结果；否则wait函数会一直阻塞直到子进程状态发生变化。 通常意义上，，如果子进程状态发生了变化，但是还是未被其父进程或者其他系统回调执行wait函数，此时的子进程被称为可等待的。 子进程运行结束后父进程执行wait函数可以推动系统释放与子进程相关的资源；否则子进程将会被维持在僵尸进程（子进程已结束，而父进程还在运行）的状态下一直存在。 参数说明 pid：要监听的进程的ID(&lt;-1, =-1, =0, &gt; 0) status: 用于存储出发状态变化时的信号值和exit(code)中的code值。 options 提供一些额外的选项控制waitpid,目前linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数宏，可以使用|连接使用. pid详细说明: pid &lt; -1 : 监听范围为进程组为-pid的所有子进程 pid = -1 : 监听范围为调用wait/waitpid的所有子进程 pid = 0: 监听范围为子进程的进程组ID（与父进程相等） pid &gt; 0: 监听特定pid的进程 status详细说明 status用于保存出发wait的信号值或者退出时exit(code)中的code值 options详细说明 WNOHANG : 使用此参数调用waitpid,即使子进程没有退出，他也会立即返回，而不是像wait一直等下去 WUNTRACED : 用于调试，极少用 一般情况下使用值为0即可。 wait与waitpid关系wait实质上是waitpid中pid=-1,options=0时封装，即 wait(&amp;status)与waitpid(-1, &amp;status, 0)完全相同 相关宏wait.h中定义了一些宏用于解析status的值： 宏 含义 WIFEXITED(status) 子进程正常退出返回true否则false WEXITSTATUS(status) 当正常退出时，返回exit(code)中的code WIFSIGNALED 子进程接受信号退出时返回true，否则false WTERMSIG 被信号量杀死时，返回信号量的值 WIFSTOPED(status) 当子进程被信号量暂停时返回true WSTOPSIG(status) 被信号量暂停时信号量的值 options值: 常量 含义 WNOHANG 调用wait时制定pid仍未返回，wait立即返回0，用于判断子进程有没有结束 WUNTRACED 当子进程被暂停时，则wait立即返回子进程的pid WCONTINUED 当被暂停的子进程又被信号量恢复后，则wait立即返回子进程的pid。Linux 2.6.10及以后生效。在Mac 0S X 10.9.5上未生效。","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"wait","slug":"wait","permalink":"http://yoursite.com/tags/wait/"},{"name":"kill","slug":"kill","permalink":"http://yoursite.com/tags/kill/"}]},{"title":"Unix文件IO的数据结构及fcntl函数详解","slug":"Unix文件IO的数据结构及fcntl函数详解","date":"2017-05-01T15:31:31.000Z","updated":"2017-06-14T06:40:23.455Z","comments":true,"path":"2017/05/01/Unix文件IO的数据结构及fcntl函数详解/","link":"","permalink":"http://yoursite.com/2017/05/01/Unix文件IO的数据结构及fcntl函数详解/","excerpt":"","text":"Linux用于I/O的数据结构及fcntl函数详解Linux内核用于IO的数据结构内核使用三种数据结构表示打开的文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响. 进程表项 每个进程在记录表中都有一个记录项，记录项中包含一张打开的文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是： 文件描述符标志(close_on_exec,close_on_exec是一个进程所有文件描述符的标记位图，每个比特位代表一个打开的文件描述符，用于确定在系统调用execve()时需要关闭的文件句柄)。 指向一个文件表项的指针 文件表项 内核为所有打开文件维护一张文件表（不同进程打开相同文件将有两条记录），每个文件表项中包括： 文件状态标志(read,write,append,async,nonblock等) 当前文件偏移量 指向该文件v(i)节点表项的指针 节点表项。每个打开的文件都有一个v-node结构，v-node中包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，V-node中还包含了文件inode节点信息，这些信息是打开文件时从磁盘上读入内存的，所以文件所有信息都是随时可用的。 v节点的信息 当前文件的长度 i节点的信息 close_on_exec是一个进程所有文件描述符（文件句柄）的位图标志，每个bit代表一个打开的文件描述符，用于确定在系统调用execve()时是否需要关闭文件句柄。当一个进程fork出一个子进程时，通常会在子进程中调用execve()函数加载执行另一个新程序。此时子进程将完全被新程序替换掉，并在子进程中执行新程序。若一个文件描述符在close_on_exec中对应的bit被设置，那么在执行execve()时该文件描述符将被关闭，否则该文件描述符将始终处于打开状态。当打开一个文件的时候，默认情况下文件句柄在子进程中也处于打开状态。注意文件描述符和文件描述符标志的区别，文件描述符是文件进程打开文件时的文件句柄，文件描述符标志为close_on_exec。 下图显示了一个进程打开两个不同文件时三张表对应的关系： 如果两个独立的进程同时打开同一个文件，三张表之间的对应关系如下： 从上面可以看出，不同进程打开相同的文件时每个进程将获得各自的文件表项，这是因为不同的进程都有各自的文件偏移量。当我们对文件进行操作的时候，上面三种表项之间的变化关系如下： 当对文件进行写操作时（write），在文件表项中的文件偏移量将增加写入的字节数。如果此时文件偏移量超过了文件长度，更新文件长度为当前的文件偏移量 当用O_APPEND标志打开一个文件，则相应的标志也被设置到文件表项的文件标志状态中。每次对这种具有追加标志的文件进行写操作时，首先将当前文件偏移量设置为文件文件长度，这就使得每次增加的内容都会写到文件末尾。 若使用lseek定位到文件末尾，则文件表项中偏移量被设置为文件长度 lseek函数只修改文件表项中的偏移量，不进行任何IO操作。 注意问题： 可能有多个文件描述符指向同一个文件表项，如在fork的时候就有可能发生 注意文件描述符和文件状态标志在作用范围方面的区别。前者只用于一个进程的描述符，而后者则应用于指向该给定文件表项的任何进程中的所有描述符。 函数fcntl功能及用法函数原型: 123#include &lt;fcntl.h&gt;int fcntl(int fd, int cmd, .../*int args or lock args*/); 函数功能:fcntl的作用是改变已经打开的文件属性。 参数说明: fd 为file descriptor,即文件打开之后的文件描述符 cmd为命令，即需要对fd操作的命令,一般为几个宏定义中的其中一个 args 参数，此参数为执行cmd命令所需要的参数 cmd参数命令及功能: fcntl的功能可以分为5种: 复制一个已有的文件描述符 cmd = F_DUPFD，此功能*返回一个文件描述符，新的描述符的值为大于或等于args的可用的（尚未打开）文件描述符的最小值，新描述符与fd共用一个文件表项。但是新的文件描述符有它自己的一套文件描述符标志. cmd = F_DUPFD_CLOEXEC.与上述功能一致，唯一不同的是使用此命令会设置CLOSE_ON_EXEC，即当执行execve的时候，文件描述符将被关闭。 获取或设置文件描述符标志 cmd = F_GETFD 返回与fd关联的close_on_exec标志，第三个参数被忽略。 cnd = F_SETFD 将文件描述符标志close_on_exec设置为第三个参数。 获取或设置文件状态标志 cmd = F_GETFL 获取fd对应的文件的状态标志（存储于文件表项） cmd = F_SETFL 设置fd对应文件的状态标志 获取或设置异步IO所有权 cmd = F_GETOWN 获取当前接受SIGIO和SIGURG信号的进程IO或者进程组ID。 cmd = F_SETOWN 设置接受SIGIO和SIGURG信号的进程ID或进程组ID。返回值为正则为进程，返回值为负数即为进程组。 获取或记录锁（cmd=F_GETLK、F_SETLK、F_SETLKW），此处不详解 文件状态标志说明： 文件状态标志存储与文件表项中，它用于说明进程对当前文件的可操作权限。文件的操作权限说明如下图表所示，权限设置可使用|或者&amp;进行设置. 文件状态标志 功能说明 O_RDONLY 只读权限 O_WRONLY 只写权限 O_RDWR 读写权限 O_EXEC 可执行权限 O_SEARCH 只搜索打开权限 O_APPEND 追加写 O_NONBLOCK 非阻塞模式 O_SYNC 等待写完成（数据和属性） O_DSYNC 等待写完成（仅数据） O_RSYNC 同步读写 O_FSYNC 等待写完成 O_ASYNC 异步IO 注意O_RDONLY、O_WRONLY、O_RDWR、O_EXEC、O_SEARCH这个五个标志并不各占一位，一个文件的访问方式只能取这五个里面的一个。因此检查当前文件的是这五个标志中的哪一个需要使用屏蔽字O_ACCMODE取得当问方式位，在于这五个标志进行对比。 代码示例说明12345678910111213141516171819202122232425262728293031323334#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; int test; //返回结果：test = 10，返回大于等于第三个参数可用的fd(10)。 test = fcntl(STDIN_FILENO, F_DUPFD, 10); printf(\"result of fcntl(STDIN_FILENO, F_DUPFD, 10) is:%d\\n\", test); //返回结果：test=11,与上一个函数功能相同 //不同之处在于其设置了close_on_exec,当执行exec时关闭响应的文件描述符 //注意有一些版本的系统上没有定义这个宏 //test = fcntl(STDIN_FILENO, F_DUPFD_CLOEXEC, 10); //返回结果 test = 0. 标准输入的文件描述符标志(即关闭标志)为0， //意思是执行exec时关联的文件描述符不关闭 test = fcntl(STDIN_FILENO, F_GETFD); printf(\"the result of fcntl(STDIN_FILENO, F_GETFD) is:%d\\n\", test); //将文件描述符标志设置为0 fcntl(STDIN_FILENO, F_SETFD, 0); //返回结果 test = 32270 test = fcntl(STDIN_FILENO, F_GETFL); printf(\"the result of fcntl(STDIN_FILENO, F_GETFL) is:%d\\n\", test); //给STDIN_FILENO对应的IO添加非阻塞权限 test |= O_NONBLOCK; fcntl(STDIN_FILENO, F_SETFL, test); test = fcntl(STDIN_FILENO, F_GETFL); printf(\"the result of fcntl(STDIN_FILENO, F_GETFL) is:%d\\n\", test);&#125; STDIN_FILENO，STDOUT_FILENO以及STDERR_FILENOSTDIN_FILENO等是系统API接口库中的宏定义，它是一个int类型的值，是打开文件的句柄，对应的主要函数有open,read,write和close等。STDIN_FILENO的含义是标准输入（键盘）的文件描述符，STDOUT_FILENO是标准输出流的文件描述符，STDERR_FILENO是标准错误流的文件描述符。 STDIN_FILENO与stdin的区别 数据类型不同 stdin的数据类型为FILE*，STDIN_NO的数据类型为int 可用的函数不同 stdin主要用的函数有fread,fwrite,fclose，STDIN_FILENO可用的函数为write，read和close stdin属于标准IO，高级的输入输出函数，在stdio.h中定义;STDIN_FILENO是文件描述符，一般定义为0,1,2,属于没有buffer的IO,直接调用系统调用，定义在unistd.h中 层次不同，stdin属于标注库处理的输入流，其声明为FILE*型，对应的函数前面都有f开头；而STDIN_FILENO属于系统API接口，对用的函数是一些系统级的调用","raw":null,"content":null,"categories":[{"name":"Linux环境高级编程","slug":"Linux环境高级编程","permalink":"http://yoursite.com/categories/Linux环境高级编程/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"fcntl","slug":"fcntl","permalink":"http://yoursite.com/tags/fcntl/"},{"name":"文件描述符标志","slug":"文件描述符标志","permalink":"http://yoursite.com/tags/文件描述符标志/"},{"name":"文件状态标志","slug":"文件状态标志","permalink":"http://yoursite.com/tags/文件状态标志/"},{"name":"inode","slug":"inode","permalink":"http://yoursite.com/tags/inode/"}]},{"title":"C语言free如何知道要free多大的空间","slug":"free如何知道要free多大的空间","date":"2017-04-07T02:50:31.000Z","updated":"2017-04-07T04:48:27.464Z","comments":true,"path":"2017/04/07/free如何知道要free多大的空间/","link":"","permalink":"http://yoursite.com/2017/04/07/free如何知道要free多大的空间/","excerpt":"","text":"在C语言中，当向一个函数传递指针的时候，它的长度信息往往会被截断（如果是数组名），传入函数的只是一个指针，而无法标示数组的长度，在函数中我们也无法获取它的长度信息，除非显示的传递一个长度参数。但是使用free函数的过程中，我们只是向free中传递了一个指针，并没有标示它的大小，那free是如何知道将要被free掉的内存的大小呢？下面将详细解答这一问题。 malloc函数的实现是以块分配内存，在被分配的块中包括两部分。第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量；第二部分中存储实际用户数据。而使用malloc分配内存返回的是第二部分用户数据的地址。而块的两个部分在内存中的存储取决有编译器的实现，一般有两种情况，第一种是最常见的，即元数据和用户数据是连续的，存储在连续空间位置。第二种是两部分分开存储。 对于第一种情况，malloc分配内存的空间图如下： 12345678____ The allocated block ____/ \\+--------+--------------------+| Header | Your data area ... |+--------+--------------------+ ^ | +-- The address you are given 对于上述情况，malloc中内存转换实现方式为：123456/* The corresponding word size */#define SIZE_SZ (sizeof(INTERNAL_SIZE_T)).../* conversion from malloc headers to user pointers, and back */#define chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ))#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ)) 如上源码我们可以看出来，chunk2mem将原始指针转换为user_data的指针，mem2chunk做了相反的转换。这个时候free的实现为： 1234void free(void* mem) &#123; p = mem2chunk(mem); // Now that you know how large is chunk \"p\", go ahead and free the chunk.&#125; 同时，我们通过实验可以推测，标准库对void*的operator=做了重载。123456789101112#include &lt;iostream&gt;int main() &#123; int *a = (int*)malloc(sizeof(int)); int *b = (int*)malloc(sizeof(int)); short *c = (short*)malloc(sizeof(short)); std::cout &lt;&lt; a &lt;&lt; std::endl &lt;&lt; b &lt;&lt; std::endl &lt;&lt; c &lt;&lt; std::endl; std::cout &lt;&lt; b - a &lt;&lt; std::endl; std::cout &lt;&lt; reinterpret_cast&lt;size_t&gt;(b) - reinterpret_cast&lt;size_t&gt;(a) &lt;&lt; std::endl;&#125; 输出结果为:123450x10b5c200x10b5c400x10b5c60832 参考: https://www.quora.com/How-does-free-function-in-C-knows-how-much-memory-to-be-released-deallocate http://stackoverflow.com/questions/1518711/how-does-free-know-how-much-to-free","raw":null,"content":null,"categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"why assigment operator can not be frined function","slug":"why-assigment-operator-can-not-be-frined-function","date":"2017-03-21T06:30:41.000Z","updated":"2017-03-21T06:31:31.856Z","comments":true,"path":"2017/03/21/why-assigment-operator-can-not-be-frined-function/","link":"","permalink":"http://yoursite.com/2017/03/21/why-assigment-operator-can-not-be-frined-function/","excerpt":"","text":"why assigment operator can not be frined this is a problem in my work and I have find th solution on stackoverflow,so recorder here problem descriptionWhen I refactor my object, I have a problem which need to change the return valueof and function std::string to a struct data, but I don’t want to change my codewhere the function be used, so I want to overload the assignment operator whichwill assign a struct to string.The code is as follows: 1234567891011121314151617181920#include &lt;string&gt;class data_struct&#123; friend std::string operator = (std::string&amp; s, data_struct&amp; d);private: bool success&#123;false&#125;; std::string message&#123;\"\"&#125;;public: data_struct(bool t_success, std::string t_message): success(t_success), message(t_message) &#123;&#125;&#125;std::string operator = (std::string&amp; s, data_struct&amp; d) &#123; s = d.s; return s;&#125;int main() &#123; data_struct d(false,\"haha\"); std::string s = d;&#125; when I compile this file , this is an error follows: 123456789main.cpp:3:64: error: ‘std::__cxx11::string operator=(std::__cxx11::string&amp;, data_struct&amp;)’ must be a nonstatic member function friend std::string operator = (std::string&amp; s, data_struct&amp; d); ^main.cpp:12:13: error: expected initializer before ‘operator’ std::string operator = (std::string&amp; s, data_struct&amp; d) &#123; ^main.cpp: In function ‘int main()’:main.cpp:19:19: error: conversion from ‘data_struct’ to non-scalar type ‘std::__cxx11::string &#123;aka std::__cxx11::basic_string&lt;char&gt;&#125;’ requested std::string s = d; why does this happen?Firstly, it should be noted that this has nothing to do with the operator being implemented as a friend specifically. It is really about implementing the copy-assignment as a member function or as a non-member (standalone) function. Whether that standalone function is going to be a friend or not is completely irrelevant: it might be, it might not be, depending on what it wants to access inside the class. Now, the answer to this question is given in D&amp;E book (The Design and Evolution of C++). The reason for this is that the compiler always declares/defines a member copy-assignment operator for the class (if you don’t declare your own member copy-assignment operator). If the language also allowed declaring copy-assignment operator as a standalone (non-member) function, you could end up with the following 1234567891011121314151617181920212223// Class definitionclass SomeClass &#123; // No copy-assignment operator declared here // so the compiler declares its own implicitly ...&#125;;SomeClass a, b;void foo() &#123; a = b; // The code here will use the compiler-declared copy-assignment for `SomeClass` // because it doesn't know anything about any other copy-assignment operators&#125;// Your standalone assignment operatorSomeClass&amp; operator =(SomeClass&amp; lhs, const SomeClass&amp; rhs);void bar() &#123; a = b; // The code here will use your standalone copy-assigment for `SomeClass` // and not the compiler-declared one&#125; As seen in the above example, the semantics of the copy-assignment would change in the middle of the translation unit - before the declaration of your standalone operator the compiler’s version is used. After the declaration your version is used. The behavior of the program will change depending on where you put the declaration of your standalone copy-assignment operator. This was considered unacceptably dangerous (and it is), so C++ doesn’t allow copy-assignment operator to be declared as a standalone function. It is true that in your particular example, which happens to use a friend function specifically, the operator is declared very early, inside the class definition (since that’s how friends are declared). So, in your case the compiler will, of course, know about the existence of your operator right away. However, from the point of view of C++ language the general issue is not related to friend functions in any way. From the point of view of C++ language it is about member functions vs. non-member functions, and non-member overloading of copy-assignment is just prohibited entirely for the reasons described above. Solutiondue to the solution above is not proper.So I overWrite the orignal function, andinvoke different version in their needed place.","raw":null,"content":null,"categories":[{"name":"C++ problems","slug":"C-problems","permalink":"http://yoursite.com/categories/C-problems/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"工厂类模式家族之简单工厂模式","slug":"工厂类模式家族之简单工厂模式","date":"2017-01-09T08:57:04.000Z","updated":"2017-06-13T13:28:55.240Z","comments":true,"path":"2017/01/09/工厂类模式家族之简单工厂模式/","link":"","permalink":"http://yoursite.com/2017/01/09/工厂类模式家族之简单工厂模式/","excerpt":"","text":"工厂类模式家族之简单工厂模式在面向对象编程的领域，设计模式给我们提供了适合特定场景的软件设计思想，不过大多设计模式都可以通过一般的设计进行替代，但我们为什么还有费工夫去遵循设计模式呢？这就要说到设计模式的精髓了，我们通过对软件系统进行良好的设计，不但可以提高代码的可重用性，增强系统的可扩展性，给客户提供良好的接口，还可以减少编码过程中因代码组织太乱扩展过程中需要修改旧代码而带来的一连串的错误，降低维护成本。软件设计过程我们应该尽量追求符合软件设计的开闭原则。 开闭原则:在面向对象编程领域中，开闭原则规定“软件中的对象(类，模块，函数)应该对于扩展是开放的，但是对于修改是封闭的”。该特性在产品化的环境中是特别有价值的，在这种环境中我们认为一旦类完成，我们可以对它进行扩展改变其行为，但是不允许修改类。也就是说一个类的实现只应该因错误而修改。－－by wiki 工厂模式家族包括三种重要的模式，分别是简单工厂模式，工厂模式以及抽象工厂模式。他们都属于类的创建型模式。创建型模式包括两种，分别是类的创建型模式和对象的创建型模式。类的创建型模式通常使用继承关系，将类的创建交由其具体的子类完成，这样就向外界隐藏了如何得到具体类的实现细节，以及这个类的实例是如何被创建或者组织在一起的。；对象创建型模式通常把一个类的创建委托给另一个对象完成，可以根据语境动态地决定生成哪个具体类的实例。 本节我们来讲解工厂模式中的简单工厂模式。主要包括以下几个部分： 简单工厂模式的实质 简单工厂模式的适用性 简单工厂模式的结构 简单工厂模式的参与者 简单工厂模式各成分之间的交互 实际应用 简单工厂模式的优缺点 简单工厂模式实例代码 简单工厂模式的实质简单工厂模式又称为静态工厂模式。 它的实质是根据客户传递的信息，工厂类通过该信息制造出相应的产品的实例返回给客户。这样我们就做到了客户只是产品的消费者，而真正的创建者是工厂类。 在简单工厂模式中，待被创建的产品通常继承自同一个类。而这个类中包含了具体产品的所有的公共成员和方法。 简单工厂模式的适用性简单工厂模式将对象的创建和对象本身的业务分离开来，降低了系统的耦合度，当维护期间需要对客户代码或者产品代码进行修改的时候，修改其中之一不会影响另一个。 简单工厂模式的结构 简单工厂模式的参与者简单工厂模式中一般有以下几个部分: 工厂类：简单工厂模式的核心，它的作用是根据客户提供的信息创建相应的具体产品 抽象产品：所有具体产品的父类，其中主要包含所有具体产品共有的方法或对象 具体产品：工厂类创建的具体实例。 简单工厂模式各成分之间的交互 客户首先创建factory类(一般为单例模式)， factory类创建成功后，客户调用其createProduct方法，并传入相关信息， 具体产品实例被创建并返回给client,开始进行使用concreteProduct 简单工厂模式的实际应用在实际开发中使用简单工厂模式中，我们可以进行变通的使用。 在实际情况种可能会出现比较复杂的抽象产品和和具体产品之间的关系，这个时候我们依然也可以使用抽象工厂模式: 简单工厂模式的优缺点简单工厂模式的优点: 通过在中间添加一个工厂类，降低产品类和客户代码之间的耦合度；客户在获取产品的时候无需记住所有产品的构造方法，只需要通过同意的工厂类接口进行创建产品，大大提高了效率准确率。 简单工厂模式的缺点：所有的产品实例化的逻辑都在工厂类的一个创建方法中，当需要添加新产品的时候，不得不进行修改factory类，这样就违背了设计的开闭原则(对扩展开放，对修改封闭)；另外当产品类别过多的时候，会出现这个函数冗杂的问题，增加维护成本。最重要的是这个工厂类是所有产品的入口，当它不能工作的时候，所有的产品将陷入瘫痪状态。 简单工厂的实例下面通过形状shape,circle以及rectangle来实现一个简单的简单工厂模式(如有问题，欢迎指正)： 12345678910111213141516171819//factory.hpp#ifndef FACTORY_HPP_#define FACTORY_HPP_#include \"circle.hpp\"#include \"rectangle.hpp\"#include &lt;memory&gt;#include &lt;string&gt;class Factory &#123;private: Factory() &#123;&#125; Factory(const Factory &amp;) = delete; Factory &amp;operator=(const Factory &amp;) = delete;public: static std::shared_ptr&lt;Factory&gt; m_factory; static std::shared_ptr&lt;Factory&gt; getInstance(); static std::shared_ptr&lt;Shape&gt; getShape(const std::string &amp;flag);&#125;;#endif 12345678910111213141516171819//factory.cpp#include \"factory.hpp\"std::shared_ptr&lt;Factory&gt; Factory::m_factory = nullptr;std::shared_ptr&lt;Factory&gt; Factory::getInstance() &#123; if (m_factory == nullptr) &#123; m_factory = std::unique_ptr&lt;Factory&gt;(new Factory()); &#125; return m_factory;&#125;std::shared_ptr&lt;Shape&gt; Factory::getShape(const std::string &amp;flag) &#123; if (0 == flag.compare(\"circle\")) &#123; return std::shared_ptr&lt;Shape&gt;(new Circle()); &#125; else if (0 == flag.compare(\"rectangle\")) &#123; return std::shared_ptr&lt;Shape&gt;(new Rectangle()); &#125;&#125; 12345678910//shape.hpp#ifndef SHAPE_HPP_#define SHAPE_HPP_#include &lt;iostream&gt;class Shape &#123;public: virtual void draw() = 0; virtual double getArea() = 0;&#125;;#endif 12345678910111213141516//circle.hpp#ifndef CIRCLE_HPP#define CIRCLE_HPP#include \"shape.hpp\"class Circle : public Shape &#123;public: Circle(double t_radius = 0) : m_radius(t_radius) &#123;&#125; virtual void draw() &#123; std::cout &lt;&lt; \"this is a circle, the radius is : \" &lt;&lt; m_radius &lt;&lt; std::endl; &#125;; virtual double getArea() &#123; return m_radius * m_radius * 3.14; &#125;private: double m_radius;&#125;;#endif 123456789101112131415161718//rectangle.hpp#ifndef RECTANGLE_HPP_#define RECTANGLE_HPP_#include \"shape.hpp\"class Rectangle : public Shape &#123;public: Rectangle(int a = 0, int b = 0) : m_height(a), m_width(b) &#123;&#125; virtual void draw() &#123; std::cout &lt;&lt; \"this is a rectangle\\n height: \" &lt;&lt; m_height &lt;&lt; \"\\nwidth:\" &lt;&lt; m_width &lt;&lt; std::endl; &#125; virtual double getArea() &#123; return m_height * m_width; &#125;private: int m_height; int m_width;&#125;;#endif 12345678910111213//main.cpp#include \"circle.hpp\"#include \"factory.hpp\"#include \"rectangle.hpp\"int main() &#123; std::shared_ptr&lt;Factory&gt; t = Factory::getInstance(); std::shared_ptr&lt;Shape&gt; c = t-&gt;getShape(\"circle\"); c-&gt;draw(); std::cout &lt;&lt; \"the area is: \" &lt;&lt; c-&gt;getArea() &lt;&lt; std::endl; std::shared_ptr&lt;Shape&gt; r = t-&gt;getShape(\"rectangle\"); r-&gt;draw(); std::cout &lt;&lt; \"the area is :\" &lt;&lt; r-&gt;getArea() &lt;&lt; std::endl;&#125;","raw":null,"content":null,"categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"简单工厂方法","slug":"简单工厂方法","permalink":"http://yoursite.com/tags/简单工厂方法/"}]},{"title":"GRASP设计原则（职责分配原则）","slug":"GRASP设计原则（职责分配原则）","date":"2017-01-08T11:45:46.000Z","updated":"2017-01-08T11:47:09.435Z","comments":true,"path":"2017/01/08/GRASP设计原则（职责分配原则）/","link":"","permalink":"http://yoursite.com/2017/01/08/GRASP设计原则（职责分配原则）/","excerpt":"","text":"GRASP设计原则（职责分配原则）GRASP(General responsibility assignment software Principle)设计原则是设计模式的基础,在GOF的23中设计模式中处处可以体现其中的一个或多个设计原则，所以在掌握设计模式之前需要对GRASP原则有一定的了解，本节我在这里总结一下grasp原则。 本文共分为以下几个内容： GRASP的九个原则 GRASP原则详解 GRASP原则在23中设计模式中的体现 GRASP的九个原则 信息专家原则(information) 创造者原则(creator) 低耦合原则(low coupling) 高内聚原则(high cohesion) 控制器原则(controller) 多态原则(polymorphism) 纯虚构(pure Fabrication) 中介原则(indirect) 受保护变量原则(protected Variations) Grasp原则详解信息专家原则(information expert)信息专家模式的本质指的是我们应该将职责委托给哪一个对象，这个职责可以是一个方法，也可以是一个算法或者其他内容。它是面向过程设计过程中最基本的原则。 委托原则:我们在设计对象的时候，如果某个对象拥有完成某个职责所需要的所有信息，那么这个职责就分配给这个对象实现。这个时候，这个类就是相对于这个职责的信息专家。 示例：我们在设计购物网站的时候，为避免重复，一种商品只能在购物车中出现一次，如果多次出现，则需要将其数量增加。这个时候我们在将物品放入购物车的时候，要首先判断当前物品是否在购物车中，判断两个物品是否为同一个物品的方法这个职责应该委托给谁呢？显而易见，商品类中有唯一标识，所以这个职责由商品类实现，而不是购物车。 创造者原则(creator)creator原则的本质是创建类对象职责应该委托给那个对象，也就是谁应该负责产生某个类的实例。 解决方案: 如果符合下面的一个或者多个条件，则可以将创建A的实例的职责分配给B; B包含A B聚合A B拥有初始化A的数据并在创建A的实例时将数据传递给A B记录A的实例 B频发使用A 满足上述一种或者多种情况的时候，我们应该奖创建A的实例的职责分配给B。 合理的creator原则带来的优点：如果职责分配合理，设计就能降低耦合，提高设计的清晰度，封装性和重用性。 示例:例如订单和商品的关系是聚合关系，这个时候我们将在订单中创建商品。 低耦合(Low coupling)耦合是评价一个系统中各个元素之间连接或者依赖关系强弱的尺度。低耦合的原则是我们在设计系统的时候尽量降低系统中各个元素之间的耦合度，这样对于系统的理解和维护都有很大的益处。 耦合性高的系统会带来的坏处: 一个类的修改导致其他类产生较大的影响； 系统难以维护和理解； 系统的重用性差，在重用一个高耦合类的时候，不得不重用它所依赖的所有类。 两个类具有以下特性中的其中一个，我们就说这两个类是耦合的： A具有一个类型为B的属性； A调用B的方法 A的方法包含对B的引用(参数或者返回值的方式) A是B的直接或者间接的子类 A是接口B的一种实现 低耦合系统的设计方法： 在类的划分上，尽量创建松耦合的类，类之间的耦合性越低，越有利于复用，修改一个类不会影响其他类。 在类的设计上，尽量降低类中成员和方法的访问权限。 在类的设计上，尽量将类设计为不变类 在类的引用上，将一个对象对另一个对象的引用降低到最小 高内聚(high cohesion)内聚是评价一个对象的职责被关联的尺度或者强弱，也可以说是功能性内聚的职责。也就是功能性紧密的相关职责应该放在同一个类中，并共同完成有限的功能。这样做更加有利于对类的理解和重用，也可以降低类的维护成本。 往往低内聚的系统设计会导致类的混乱，当对功能进行扩展或者改进的时候带来不必要的麻烦，低内聚的类也不利于重用，因为他们的职责如此之混乱。 为了达到高内聚，我们需要对类的职责进行分解，使分解出来的类具有独立的职责，满足单一职责原则。将一些需要在多个类中使用到的方法封装到一个类中，其他的类只负责他们需要负责的相关功能，这样我们可以提高类的内聚程度。 控制器原则(controller)控制器模式的实质是将一些系统事件的接受和处理委托给一个的对象controller，这个对象可以是一个类，系统或者子系统，它不与UI进行交互，它只负责系统信息的接收和处理。 一般情况下，控制器是一个系统，这个系统中包括多个处理器，分别对应处理不同的事务。通常情况下，一个控制器应当把要完成的功能委托给其他对象，而它只负责任务的协调控制和分配。 控制器原则与MVC模式相对应，MVC模式是一种比设计模式更高的架构模式。 多态原则(polymorphism)多态原则与面向对象设计原则中的多态概念类似，这里不再详细赘述。 纯虚构(pure Fabrication)纯虚构原则与我们所说的纯虚函数类似。 纯虚构的作用是用来解决高内聚和低耦合之间的矛盾的。高内聚低耦合是我们系统设计的终极目标，高内聚意味着我们要将类拆分成多个功能集中的类，但是拆分的多个类之间需要进行协作才能正常工作，这样又增加了类之间的耦合性。 纯虚构原则是用来解决上述问题的方案。它要求将一部分类的职责转移到纯虚构类中，在理想的情况下，分配给这种虚构类的职责是为了达到高内聚低耦合的效果。在实际的操作过程中，纯虚构类的实现又很多种方式，例如将数据库中操作的方法从数据库实体中分离出来，形成专门的数据访问类；通过对类的分解来实现类的重用，新增加的数据访问类对应于数据的持久化存储，这是软件开发过程中为了方便虚构出来的一个概念。一般情况下，纯虚构模式通常基于功能进行划分的。 中介模式(indirect)中介模式的目的是为了避免两个对象之间产生直接耦合，降低对象之间的耦合度。 解决方案是建立中间对象来协调两个对象之间的交互，避免耦合性过高。 受保护模式(protected variations)受保护模式的实质与OCP(开放闭合原则)类似，我们首先找到系统中不稳定的变化点，使用统一的接口封装起来，如果未来发生变化的时候，可以通过扩展接口来扩展新的功能，而不需要改变旧的代码。这样达到易于扩展的目的。","raw":null,"content":null,"categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"grasp","slug":"grasp","permalink":"http://yoursite.com/tags/grasp/"}]},{"title":"创建型设计模式之build模式","slug":"创建型设计模式之build模式","date":"2017-01-07T17:36:19.000Z","updated":"2017-06-13T13:28:30.924Z","comments":true,"path":"2017/01/08/创建型设计模式之build模式/","link":"","permalink":"http://yoursite.com/2017/01/08/创建型设计模式之build模式/","excerpt":"","text":"创建型设计模式之build模式最近在读《设计模式-可复用面向对象软件设计的基础》一书，在阅读的过程中我会结合书中的相关知识和实例以及在网络上的博客对相关的模式的理解进行总结，并在此基础上加入自己的一些理解，总结模式中需要注意的一些点，记录在此博客，以供大家交流分享，同时防止自己对内容遗忘，如有不正确指出，欢迎批评指正。 本节的主要内容是设计模式中的创建型模式之一:builder模式 要用好builder模式，必须对其机制了解透彻，将该模式用在合适的软件中才能显出它真正的威力，第五部分中实例将为您展示它的真正威力。 本文内容分为以下几个方面: builder模式的意图 builder模式的适用性 builder模式的结构(通用UML类图)及详解 builder模式中的参与者 builder模式中各个成分之间的交互 builder模式比较好的一个实例 builder模式使用过程中注意的点 KFC套餐实例代码 builder模式的精髓都隐藏于builder模式的意图和实用性中，让你真正理解这两个方面，可以说你已经掌握了builder模式（以下意图和模式都摘自《设计模式》书中） builder模式的意图builder模式的意图是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 builder模式的适用性 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 提前记录一下:装配的工作是由导向器(director)完成的，复杂对象的创建是由具体的建造器完成(concreteBuilder)，这里不明白没问题，等你看完全文再过来看这里你就理解了。 当且仅当上面两个条件均满足的情况下我们要使用builder模式（完全理解这两条不一件重要的事情，但是不要着急,当你读完这篇文章的时候就会拨开它的庐山真面目了） builder模式的结构(UML类图)及详解builder模式的UML类图关系如下: 注意的问题: 在builder中一般不声明纯虚函数，而是把它们定义为空方法，这使客户只重定义他们感兴趣的操作。 在director中，注意我们不是把所有的buildPart都去执行一次，而是根据需要的客户的需求，进行定制的去buildPart部分构建，可以构建一次，也可以构建多次。 一般将m_product声明为protected成员，因为这样既保证了封装性，又能使得concreteBuilder能够正常操作product； builder模式种的参与者从上面的类图中我们也可以看出,在builder模式中的参与者有以下四种,以及他们的职责分别是:(此处为个人理解，与书中内容可能不一致,如果有问题欢迎指正) Director: 负责装配product的各个部件，使用Builder的类方法进行实现。它的作用是隔离了客户与product的具体生产过程；并负责控制product的生产过程。 Builder: 为创建一个product对象的各个部件指定抽象接口。一般情况下默认builderPart的操作默认为空。 concreteBuilder: 具体实现每一个部件的具体的复杂生产过程，如buildPartA()的具体实现，并提供一个检索产品的接口。 Product: 这个争议不大，即为被构造的复杂对象。此类对象会有不同的表示。 builder模式各个成分之间的交互方式先上一张时序图: 从上面的时序图可以分析出，各个成分之间的交互方式如下: 客户首先创建一个concreteBuilder对象,然后创建一个Director, 创建结束之后，使用concreteBuilder修饰对象Director, 然后调用Director的construct()方法，进行构造Product, 最后客户通过concreteBuilder的getResult()方法取回生成的Product builder模式中一个较好的实例两个实例来自网络对两本书籍实例的纠正,改编 上面这篇文章深刻的分析了builder模式的本质以及诸多误区的分析，收益颇多，在此感谢博主分享。 在本例中,设备(Equipment)是一个复杂对象，由一个machine和一个或多个输入端口(InputPort)或者输出端口(outputPort)组成；其中输入或输出端口可能有不同的类型(ordinary和super)。现在要你设计一个生成不同型号的产品，要求产品可能包含一进一出(普通或super)，一进两出(普通或super)。 在设计中,我们首先定义一个LCDFactory对象充当director，一个设备生成器(EQPBuilder),相当于Builder。 ​ 首先ordinary和super是port的内部实现方式不同，所以我们需要定义两个具体类，即 ordinaryEQPBuilder和superEQPBuilder。 ​ 在EQPbuilder中，我们将定义四个函数，分别是:buildMachine(), addInputPort(), addOutputPort()和getEQP()。两个concrete类继承EQPBuilder。 ​ 当我们需要获取不同数目的port的设备，这属于组装方面的范畴，所以我们将在LCDFactory中的createEQP中做。其UML类图如下: builder模式在使用的过程中需要注意的问题这里所说的注意的问题可能上面已经提到了，但是这里还是要着重强调一下，因为我们稍不注意，就可能将模式滥用，导致系统设计的失败。 在builder模式中Builder一定不要定义纯虚函数成员函数，而是定义为空方法的虚函数，这样就可以使得客户可以只定义他们感兴趣的操作。 Director负责装配产品，concreteBuilder负责实现复杂产品部件的具体实现 在Director中调用Builder的buildPart函数的时候，并不是每个函数都被调用，而是根据要生成的product对其选择性调用，可能调用零次，也可能调用多次。 Builder中的m_product声明为protected,即保证对象的封装性，又能让具体类方便的使用。(这是我在写代码的时候的解决方法，如果有更好的将m_product声明为private的解决方法欢迎交流2824759538@qq.com) KFC套餐实例代码这是本人使用KFC服务员生成套餐时的一种模拟，其实实际情况中并不需要使用builder模式，但是这里为了练手强行写成了builder模式，希望大家不要吐槽。 1234567891011121314//KFCWaiter.hpp 注意此处water相当于Director的作用#ifndef KFCWAITER_HPP_#define KFCWAITER_HPP_#include \"MealBuilder.hpp\"class KFCWaiter &#123;public: void setMealBuilder(std::shared_ptr&lt;MealBuilder&gt; t_builder); void construct();private: std::shared_ptr&lt;MealBuilder&gt; m_builder;&#125;;#endif 123456789//KFCWaiter.cpp#include \"KFCWaiter.hpp\"void KFCWaiter::setMealBuilder(std::shared_ptr&lt;MealBuilder&gt; t_builder) &#123; m_builder = t_builder;&#125;void KFCWaiter::construct() &#123; m_builder-&gt;buildFood(); m_builder-&gt;buildDrink();&#125; 123456789101112131415161718192021// Meal.hpp Meal相当于Product#ifndef MEAL_HPP#define MEAL_HPP#include &lt;iostream&gt;#include &lt;string&gt;class Meal &#123;public: Meal(std::string t_food = \"hanbao\", std::string t_drink = \"kele\"); ~Meal(); std::string getFood() const; std::string getDrink() const; void getMeal() const; void buildFood(const std::string &amp;t_food); void buildDrink(const std::string &amp;t_drink);private: std::string m_food; std::string m_drink;&#125;;#endif 1234567891011121314//Meal.cpp#include \"Meal.hpp\"Meal::Meal(std::string t_food, std::string t_drink) : m_food(t_food), m_drink(t_drink) &#123;&#125;Meal::~Meal() &#123;&#125;std::string Meal::getFood() const &#123; return m_food; &#125;std::string Meal::getDrink() const &#123; return m_drink; &#125;void Meal::getMeal() const &#123; std::cout &lt;&lt; \"套餐为:\" &lt;&lt; std::endl &lt;&lt; \"食物:\" &lt;&lt; m_food &lt;&lt; std::endl &lt;&lt; \"饮料:\" &lt;&lt; m_drink &lt;&lt; std::endl;&#125;void Meal::buildFood(const std::string &amp;t_food) &#123; m_food = t_food; &#125;void Meal::buildDrink(const std::string &amp;t_drink) &#123; m_drink = t_drink; &#125; 123456789101112131415161718//MealBuilder.hpp#ifndef BUILDER_HPP#define BUILDER_HPP#include \"Meal.hpp\"#include &lt;memory&gt;#include &lt;string&gt;class MealBuilder &#123;public: MealBuilder(); virtual void buildFood() = 0; virtual void buildDrink() = 0; std::shared_ptr&lt;Meal&gt; getResult(); virtual ~MealBuilder()&#123;&#125;;protected: std::shared_ptr&lt;Meal&gt; m_meal;&#125;;#endif 1234//MealBuilder.cpp#include \"MealBuilder.hpp\"MealBuilder::MealBuilder() : m_meal(std::shared_ptr&lt;Meal&gt;(new Meal())) &#123;&#125;std::shared_ptr&lt;Meal&gt; MealBuilder::getResult() &#123; return m_meal; &#125; 12345678910//MealBuilderA.hpp#ifndef MEALBUILDERA_HPP_#define MEALBUILDERA_HPP_#include \"MealBuilder.hpp\"class MealBuilderA : public MealBuilder &#123;public: virtual void buildFood(); virtual void buildDrink();&#125;;#endif 12345//MealBuilderA.cpp#include \"MealBuilderA.hpp\"void MealBuilderA::buildFood() &#123; m_meal-&gt;buildFood(\"套餐A食物\"); &#125;void MealBuilderA::buildDrink() &#123; m_meal-&gt;buildDrink(\"套餐A饮料\"); &#125; 12345678910//MealBuilderB.hpp#ifndef MEALBUILDERB_HPP_#define MEALBUILDERB_HPP_#include \"MealBuilder.hpp\"class MealBuilderB : public MealBuilder &#123;public: virtual void buildFood(); virtual void buildDrink();&#125;;#endif 12345//MealBuilderB.cpp#include \"MealBuilderB.hpp\"void MealBuilderB::buildFood() &#123; m_meal-&gt;buildFood(\"套餐B食物\"); &#125;void MealBuilderB::buildDrink() &#123; m_meal-&gt;buildDrink(\"套餐B饮料\"); &#125; 1234567891011121314//main.cpp#include \"KFCWaiter.hpp\"#include \"MealBuilderA.hpp\"#include \"MealBuilderB.hpp\"int main() &#123; std::shared_ptr&lt;MealBuilder&gt; Aptr = std::shared_ptr&lt;MealBuilder&gt;(new MealBuilderA()); KFCWaiter k; k.setMealBuilder(Aptr); k.construct(); std::shared_ptr&lt;Meal&gt; current_meal = Aptr-&gt;getResult(); current_meal-&gt;getMeal();&#125;","raw":null,"content":null,"categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"UML时序图详解","slug":"UML时序图详解","date":"2017-01-07T07:17:23.000Z","updated":"2017-06-13T13:27:08.539Z","comments":true,"path":"2017/01/07/UML时序图详解/","link":"","permalink":"http://yoursite.com/2017/01/07/UML时序图详解/","excerpt":"","text":"UML时序图详解 这几天在阅读《设计模式》一书，书中总结了前人在面向对象软件设计过程中针对特定的问题提出的简洁而优雅的解决方案。在阅读的过程中，我一边理解书中给出的实例，一边结合自己写过的项目或者用过的框架与当前模式进行对比，发现之前的项目有一些还是有很大的改进空间。在阅读本书的过程中，书中很多例子都是通过UML类图和UML时序图进行说明，所以，理解这些例子的前提是对UML类图以及UML时序图有一定的了解，UML类图在前面的博客(https://langzi989.github.io/2017/01/05/UML%E5%9B%BE%E8%A1%A8%E7%A4%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/)中已经讲解，现在我们主要来看一下UML时序图中的重要概念。 UML类关系以及时序图在大三上《系统分析与设计》课的时候学过，但是那个时候不知道这东西有什么用，所以没有认真学和理解。随着实战经验的增多，越来越能体会到这些在软件设计的过程中重中之重，不管是描述你的设计思想还是与团队中其他人进行交流。所以还是建议大家在学到这一部分的时候对这门课认真对待。 定义时序图是一种按照时间顺序显示对象之间的交互的图。时序图中显示的是参与交互的对象和对象之间消息传递的顺序。 基本元素时序图中包含的主要的元素有: 角色(Actor) 对象(Object) 生命线(life line) 控制焦点(focus of control) 消息(message) 自关联消息(self-associated message) 组合片段(combined fragment) 基本元素详解角色(actor)角色指的是系统角色，这个角色可以是人，其他系统或者子系统 图形表示: 对象(object)对象包括三种: 指定类名和对象名的对象objectName: className 指定类名但没有对象名的对象(匿名对象) :className 指定对象名但不指定类名的对象 objectName 图形表示：第一类: 第二类: 第三类: 生命线(life line)生命线在时序图中使用向下的虚线表示,它指的是其所对应的对象的存活时间。从上到下表示时间的推后。 图像表示: 控制焦点(focus of control)控制焦点在时序图中以方块的形式出现，它是一种表示时间段的方式，对象在这一时间段中执行相应的操作。 图像表示: 消息(message)消息有三种类型 同步消息：发送者发送请求后被阻塞，直到接受者返回消息或者做完其他处理之后发送者才能继续执行之后的操作 异步消息：发送者发送消息给接受者之后不等待接受者返回响应而继续执行下面的操作。 返回消息:接受者返回消息给发送者 消息的图形表示：同步消息: 异步消息: 返回消息: 自关联消息(self-associated message)自关联消息一般指的是当前类调用自己的函数的情况 组合片段(combined fragment)组合片段中包括四个部分: Alternative fragment(alt表示):与if…then…else…对应 option fragment(opt表示):与switch对应 parallel fragment(par表示):表示同时发生 Loop Fragment(loop表示):与循环对应 图形表示: alt:","raw":null,"content":null,"categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://yoursite.com/tags/UML/"}]},{"title":"UML图表示常见的类之间的关系","slug":"UML图表示常见的类之间的关系","date":"2017-01-05T13:12:28.000Z","updated":"2017-06-13T13:26:20.372Z","comments":true,"path":"2017/01/05/UML图表示常见的类之间的关系/","link":"","permalink":"http://yoursite.com/2017/01/05/UML图表示常见的类之间的关系/","excerpt":"","text":"UML图表示常见的类之间的关系类之间的关系常见的主要包括以下几种: 继承 实现 依赖 关联 聚合 组合 继承（inheritance）继承的概念大家都比较熟悉，他主要指的是派生类继承父类或者接口之间的继承，派生类继承了父类中原有的功能，并在此基础上添加了新的功能。例如public继承实质上是一种is-a的关系,(子类is a 基类) 图形表示: 实现(implement)实现指的是一个类实现一个接口,一个类可以实现一个或者多个接口。实现是类和接口之间常见的一种关系。在java中通常通过implements实现。 图形表示： 依赖依赖指的是一个类A使用另外一个类B,这种该使用关系是偶然性的，临时的，非常弱的一种关系。但是类B的变化会影响到类A;比如人要使用船过河中，这个时候人和船就是一种依赖关系。具体表现在代码中就是B是类A中的某个方法的参数。 图形表示: 关联关联是指俩个类之间的或者类和接口之间的一种强依赖关系。而这种强依赖关系不是偶然性的，而是长期的，而且双方的关系是平等的，关联可以是单向的，也可以是双向的。具体表现在代码中是(1):B以类属性的方式出现在类A中（２）A引用类型为B的全局变量 图形表示: 聚合聚合是关联关系的一种特例，它表现的是一种has-a的关系，即整体与部分的关系，此时整体与部分可以是分离的，他们可以具有各自的声明周期，部分可以属于多个整体对象，也可以被多个整体对象共享；如计算机与CPU的关系聚合中部分和整体都有各自的生命周期，并且互相影响 图形表示： 组合组合也是关联的一种特例，它体现的是一种contain-a的关系，这种关系比聚合强；这个时候整体和部分是不可分离的，整体的声明周期与部分的声明周期相同，当整体的周期结束时，部分的周期也随之结束。如人和大脑的关系 图形表示： 依赖性强弱:组合&gt;聚合&gt;关联&gt;依赖","raw":null,"content":null,"categories":[{"name":"设计模式之路","slug":"设计模式之路","permalink":"http://yoursite.com/categories/设计模式之路/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://yoursite.com/tags/UML/"}]},{"title":"docker防止fork炸弹","slug":"docker防止fork炸弹","date":"2016-12-29T11:00:25.000Z","updated":"2016-12-29T13:01:08.965Z","comments":true,"path":"2016/12/29/docker防止fork炸弹/","link":"","permalink":"http://yoursite.com/2016/12/29/docker防止fork炸弹/","excerpt":"","text":"docker防止fork炸弹在开发过程中，我们使用了docker作为容器来进行编程语言代码的评测，以用于防止有害代码破坏宿主物理机器，但是在昨天发现docker还是会受fork炸弹的影响将宿主物理机器挂掉。针对这个问题，我在docker官网找到了相关的解决方法，记录分享并以备之后再次遇到此类问题可以很快找到解决方案。当前解决方案只适用于docker1.1版本及之后(通过docker.io进行安装,sudo apt install docker.io)。解决方案的思想就是:在启动docker的时候给其加上启动选项–pids-limit来限制cgroup中的fork的进程的最大数，我这里限制的30,可以根据自己的需求去限制。1docker run -it --pids-limit 30 Ubuntu:14.04 上述方法即可防止fork炸弹。以下内容转载自http://blog.csdn.net/thinkhy/article/details/50995720 Docker容器与安全Docker能否大规模用于生产环境，尤其是公有云环境，就在于Docker是否能提供安全的环境。本文将总结《Docker容器与容器云》一书3.9节『Docker与容器安全』的主要内容，包括Docker现有安全机制、存在的安全问题以及Docker安全增强三个方面。 1. Docker的安全机制1.1 Docker daemon安全 Docker向外界服务提供了四种通信方式，默认是以Unix域套接字的方式来与客户端通信，这种方式较TCP形式更为安全。 Docker也提供了TLS传输层安全协议，通过–tlsverify(安全传输校验），–tlscacert(信任证书)、–tlskey(服务器或者客户端秘钥）、–tlscert（证书位置）来配置。1.2 镜像安全 Docker registry镜像库访问控制 Docker daemon第一次启动时，通过公网（Amazon CDN）载入official.json包，饮食公共image和用户image的目录以及数字签名信息。 official.json在Docker daemon启动时加载到MemoryGraph，MemoryGraph用于存储公钥以及命名之间的授权映射，默认授权节点对授权空间有读写权限。 镜像校验和 镜像校验和用来保证镜像的完整性，以预防可能出现的镜像破环。 目前Docker对于镜像校验和和验证失败不采取任何措施，仅输出警告信息1.3 内核安全 内核为容器提供了两种技术cgroup和namespace，分别对容器进行资源限制和资源隔离。 容器本质是进程，cgroup用来限制容器的资源使用量，避免单个容器耗尽系统资源。 namespace用来隔离容器与宿主机，以及不同的容器。 Docker目前仅完整支持uts、ipc、pid、network、mount这5种ns,user ns尚未完全支持。 系统资源未进行隔离，如/proc，/sys、SELinux、time、syslog、/dev设备信息等均未进行隔离。1.4 容器之间的网络安全 Docker可通过iptabls设定规则实现禁止或允许容器之间的通信。1.5 Docker容器Capability限制 容器的行为通过Linux超级用户分组限制，具体包括了CHOWN、DAC_OVERRIDe、FSETID、FOWNER、MKNOD、NET_RAW、SETGID、SETUID、SETFCAP、SETPCAP、NET_BIND_SERVICE、SYS_CHROOT、KILL和AUDIT_WRITE。 Docker进程的Capability可通过docker run命令的参数进行配置2. Docker安全问题2.1 磁盘资源限制问题 Docker容器通过镜像层叠的方式来构建容器内的文件系统，本质上还是在宿主机文件系统的目录(/var/lib/docker)下存储文件。 极有可能出现一个容器将宿主机上所有的磁盘空间耗尽，导致其它容器无法存储文件，所以有必要对容器的磁盘使用量进行限制。2.2 容器逃逸问题 Docker使用操作系统进行虚拟化，共享内核、内存、CPU以及磁盘，易造成容器逃逸问题。 Docker1.0之后采用白名单来限制容器的能力，会给出默认的容器Capability清单，禁止容器拥有清单之外的Capability。2.3 容器DoS攻击与流量限制问题 公有云基于虚拟化技术实现，攻击数据包可能不需要通过物理网卡就可以攻击同一个宿主机下的其他容器，传统Dos预防措施无法适用容器之间的攻击。 的Docker容器连接在网桥上，通过veth pari技术创建网卡，其一端在容器内命名为eth0，另一张网上驻留在宿主机环境之中。 同一宿主机下所有容器共用一张物理网卡，如果一个容器抢占大部分带宽，会影响其它容器使用。2.4 超级权限问题 docker run时加入–privileged参数能使容器获得所有的超级用户权限能力，并将所有的宿主机的所有设备挂载到容器内。3. Docker安全的解决方案3.1 SELinux SELinux三种控制方式 Type Enforcement: 主要的访问控制机制。 Role-Based Access Control(RBAC)：基于SELinux用户的权限控制手段。 Multi-Level Security(MLS): 多级分类安全，指定level标签。 为什么要在Docker中使用SELinux SELinux将所有进程和文件打上标签，而容器以进程方式运行，所以控制进程如何访问资源，也就是限制容器如何去访问资源。 SELinux策略是全局的，它不是针对具体用户设定，而是强制整个系统遵循。 减少提权攻击风险。3.2 user namespace 容器的超级用户权限通过ns映射到宿主机是一个普通用户。 容器被恶意程序攻击，所做的也就是这个普通用户的权限，而非宿主机的超级权限。3.3 磁盘限额 Docker仅对Device Mapper文件系统的限额提供了–storage-opt参数进行限制。 cgroup没有对磁盘进行限制，Linux磁盘限额技术主要基于用户和文件系统。 可能的解决方案 所有用户共有宿主机的一块磁盘，限制用户在磁盘上的使用量来限定容器的磁盘使用量。 选择支持目录限额的文件系统，如XFS。 Docker定期检查每一个容器磁盘使用量，会对性能造成影响。 创建虚拟文件系统，些文件系统仅供某一个容器使用。3.4 容器流量限制 Docker没对容器的网络带宽做限制。 可以采用Traffic Controller容器对容器网卡流量进行限制，一定程序上减少容器Dos攻击危害。3.5 GRSecurity内核安全增强工具 Docker容器共享宿主机的内存，在内存安全上存在不少问题，需要针对内存破坏做防御。 GRSecurity是一个对内核的安全扩展，通过智能访问控制来阻止内存破坏，预防0day漏洞。3.6 fork炸弹 fork炸弹以极快速度创建大量进程，以此消耗系统资源，使系统无法运行新程序，现有进程运行速度放缓。 容器本身在内核层面隔离性不足，fork bomb会给容器带来灾难性影响。 fork bomb受到社区关注（Issue 6479），但目前还没有完美解决方案。 Docker无法使用ulimit来限制forkbomb问题，因为一个宿主机用户可能同时启动多个容器，无法对每个容器做进程数的限制。 总结Docker自身已经提供了不少安全机制，但Docker目前仍然只适于运行可信应用程序（内部使用），如果需要运行任意代码，安全很难得到保证。在日常应用中，还可以通过SELinux、GRSecurity、seccomp等工具来增强容器安全。","raw":null,"content":null,"categories":[{"name":"docker技术","slug":"docker技术","permalink":"http://yoursite.com/categories/docker技术/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"time命令详解","slug":"time命令详解","date":"2016-12-27T13:18:33.000Z","updated":"2016-12-27T15:19:33.189Z","comments":true,"path":"2016/12/27/time命令详解/","link":"","permalink":"http://yoursite.com/2016/12/27/time命令详解/","excerpt":"","text":"Linux time命令详解参考:http://blog.he96.com/2011/01/linux-timewhat-do-real-user-and-sys.html real,user,sys我们常用linux中的time命令计算某个程序的运行耗时，用户态CPU耗时，系统态COU耗时。例如:1234time fooreal 0m0.020suser 0m0.020ssys 0m0.000s 现在我们探讨一下上述三个时间分别代表的含义: real: 表示a.out程序的实际的运行耗时，也就是在a.out运行开始时刻你看了一下手表，a.out运行结束时刻看了一眼手表，两次时间的差值就是real的值。例如使用time sleep 2的时候real值为2 user: a.out运行在用户态CPU的时间 sys: a.out运行在核心态CPU的时间 用户态和核心态然后我们讲一下用户态和核心态： 核心态(kernal mode): 在内核态，代码拥有完全的，不受任何限制的访问底层硬件的能力。可以执行任意的CPU指令，访问任意的内存地址。内核态通常情况下，都是为哪些最底层的，由操作系统提供的，可信可靠耳朵代码来运行的。内核态崩溃将是灾难性的，它会影响到整个系统。 用户态(User mode):在用户态，代码不具备直接访问底层硬件或者内存的能力，而必须借助操作系统提供的可靠的,底层的API来访问硬件或者内存。由于这种隔离带来的保护作用，用户态代码崩溃，操作系统可以正常恢复。我们大多数代码是运行在用户态。 区分内核态和用户态的作用:隔离保护，使得系统更稳定。使用这三个时间我们可以计算当前程序CPU的使用率：CPU Usage = (user + sys) / real_time 常见误区 realtime = user + sys realtime &gt; user + sys由于有一些程序需要等待I/O等导致realtime与user+sys不相等当在多核CPU的情况下第二种情况不成立","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"C++前置声明","slug":"C-前置声明","date":"2016-12-22T14:08:31.000Z","updated":"2016-12-22T16:10:28.499Z","comments":true,"path":"2016/12/22/C-前置声明/","link":"","permalink":"http://yoursite.com/2016/12/22/C-前置声明/","excerpt":"","text":"C++前置声明以个人理解，C++的前置声明的意思是在类定义之前对其进行声明。它在现实编程的场景中可以解决很多问题。比如解决两个类相互依赖的问题，降低类之间的编译依存关系等等。 实际场景我们分别定义一个锁(Lock)和钥匙(Key)的类(默认一把钥匙只能开一把锁，一把锁只能被一把钥匙打开)。代码如下：Lock.hpp12345678#include \"Key.hpp\"class Lock &#123; public: Lock(); virtual ~Lock(); private: Key m_key;&#125; Key.hpp12345678#include \"Lock.hpp\"class Key &#123; public: Key(); virtual ~Key(); private: m_lock;&#125; 这个时候出现了两个类相互包含的情况，因为在编译Lock.cpp的时候，我们需要去查看Key的定义，于是去定义Key,在Key中需要Lock的定义，于是又去构造Lock,这样下去，就出现了一个无限循环包含的情况，有些编译器会直接编译错误，而其他编译器会无限包含下去。这该怎么办呢？有办法，C++为我们提供了前置声明。前置声明是什么？就这个例子来讲，我们要造一把锁，光有锁不行啊，我们还得有能打开这把锁的钥匙。但是锁还没有造好，总不能先打造钥匙吧，钥匙的形状我定了，改天在造。先把锁造好，造锁的时候我要先给要是留一个位置，等锁造好了，我再决定造什么样的钥匙。前置声明就是我在声明一个类(Lock)的时候,用到了另外一个类（Key）的定义，但是Key还没定义呢，而且我先不需要Key的定义，只需要直到Key是一个类就好了。那好，我就先声明类Key,告诉编译器Key是一个类(不需要包含Key.hpp)1class Key; 然后在Lock中用到Key的时候，都用指针或者引用代替(因为指针是固定大小的，但Key的大小只有知道了Key的定义才能确定)。然后上面的代码就可以改造为如下： Lock.hpp12345678class Key;class Lock&#123; private: Key *mp_key; public: Lock(); virtual ~Lock();&#125;; Key.hpp12345678class Lock;class Key &#123; private: Lock* mp_lock; public: Key(); virtual ~Key();&#125; 前置声明注意的问题必须使用前置声明的指针或引用形式在需要使用前置声明的文件中，不可以使用类的定义式，因为类的定义式只有在类定义之后才能获取，这个时候类还没有定义，所以会出错。另一个类在构造的时候编译器是需要计算该对象所占的字节的大小给其分配内存的，但是如果使用类的定义式，这个时候类还未定义，所以无法计算其大小，所以只能使用指针或者引用的形式进行引用。 避免在Lock中使用Key的方法避免在Key定义之前调用Key的析构函数","raw":null,"content":null,"categories":[{"name":"C++学习","slug":"C-学习","permalink":"http://yoursite.com/categories/C-学习/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"条款27:尽量少做转型动作","slug":"条款27-尽量少做转型动作","date":"2016-12-21T12:57:15.000Z","updated":"2016-12-21T14:28:46.924Z","comments":true,"path":"2016/12/21/条款27-尽量少做转型动作/","link":"","permalink":"http://yoursite.com/2016/12/21/条款27-尽量少做转型动作/","excerpt":"","text":"条款27:尽量少做转型动作(Effective C++)C++规则设计的目标之一是，保证类型错误决不可能发生。理论上如果你的程序很干净的通过编译，就表示它并不企图在任何对象身上执行任何不安全，无意义，愚蠢荒谬的操作。这是一个及其具有价值的保证，不要轻易放弃它。但是在很多种情况下，我们不得不进行转型操作，转型操作破坏了类型系统。这可能会导致任何可能种类的麻烦，有些容易辨识，但是有些可能会很隐晦。所以在需要进行转型操作的时候一定要慎重，尽量通过设计避免不必要的转型操作。 类型转换的形式首先我们回顾一下类型转换的语法，因为通常有三种不同的形式，可写出相同的类型转换动作。 C风格类型转换： (T)expression //将expression转换为类型T 函数式风格类型转换： T(expression) //同上上面的两种形式并无差别，纯粹只是把小括号摆放的位置不同而已，我们称上述两种转为为”旧式转型”(old style cast)。 C++还提供四中新式转型(new style): const_cast&lt; T &gt;(expression) dynamic_cast&lt; T &gt;(expression) reinterpret_cast&lt; T &gt;(expression) static_cast&lt; T &gt;(expression) const_cast通常被用来将对象的常量性移除(cast away the constness)。它也是唯一有此能力的C++-style转型操作符。 dynamic_cast主要用来执行类型向下转型(safe downcasting),也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一一个可能耗费重大运行成本的转型动作。 reinterpret_cast 意图执行低级转型，实际动作及结果可能取决于编译器。这也就表示它不可移植，例如将一个pointer to int 转型为int。这一类型转换在低级代码以外很少见。 static_cast 用来强迫隐式转换(implicit conversion)，例如将non-const对象转换为const对象，或者将int转换为double等等。也可以用来执行上述多种转换的反向转换,例如将void指针转换为type指针，将pointer to derive 转化为point to bas。但是无法将const转换为non-const。 dynamic_cast与static_cast详解 static_cast是用来强迫隐式类型转换，它可以用于1.基本数据类型以及指针之间的转换；2.类层次中基类与子类成员函数指针的转换；3.类层次结构中基类与子类指针或者引用之间的转换。 dynamic_cast可以用于1.继承关系中类指针或者引用之间的转换；2.包含虚函数之间对象指针的转换3.以及保证转换的安全性。 static_cast用于基本数据类型转换和指针之间的转换12345678char a;int b = static_cast&lt;int&gt;(a);char c = static_cast&lt;char&gt;(b);char *pa = NULL;int *pb = (int*)pa;pb = static_cast&lt;int*&gt;(pa); //编译错误static_cast只能用于void指针和type指针之间的转换void *pv = static_cast&lt;void*&gt;(pa); //正确pb = static_cast&lt;int*&gt;(pv); 类层次中基类与子类成员函数指针的转换12345678910111213141516171819202122class base &#123;public: base(int t_data) : m_data(t_data) &#123;&#125; void printData() &#123; std::cout &lt;&lt; m_data &lt;&lt; std::endl; &#125;private: int m_data;&#125;;class child : public base &#123;public: child(int t_data) : base(t_data) &#123;&#125; void printData() &#123; std::cout &lt;&lt; \"this is in the child\" &lt;&lt; std::endl; &#125;&#125;;typedef void (base::*basefun)();int main() &#123; base a(10); basefun func = &amp;base::printData; func = static_cast&lt;basefun&gt;(&amp;child::printData); (a.*func)(); //this is in the child&#125; 类层次结构中基类与子类指针或者引用之间的转换上行转换:子类指针或引用转换为基类的指针或引用 —安全下行转换:基类的指针或者引用转换为子类的指针或引用 —危险(避免这样做)123456789101112131415161718192021222324252627282930class A&#123;&#125;;class B:public A&#123;&#125;;class C:public A&#123;&#125;;class D&#123;&#125;;A objA;B objB;A* pObjA = new A();B* pObjB = new B();C* pObjC = new C();D* pObjD = new D();objA = static_cast&lt;A&amp;&gt;(objB); //转换为基类引用 objA = static_cast&lt;A&gt;(objB);objB = static_cast&lt;B&gt;(objA); //error 不能进行转换 pObjA = pObjB; //right 基类指针指向子类对象//objB = objA; //error 子类指针指向基类对象pObjA = static_cast&lt;A*&gt;(pObjB); //right 基类指针指向子类pObjB = static_cast&lt;B*&gt;(pObjA); //强制转换 OK 基类到子类//pObjC = static_cast&lt;C*&gt;(pObjB); //error 继承于统一类的派生指针之间转换//pObjD = static_cast&lt;D*&gt;(pObjC); //error 两个无关联之间转换 dynamic_cast继承关系的类指针对象或者引用之间的转换若积累中没有虚函数，使用dynamic_cast可以将子类的指针或引用转换为基类的指针或引用，与static_cast用法相同，不同的是,这个时候使用dynamic_cast将基类指针转换为子类指针的时候会出现编译错误(static_cast不会，但是很危险)。12345678910111213141516171819202122232425262728class A&#123;&#125;;class B:public A&#123;&#125;;class C:public A&#123;&#125;;class D&#123;&#125;;A objA;B objB;A* pObjA = new A();B* pObjB = new B();C* pObjC = new C();D* pObjD = new D();//objA = dynamic_cast&lt;A&gt;(objB); //error 非引用objA = dynamic_cast&lt;A&amp;&gt;(objB);//objB = dynamic_cast&lt;B&amp;&gt;(objA); //error A 不是多态类型不能转换 若有虚函数则可以进行转换pObjA = dynamic_cast&lt;A*&gt;(pObjB);//pObjB = dynamic_cast&lt;B*&gt;(pObjA); //error A 继承关系 不是多态类型不能转换//pObjB = dynamic_cast&lt;B*&gt;(pObjC); //error C 兄弟关系 不是多态类型不能转换//pObjB = dynamic_cast&lt;B*&gt;(pObjD); //error D 没有关系 不是多态类型不能转换 包含有虚函数之间的对象指针的转换使用dynamic_cast将基类指针转换为子类指针的时候并不是永远有效：只有基类指针本身指向的就是一个派生类对象的时候有效。其他时候结果为NULL;12345678910111213141516171819class A&#123;Public: Virtual ~A()&#123;&#125;&#125;;class B:public A&#123;&#125;;class C:public A&#123;&#125;;class D&#123;Public:Virtual ~D()&#123;&#125;&#125;;pObjB = dynamic_cast&lt;B*&gt;(pObjA); // worning 继承关系 父类具有虚函数 多态pObjB = dynamic_cast&lt;B*&gt;(pObjD); //worning 没有关系 D是多态类型可以转换//以上结果：pObjB == NULL 此处会发生一个运行时错误 dynamic_cast转换的安全性当涉及到基类和派生类对象之间的转换的时候，总使用dynamic_cast会避免很多错误，它是安全的，但是它会给程序运行带来巨大的开销。当子类指针转换为基类指针的时候,两种转型都OK,dynamic_cast开销较大。当基类指针转换为派生类指针的时候，若基类中没有虚函数，static_cast不会报错，但是做法很危险，dynamic_cast编译不通过。当含有虚函数的时候，若基类指针没有指向派生类，这个时候会返回NULL,所以也是安全的。 虚函数对于dynamic_cast转换的作用为什么dynamic_cast转换类指针的时候需要虚函数呢？dynamic_cast转换是在运行时进行转换，运行时转换就需要知道类对象的信息(继承关系等)。在运行时或者这个信息的是虚函数表指针，通过这个指针可以获取到该类对象的所有的虚函数，包括父类的。因为派生类会继承基类的虚函数表，所以通过这个虚函数表，我们就可以知道类对象的父类，在转换的时候就可以用来判断对象有无继承关系。所以虚函数对于正确的基类指针转换为子类指针是非常重要的。 effective的三点建议 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。 如果转型是必要的，试着将它隐藏与某个函数的背后。客户随后可以调用该函数，而不需要将转型放到他们自己的代码中。 宁可使用C++-style转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌","raw":null,"content":null,"categories":[{"name":"effective C++","slug":"effective-C","permalink":"http://yoursite.com/categories/effective-C/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"通过/proc/meminfo实时获取系统内存使用情况","slug":"通过-proc-meminfo实时获取系统内存使用情况","date":"2016-12-19T15:43:49.000Z","updated":"2016-12-19T21:00:44.288Z","comments":true,"path":"2016/12/19/通过-proc-meminfo实时获取系统内存使用情况/","link":"","permalink":"http://yoursite.com/2016/12/19/通过-proc-meminfo实时获取系统内存使用情况/","excerpt":"","text":"通过/proc/meminfo实时获取系统内存使用情况(Linux)linux内核提供了一种通过/proc文件系统来在运行时访问内核内部数据结构，改变内核设置的机制，各种硬件平台上的linux系统的/proc文件系统的基本概念都是相同的。/proc文件系统是一种内核和内核模块用来向进程发送信息的机制。这个伪文件系统可以和内核内部的数据结构进行交互，获取实时的进程信息。注意，/proc文件系统是存储与内存而不是硬盘,/proc虚拟文件系统实质是以文件系统的形式访问内核数据的接口。 /proc/meminfolinux系统中/proc/meminfo这个文件用来记录了系统内存使用的详细情况。其中top，free命令中的数据是通过这个文件中的信息计算并按照特定的格式进行显示。/proc/meminfo内容详解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$cat /proc/meminfoMemTotal: 8052444 kBMemFree: 2754588 kBMemAvailable: 3934252 kBBuffers: 137128 kBCached: 1948128 kBSwapCached: 0 kBActive: 3650920 kBInactive: 1343420 kBActive(anon): 2913304 kBInactive(anon): 727808 kBActive(file): 737616 kBInactive(file): 615612 kBUnevictable: 196 kBMlocked: 196 kBSwapTotal: 8265724 kBSwapFree: 8265724 kBDirty: 104 kBWriteback: 0 kBAnonPages: 2909332 kBMapped: 815524 kBShmem: 732032 kBSlab: 153096 kBSReclaimable: 99684 kBSUnreclaim: 53412 kBKernelStack: 14288 kBPageTables: 62192 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 12291944 kBCommitted_AS: 11398920 kBVmallocTotal: 34359738367 kBVmallocUsed: 0 kBVmallocChunk: 0 kBHardwareCorrupted: 0 kBAnonHugePages: 1380352 kBCmaTotal: 0 kBCmaFree: 0 kBHugePages_Total: 0HugePages_Free: 0HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kBDirectMap4k: 201472 kBDirectMap2M: 5967872 kBDirectMap1G: 3145728 kB 详解： MemTotal: 所有内存(RAM)大小,减去一些预留空间和内核的大小。 MemFree: 完全没有用到的物理内存，lowFree+highFree MemAvailable: 在不使用交换空间的情况下，启动一个新的应用最大可用内存的大小，计算方式：MemFree+Active(file)+Inactive(file)-(watermark+min(watermark,Active(file)+Inactive(file)/2)) Buffers: 块设备所占用的缓存页，包括：直接读写块设备以及文件系统元数据(metadata)，比如superblock使用的缓存页。 Cached: 表示普通文件数据所占用的缓存页。 SwapCached: swap cache中包含的是被确定要swapping换页，但是尚未写入物理交换区的匿名内存页。那些匿名内存页，比如用户进程malloc申请的内存页是没有关联任何文件的，如果发生swapping换页，这类内存会被写入到交换区。 Active: active包含active anon和active file Inactive: inactive包含inactive anon和inactive file Active(anon): anonymous pages（匿名页），用户进程的内存页分为两种：与文件关联的内存页(比如程序文件,数据文件对应的内存页)和与内存无关的内存页（比如进程的堆栈，用malloc申请的内存），前者称为file pages或mapped pages,后者称为匿名页。 Inactive(anon): 见上 Active(file): 见上 Inactive(file): 见上 SwapTotal: 可用的swap空间的总的大小(swap分区在物理内存不够的情况下，把硬盘空间的一部分释放出来，以供当前程序使用) SwapFree: 当前剩余的swap的大小 Dirty: 需要写入磁盘的内存去的大小 Writeback: 正在被写回的内存区的大小 AnonPages: 未映射页的内存的大小 Mapped: 设备和文件等映射的大小 Slab: 内核数据结构slab的大小 SReclaimable: 可回收的slab的大小 SUnreclaim: 不可回收的slab的大小 PageTables: 管理内存页页面的大小 NFS_Unstable: 不稳定页表的大小 VmallocTotal: Vmalloc内存区的大小 VmallocUsed: 已用Vmalloc内存区的大小 VmallocChunk: vmalloc区可用的连续最大快的大小 通过/proc/meminfo实时获取系统内存使用情况http://man.linuxde.net/free目前我们希望实时获取系统中内存的使用情况，实际可以挪用的内存数为free+cache+buffer,实际使用的内存数为used-cache-buffer(total-free-cache-buffer),","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"memory","slug":"memory","permalink":"http://yoursite.com/tags/memory/"}]},{"title":"通过/proc/stat计算linux系统即时CPU使用率","slug":"通过-proc-stat计算linux系统即时CPU使用率","date":"2016-12-18T22:03:09.000Z","updated":"2016-12-18T22:03:35.949Z","comments":true,"path":"2016/12/19/通过-proc-stat计算linux系统即时CPU使用率/","link":"","permalink":"http://yoursite.com/2016/12/19/通过-proc-stat计算linux系统即时CPU使用率/","excerpt":"","text":"通过/proc/stat计算linux系统即时CPU使用率/proc/stat/proc文件系统是一个伪文件系统，它存在于内存中，不占用外存空间。它以文件系统的方式为内核与进程提供通信接口。用户和应用程序可以通过/proc得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程是动态改变的，所以用户或应用程序读取/proc目录中的文件的时，/proc文件系统是动态从系统内核读出所需信息并提交的。在linux或Ubuntu系统中，/proc/stat文件记录了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前的值。我们可以通过一个较小的时间段的CPU利用率值来估算某一个时刻的CPU利用率。首先我们先来查看一下/proc/stat中的内容：123456$ cat /proc/statcpu 15543 334 4963 142337 3413 0 180 0 0 0cpu0 3877 142 1137 35988 615 0 28 0 0 0cpu1 3866 23 1068 35982 608 0 74 0 0 0cpu2 4104 159 1333 35395 735 0 59 0 0 0cpu3 3695 9 1424 34970 1454 0 18 0 0 0 上面的信息中前八个是比较重要的。 user(15543): 从系统启动到当前时刻，处于用户态的时间(用户空间的CPU时间)，不包括nice为负值的进程。 nice(334): 从系统启动到当前时刻，nice值为负的进程所占的CPU时间。 system(4963): 从系统启动到当前时刻，处于内核状态的CPU时间。 idle(142337): 从系统启动到当前时刻，除了I/O等待时间以外的其他等待时间 iowait(3413): ~，IO等待时间 irq(0): ~, 硬中断时间 softrq(180): ~,软中断时间。 steal: ~,在虚拟环境中运行的时间。 总的CPU时间为：total = user+nice+system+idle+iowait+irq+softrq 计算当前时刻的CPU使用率我们使用距离当前时刻较小的间隔的时间段的CPU使用率近似当前时刻的CPU使用率。12CPU Usage=1 - (△idle+△iowait) / △total_time =1 - (idle2+iowait2 - idle1 - iowait1) / (total_time2 - total_time1)","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"linux进程nice值及其与优先级的关系","slug":"linux进程nice值及其与优先级的关系","date":"2016-12-18T20:25:04.000Z","updated":"2016-12-18T20:26:48.601Z","comments":true,"path":"2016/12/19/linux进程nice值及其与优先级的关系/","link":"","permalink":"http://yoursite.com/2016/12/19/linux进程nice值及其与优先级的关系/","excerpt":"","text":"linux进程nice值及其与优先级的关系在linux多任务环境的系统中，系统是根据进程的优先级(priority)给进程进行分配资源。优先级越高的进程越有优先执行的权利。配置进程优先权碎玉linux很有用，可以大大改善系统的性能。还可以把指定的进程运行在指定的cpu上。 nice与priority在linux中使用ps 的-l参数可以对进程的优先权信息进行查看：123456$ ps -l#打印信息:F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD0 S 1000 5242 5232 0 80 0 - 7461 wait pts/1 00:00:00 bash4 T 1000 5881 5242 0 80 0 - 12247 signal pts/1 00:00:01 top4 R 1000 6386 5242 0 80 0 - 8996 - pts/1 00:00:00 ps 从上面可以看出,上表中打印出一些有用的信息： UID: 进程的user id PID: 进程ID PPID: 当前进程的父进程的ID PRI: 优先级(pri越小优先级越高) NI: nice值，当前进程的nice值前三个值比较容易理解，pri和NI的含义，pri比较好理解，即进程的优先级，pri越小，优先级越高，那nice值呢？nice表示进程可被执行的优先级的修正数值。如前面说的，pri越小越优先被执行，那么加入nice之后pri(new)=pri(old)+nice。这样,当nice为负值的时候，该程序的pri变小，优先级越高。 注意:进程的nice值不是进程的优先级，但是会影响进程优先级的变化。 nice相关linux命令nice与renice1.nice的作用是启动时设置nice的值1ice -n -5 ./MatrixJudge &amp; -n参数用于指定nice值2.renice的作用是修改已经存在的进程的nice值1renice -5 -p 10000 上述的意思是将PID为10000的nice值置为-5,-p参数用于指定PID。","raw":null,"content":null,"categories":[{"name":"linux笔记","slug":"linux笔记","permalink":"http://yoursite.com/categories/linux笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"tornado表单与模板","slug":"tornado表单与模板","date":"2016-12-16T15:48:06.000Z","updated":"2016-12-30T14:07:06.063Z","comments":true,"path":"2016/12/16/tornado表单与模板/","link":"","permalink":"http://yoursite.com/2016/12/16/tornado表单与模板/","excerpt":"","text":"tornado表单和模板在第一章中，我们学习了使用tornado创建一个web应用的基础知识。包括处理函数，HTTP方法以及tornado的框架的总体结构。在这一章中，我们学习tornado的更加强大的功能—-表单和模板。和大多数的web框架一样，tornado的一个重要的目标就是帮助你更快地编写程序，尽可能整洁地复用更多的代码。尽管tornado灵活，可以使用几乎所有python支持的模板语言，tornado自身也提供了一个轻量级，快速并且灵活的模板语言，在tornado.template模块中。 简单示例 Poem Maker Propoemmaker.py123456789101112131415161718192021222324252627282930313233import os.pathimport tornado.httpserverimport tornado.optionsimport tornado.webimport tornado.ioloopfrom tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class IndexHandler(tornado.web.RequestHandler): def get(self): self.render(\"index.html\")class PoemPageHandler(tornado.web.RequestHandler): def post(self): noun1 = self.get_argument(\"noun1\") noun2 = self.get_argument(\"noun2\") verb = self.get_argument(\"verb\") noun3 = self.get_argument(\"noun3\") self.render(\"poem.html\", roads=noun1, wood=noun2, made = verb, difference=noun3)if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", IndexHandler), (r\"/poem\", PoemPageHandler)], template_path = os.path.join(os.path.dirname(__file__), \"templates\"), static_path = os.path.join(os.path.dirname(__file__), \"static\")， debug=True) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 除了上述poemmaker.py，还需要在文件夹templates下添加以下两个文件。/templates/index.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;Poem Maker Pro&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Enter terms below.&lt;/h1&gt; &lt;form method=&quot;post&quot; action=&quot;/poem&quot;&gt; &lt;p&gt;Plural noun &lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;noun1&quot; /&gt;&lt;/p&gt; &lt;p&gt;Singular noun&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;noun2&quot; /&gt;&lt;/p&gt; &lt;p&gt;Verb (haha)&lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;verb&quot; /&gt;&lt;/p&gt; &lt;p&gt;Noun&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;noun3&quot; /&gt; &lt;/p&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; /templates/poem.html123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;this is the poem&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Your poem&lt;/h1&gt; &lt;p&gt;Two &#123;&#123;roads&#125;&#125; diverged in a &#123;&#123;wood&#125;&#125;, and I—&lt;br/&gt; I took the one less tracelled by, &lt;br/&gt; and that has &#123;&#123;made&#125;&#125; all the &#123;&#123;difference&#125;&#125;.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 运行python文件:1python poemmaker.py 此时访问8000端口会出现首页上包括多个表单等待用户输入。这个表单包括多个文本域(命名为noun1, noun2等)，其中内容将在用户点击“submit”按钮时以post请求的方式发送到/poem。当点击submit按钮之后，tornado应用跳转到poem.html，插入你在表单中填写的值。结果是显示的一首诗。 下面我们逐条讲述当前示例中的每一个涉及到的知识点： 2.1.1渲染模板从结构上讲，poemmaker和第一章的例子很相似。我们定义了几个RequestHandler子类并把它们传递给tornado.web.Application对象。那么有什么不一样的地方呢？首先我们向Application对象的init方法传递了一个template参数。1template_path = os.path.join(os.path.dirname(__file__), \"templates\") template_path参数告诉tornado在哪里寻找模板文件。我们将在第三章中讲解其确切的用法和性质。而它的基本要点是：模板是一个允许你嵌入python代码片段的html文件。上面的代码告诉python在你的tornado应用文件相同目录下的templates文件夹下寻找模板文件。一旦我们告诉tornado在哪里寻找模板，我们就可以使用RequestHandlser类的render方法来告诉tornado读入模板文件，插入其中的模板代码，并将结果返回给浏览器。比如，在IndexHandler中，我们可以发现语句：1self.render(\"index.html\") 这段代码告诉tornado载templates文件夹下找到一个名字为index.html的文件，读取其中的内容，并发送给浏览器。 2.12 填充实际上index.html完全不能称之为模板，因为它所包含的完全是已经编写好的html标记。这可以是模板一个不错的使用方式。但是在通常情况下我们更希望html输出可以结合我们的程序传入给模板的值。模板poem.html使用PoemPageMaker渲染，它是一个模板。我们可以看到，在poem.html中，它可以看到模板中有一些被双大括号括起来的字符串，就像这样：123&lt;p&gt;Two &#123;&#123;roads&#125;&#125; diverged in a &#123;&#123;wood&#125;&#125;, and I—&lt;br/&gt;I took the one less tracelled by, &lt;br/&gt;and that has &#123;&#123;made&#125;&#125; all the &#123;&#123;difference&#125;&#125;.&lt;/p&gt; 在双大括号中的单词是占位符，当我们渲染模板时希望以实际值代替。我们可以使用render函数中传递关键字参数的方法 指定什么值将被填充到html文件中的对应位置，其中关键字对应模板文件中占位符的名字。下面是在poemPageMaker中相应的代码部分：12345noun1 = self.get_argument(\"noun1\")noun2 = self.get_argument(\"noun2\")verb = self.get_argument(\"verb\")noun3 = self.get_argument(\"noun3\")self.render(\"poem.html\", roads=noun1, wood=noun2, made = verb, difference=noun3) 在这里，我们告诉模板使用变量noun1作为模板中roads的值，以此类推。 2.13 设置静态路径你可以通过向Application类的构造函数传递一个名为static_path的参数来告诉tornado从文件系统一个特定的位置提供静态文件。在上述代码中如下：1static_path = os.path.join(os.path.dirname(__file__), \"static\")) 在这里，我们设置了一个当前应用目录下名为static的子目录作为static_path的参数。应用将读取static中的文件作为静态文件 2.1.4使用static_url生成urltornado模板提供了一个叫做static_url的函数生成static目录下文件的url.让我们来看看在index.html中static_url的调用代码的示例代码：1&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123;static_url(&quot;style.css&quot;)&#125;&#125;&quot;&gt; 这个对static_url的调用生成了url的值，并渲染出类似下面的代码：1&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/style.css?v=ab12&gt; 那么为什么使用static_url而不是在你的模板中硬编码呢？原因有以下两点：第一，static_url函数创建了一个基于文件内容的hash值，并将其添加到url末尾(查询字符串的参数是v).这个hash值确保浏览器总是加载一个文件的最新版本而不是以前的缓存版本。无论是在开发阶段还是部署到生产环境，都非常有用，因为用户不必为了可到你的静态内容去清除浏览器的缓存了。第二，你可以改变你的url结构，而不用改变模板中的代码。例如，你可以配置tornado响应来自路径/s/filename的请求时提供静态内容，而不是默认的/static路径。如果你使用static_url而不是硬编码，这个时候你不需要改变代码中的值。 debug参数在这个例子中，你可能注意到了debug=True的使用。它调用了一个便利的测试模块:tornado.autoreload模块，此时，一旦主要的python文件被修改，tornado会尝试重启服务器，而且载模板改变的时候会自动刷新。对于快速改变和实时更新这非常棒，但不要在生产上使用它，因为他将防止tornado缓存模板。 2.2模板语法既然我们已经看到了一个模板在实际应用中的例子，哪买让我们深入了解它们是如何工作的。tornado模板是被python表达式和控制语句标记的简单文本文件。tornado的语法非常直接。在2.1节中，我们展示了如何在一个web应用中使用render方法传送html给浏览器。你可以在tornado应用之外使用python解释器导入模块尝试模板系统，此时结果会被直接输出出来。1234&gt;&gt;&gt; from tornado.template import Template&gt;&gt;&gt; content = Template(\"&lt;html&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123;header&#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\")&gt;&gt;&gt; print content.generate(header=\"Welcome!\")&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 2.21填充表达式上面的演示我们也可以看出，向html中填充python变量的值，我们可以使用双大括号；其实我们可以在双大括号中插入python表达式，它会自动计算出其实际值：1234567&gt;&gt;&gt; from tornado.template import Template&gt;&gt;&gt; print Template(\"&#123;&#123; 1+1 &#125;&#125;\").generate()2&gt;&gt;&gt; print Template(\"&#123;&#123; 'scrambled eggs'[-4:] &#125;&#125;\").generate()eggs&gt;&gt;&gt; print Template(\"&#123;&#123; ', '.join([str(x*x) for x in range(10)]) &#125;&#125;\").generate()0, 1, 4, 9, 16, 25, 36, 49, 64, 81 2.22 控制流语句同样也可以在tornado模板中使用python条件和循环语句。控制与句以{ %和% }包围，并以类似下面形式使用：123&#123;% if page is None %&#125;或&#123;% if len(entrise) == 3 %&#125; 控制语句的大部分就像对应的python语句一样工作，支持if,for,wihle,try。在这些情况下，语句块以{ %开始，以 % }结束 模板:12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;header&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &#123;%for book in books%&#125; &lt;li&gt;&#123;&#123;book&#125;&#125;&lt;/li&gt; &#123;% end %&#125; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 处理函数:1234class BookHandler(tornado.web.RequestHandler): def get(self): self.render(\"books.html\", title=\"Home Page\", header=\"Books that are great\",\\ books=[\"python\", \"c++\", \"pascal\"]) 这个时候将渲染出：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123;header&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;python&lt;/li&gt; &lt;li&gt;C++&lt;/li&gt; &lt;li&gt;pascal&lt;/li&gt; &#123;% end %&#125; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 不像其他的python模板渲染系统，tornado模板语言的一个最好的东西是在if和for语句块中可以使用的表达式没有限制.因此，你可以在你的模板中执行所有的python代码。同样，你也可以在你的控制语句块中间使用{ % set foo = “bar” % }来设置变量的值。你还有很多可以在控制语句块中做的事情，但是，在大多数情况下，你最好使用UI模块来做更复杂的划分。我们稍后会更详细的看到这一点。 2.2.3在模板中使用函数tornado在所有模板中默认提供了一些遍历的函数。他们包括：12345678#替换字符串s中的&amp;,&lt;,&gt;为他们对应的html字符escape(s)# 使用urllib.quote_plus替换字符串s中的字符为URL编码形式url_escape(s)#将val编码成json格式，底层使用json.dumps()json_encode(val)#过滤字符串s,把连续的多个空白字符替换成一个空格squeeze(s) 在模板中使用一个你自己编写的函数也很简单：只需要将函数名作为模板的参数传递即可，就像其他的变量。123456789&gt;&gt;&gt; from tornado.template import Template&gt;&gt;&gt; def disemvowel(s):... return ''.join([x for x in s if x not in 'aeiou'])...&gt;&gt;&gt; disemvowel(\"george\")'grg'&gt;&gt;&gt; print Template(\"my name is &#123;&#123;d('mortimer')&#125;&#125;\").generate(d=disemvowel)my name is mrtmr","raw":null,"content":null,"categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"tornado","slug":"tornado","permalink":"http://yoursite.com/tags/tornado/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"tornado入门(简单的web服务)","slug":"tornado入门-简单的web服务","date":"2016-12-05T14:18:06.000Z","updated":"2016-12-10T16:12:14.591Z","comments":true,"path":"2016/12/05/tornado入门-简单的web服务/","link":"","permalink":"http://yoursite.com/2016/12/05/tornado入门-简单的web服务/","excerpt":"","text":"tornado入门tornado是使用python编写的一个强大的，可扩展的web服务器。它在高并发的网络请求中表现的足够稳定，但是却在创建和编写的过程中有着足够的轻量级，并能够被用在大量的应用和工具中。不同于那些最多只能达到10000个并发连接的传统web服务器，tornado在设计之初就考虑到了性能因素，旨在解决C10K问题，这样的设计使得其成为一个非常高性能的框架。此外，它还拥有处理安全性，用户验证，社交网络以及与外部服务进行异步交互的工具。 Hello tornadotornado是一个编写对HTTP请求响应的框架。作为程序员，你的工作是编写响应特定条件HTTP请求的响应的handler。 hello.py12345678910111213141516171819import tornado.httpserverimport tornado.ioloopimport tornado.optionsimport tornado.webfrom tornado.options import define, optionsdefine(\"port\", default=8000, help = \"run on the give port\", type = int)class indexHandler(tornado.web.RequestHandler): def get(self): greeting = self.get_argument(\"greeting\", \"hello\") self.write(greeting + \", friend user!\")if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", indexHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 编写一个tornado应用中最多的工作是定义继承自tornado.RequestHandler的类。在这个例子中，我们创建了一个简单的应用，在指定的端口监听请求，并在根目录(“/“)下响应请求。执行命令:1python hello.py --port=9999 使用命令对其访问12345curl http://localhost:9999hello, friend user!curl http://localhost:9999/?greeting=daviddavid, friend user! 现在tornado程序就已经在localhost:9999处进行监听。我们可以对其进行根目录使用get方法进行那个访问. 程序分析下面我们开始逐条语句进行分析：开始的import语句导入了程序所必须的tornado的相关模块。虽然tornado还有其他模块，但是我们在这个程序中只需要这四个模块 tornado中options模块分析12from tornado.options import define, optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int) tornado包含了一个有用的模块tornado.options来从命令行读取设置。我们在这里使用这个模块指定我们监听http请求的端口。它的工作流程是:如果一个与define语句中同名的设置在命令行中给出，那么它将成为全局options的一个属性。如果用户程序在运行的时候使用了–help选项，程序将打印出你所定义的选项以及你在define函数的help参数中指定的文本。如果程序没有为这个选项指定值，那么则使用default进行替代。tornado使用type来验证参数的类型，当类型不合适的时候跑出一个异常。因此，我们允许一个整数port作为options.port来访问程序，如果用户没有指定port的值，则默认为9999端口。 请求处理函数类及方法1234class indexHandler(tornado.web.RequestHandler): def get(self): greeting = self.get_argument(\"greeting\", \"hello\") self.write(greeting + \", friend user!\") 这是tornado请求处理函数类，它继承自tornado.web.RequestHandler,当处理一个请求的时候，tornado将这个类实例化，并调用http请求方法所对应的方法。在这个例子中，我们只定义了get方法，也就是说这个类对http的GET请求作出响应。我们稍后将看到实现不止一个http方法的处理函数。 获取查询参数1self.get_argument(\"greeting\", \"hello\") tornado的request类有很多有用的内建函数，包括get_argument()用来用一个查询字符串中获取参数的值。上述的意思是从查询字符串中获取查询参数greeting的值，若查询参数中没有greeting参数，则会其值为”hello”，即为其默认值。 RequestHandler的write函数1self.write(greeting + \", firendly user\") tornado另一个有用的方法是write,它以一个字符串作为参数，并将其写入到http响应中去。在这里，我们使用请求中greeting的参数提供的值插入到greeting中，并写回到相应中去。 创建Application实例123if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/\", indexHandler)]) 这里是真正使得tornado运转起来的语句。首先我们使用tornado的options解析命令行。然后我们创建了一个tornado的Application实例。传递给Application的init方法的最重要的参数就是handlers。它告诉tornado用那个类来响应特定的请求。 端口监听123http_server = tornado.httpserver.HTTPServer(app)http_server.listen(options.port)tornado.ioloop.IOLoop.instance().start() 从这离开始的代码会被反复使用，一旦Application对象被创建，我们可以将其传递给httpServer的对象，然后使用我们在命令行指定的端口进行监听。最后，在程序准备好接收HTTP请求后，我们创建一个tornado的IOLoop的实例进行启动。 简单字符串服务12345678910111213141516171819202122232425262728import textwrapimport tornado.webimport tornado.httpserverimport tornado.ioloopimport tornado.optionsfrom tornado.options import define,optionsdefine(\"port\", default=8000, help=\"run on the given port\", type=int)class ReverseHandler(tornado.web.RequestHandler): def get(self, input1, input2): self.write(input1) self.write(input2)class WrapHandler(tornado.web.RequestHandler): def post(self): text =self.get_argument(\"text\") width = self.get_argument(\"width\", 40) self.write(textwrap.fill(text, int(width)))if __name__ == \"__main__\": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r\"/reverse/([0-9]+)(\\w+)\", ReverseHandler),\\ (r\"/wrap\", WrapHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 上述是一个简单的字符串操作的web服务，有两个作用:第一，到/reverse/string的GET请求奖会返回url路径中指定字符串的反转形式。12$curl http://localhost:8000/reverse/123456654321 作用二是，到/wrap的POST请求从参数text中取得指定文本，并返回按照参数width指定宽度装饰的文本。下面的请求指定一个没有宽度的字符串，所以它的输出宽度被指定为程序中的get_argument的默认值40123$http://localhost:8000/wrap -d text=Lorem+ipsum+dolor+sit+amet,+consectetuer+adipiscing+elit.Lorem ipsum dolor sit amet, consectetueradipiscing elit. RequestHandler的更多知识HTTP方法到目前为止我们只用了http中的get,post方法，但tornado支持任何合法的HTTP请求（GET,POST,HEAD,DELETE,OPTIONS）。你可以非常容易的定义上述任何一种方法的行为，只需要在RequestHandler类中使用同名方法。 HTTP状态码从上面的代码可以看出，你可以使用RequestHandler类的set_status()方法显式的去设置http的状态麻，但是你需要记住在某些情况下，tornado会自动的设置状态码。下面是一种常见的纲要。 404 Not Found当http请求的路径无法匹配到任何RequestHandler类对应的模式的时候tornado会返回404相应码。 400 Bad Request如果你调用了一个没有默认值的get_argument()方法，并且没有发现给定名称的参数，tornado将自动返回一个400响应码 405 Method Not Allowed如果传入的请求使用了RequestHandler中没有定义的http方法，tornado将自动返回一个405响应码。 500 Internal Server Error当程序遇到任何不能让其退出的错误的时候，tornado自动返回响应码500.代码中任何没有捕获的异常也会返回500. 200 OK如果相应成功，并没有其他返回码被设置，tornado将默认返回一个200.","raw":null,"content":null,"categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"tornado","slug":"tornado","permalink":"http://yoursite.com/tags/tornado/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"迭代器和简单的生成器","slug":"迭代器和简单的生成器","date":"2016-12-04T12:22:48.000Z","updated":"2016-12-04T13:12:12.518Z","comments":true,"path":"2016/12/04/迭代器和简单的生成器/","link":"","permalink":"http://yoursite.com/2016/12/04/迭代器和简单的生成器/","excerpt":"","text":"迭代器和简单的生成器摘自: https://www.ibm.com/developerworks/cn/linux/sdk/python/charm-20/ python2.2引进了一种带有新型关键字的新型构造。这个构造是生成器；关键字是yield.生成器使几个新型，强大和富有表现力的编程习惯成为可能，但初看，要理解生成器，还是有一点难度。本文由浅入深的介绍了生成器，同时还介绍了迭代器的相关问题。 由于迭代器比较容易理解，让我们先看它。基本上迭代器是含有.next方法的对象。这样定义不十分正确但非常接近。事实上，当迭代器应用新的iter()内置函数的时候，大多数迭代器的上下文希望返回迭代器，需要使iter()方法返回self.本文的示例将会说明清楚这一点。如果迭代有一个逻辑的终止，则迭代器的.next()方法可能决定抛出StopIteration异常。生成器要稍微复杂化和一般化一点。但生成器典型的用途是用来定义迭代器；所以不值得总是为一些细微之处而担心，生成器是这样一个函数它记住上一次返回时在函数体中的位置，对于生成器函数的第二次调用跳转到该函数的中间，而上次调用的所有的局部变量都被记住 随机遍历让我们考虑一个简单的问题，可以使用很多方法解决它。假设我们想要一串正的随机数字流，这个数字流的要求是每一个数字不允许小于0.1,且相邻两个数字之间的大小相差绝对值不小于0.4 版本一版本一是比较传统的做法,我们直接写一个随机产生一串数字流的函数，并将他保存在一个list中返回:123456789101112131415def generate_random(): last, rand = 1, random.random() num = [] while rand &gt; 0.1: if abs(last - rand) &gt;= 0.4: last = rand num.append(rand) else: print \"invalid\" rand = random.random() num.append(rand) return numfor item in generate_random(): print item 从上面可以产出，这种方法有很大的局限性。首先这个示例中不可能产生庞大的数字列表，通过对数字的大小限制进行终结随机数的产生，我们可以通过限制进行预测此数列的大小。另一方面，在内存和性能方面使这种方法变得不切实际，以及没有必要。同样是这个问题，使得python较早的版本中添加了xrange()和xreadlines()。重要的是，许多流取决于外部事件，并且当每个元素可用时，才处理这些流。在python2.1和较早的版本中，我们的诀窍是使用静态函数局部变量来记住函数上一次调用的事情。显而易见，全局变量可以用来做同样的工作，但是它会带来大家熟知的问题：命名空间污染问题 ###版本二 使用静态成员解决上述问题1234567891011121314def generate_random_static(last = [1]): rand = random.random() if rand &lt; 0.1: return while abs(rand - last[0]) &lt; 0.4: print \"invalid\" rand = random.random() last[0] = rand return randnum = generate_random_static()while num is not None: print num num = generate_random_static() 这个函数是一个很好的存储器，它只需要记住上一次的的值，返回一个单一的数字。而不需要存储一整个列表。并且与此类似的函数可以返回却绝育外部事件的连续的值。不方便的是使用这个函数不够方便，且想当不灵活 版本三 定义迭代器类实质上python2.2的序列都是迭代器，python常见的习惯用法for elem in lst:而实际上是让;lst差生一个迭代器。然后for循环调用这个迭代器的.next()方法，直到遇到StopIteration为止。幸运的是，由于常见的内置类型自动产生它们的迭代器，所以python程序员不需要直到这里发生了什么。实际上，现在字典里有.iterkeys(),.iteritems(),.itervalues()方法产生迭代器。定制类支持直接使用randomwalk_list()以及一次一个元素这种极度节省的randomwalk_static,这是简单易懂的。1234567891011121314151617181920class generate_random_class(object): def __init__(self): self.last = 1 self.rand = random.random() def __iter__(self): return self def next(self): if self.rand &lt; 0.1: raise StopIteration else: while abs(self.last - self.rand) &lt; 0.4: print \"invalid\" self.rand = random.random() self.last = self.rand return self.randfor item in generate_random_class(): print item 版本四 生成器版本上述方法也会产生较多的问题，虽然它避免了产生整个list,大量局部变量的情况，但是当迭代器类或者函数取决于多个数据状态的时候，就需要记录多个数据的状态，这种情况下出现错误的记录较大。所以也不是一种较好的解决方法。使用python自带的生成器yield关键字在 Python 2.2+ 中，不直接 写生成器。 相反，编写一个函数，当调用它时，返回生成器。这可能看起来有点古怪，但“函数工厂”是 Python 的常见特性，并且“生成器工厂”明显是这个概念性扩展。在 Python 2.2+ 中使函数成为生成器工厂是它主体某处的一个或多个 yield 语句。如果 yield 发生， return 一定只发生在没有伴随任何返回值的情况中。 然而，一个较好的选择是，安排函数体以便于完成所有 yield 之后，执行就“跳转到结束”。但如果遇到 return ，它导致产生的生成器抛出 StopIteration 异常，而不是进一步生成值。1234567891011def generate_random_yield(): last, rand = 1, random.random() while rand &gt; 0.1: if abs(last - rand) &gt;= 0.4: last = rand yield rand rand = random.random() yield randfor item in generate_random_yield(): print item 上述做法的好处是逻辑简洁，与正常写法无意，也保证了通用性。","raw":null,"content":null,"categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"生成器","slug":"生成器","permalink":"http://yoursite.com/tags/生成器/"},{"name":"迭代器","slug":"迭代器","permalink":"http://yoursite.com/tags/迭代器/"}]},{"title":"python yield使用浅析","slug":"python-yield使用浅析","date":"2016-12-03T14:08:04.000Z","updated":"2016-12-04T11:53:12.318Z","comments":true,"path":"2016/12/03/python-yield使用浅析/","link":"","permalink":"http://yoursite.com/2016/12/03/python-yield使用浅析/","excerpt":"","text":"python yield使用浅析摘自:https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/初学python的人经常会发现python函数中使用了很多yield关键字，然而，带有yield关键字的函数的执行流程和普通函数的执行流程不同，yield带来了什么作用，为什么要设计yield?本文将由浅入深地讲解yield的概念和用法，帮助读者体会yield在python中的简单而强大的功能您可能听说过，带有yield的函数在python中称为generator(生成器)，何谓生成器？先抛开generator,以一个常见的编程题目来展示yield的概念。 如何生成斐波那契数列版本1（直接输出斐波那契数列）斐波那契额数列的概念搭建应该比较清晰，相信大家能共很轻易的写出如下的算法来计算斐波那契数列:123456def fab(max): n, a, b = 0, 0, 1 while n &lt; max: print b a, b = b, a + b n = n + 1 执行fab(5),我们会的到如下的结果：123456&gt;&gt;&gt; fab(5)11235 结果没有问题，但是有经验的开发者会指出，直接在fab函数中 print打印出结果可复用性较差，因为fab返回的结果是None,其他函数无法获取该函数生成的斐波那契数列。所以要提高该函数的可复用性，最好不要直接打印出数列，而是返回一个list 版本二（返回list）123456789def fab(max): n, a, b = 0, 0, 1 L = [] while n &lt; max: L.append(b) a, b = b, a + b n = n + 1 return L 使用如下方式打印出斐波那契数列：1234567&gt;&gt;&gt; for n in fab(5):... print =n11235 上述版本获取了可复用性的要求，但是该函数在运行的过程中占用的内存会随着参数max的增大而增大，如果要控制内存占用，最好不要用list来保存中介按结果，而是通过iterable对象来迭代。例如在python2.x中123for i in range(0,100)for i in xrange(0,100) 前者会生成一个长度为100的list,而后者则不会生成一个100的list，而是在每次迭代中返回下一个数值，内存占用空间很小。因为xrange不返回list,而返回一个iterable的意向，利用iterable我们可以吧fab函数写成一个支持iterable的class 版本三（实现支持iterable的对象）1234567891011121314class fab(object): def __init__(self, max): self.max = maxself.n, self.a. self.b = 0, 0, 1 def __iter__(self): return self def next(self): if self.n &lt; self.max: r = self.b self.a, self.b = self.b, self.a + self.b self.n = self.n + 1 return r raise StopIteration Fab函数通过next不断返回数列的下一个数，内存占用始终为常数1234567&gt;&gt;&gt;for n in fab(5):... print n11235 上述代码虽然实现了我们版本二的要求，但是代码远远没有第一个版本简洁。如果想要保持第一版的简洁，这个时候就要用上yield 版本四123456def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 第四个版本和第一个版本相比仅仅把print b该成了yield b,就在保持简洁性的同时获得了iterable的效果。调用第四个版本和第二个版本的fab完全一致:1234567&gt;&gt;&gt;for n in fab(5):... print n11235 简单的将,yield的作用就是把一个函数变成了一个generator,带有yield的函数不在是一个普通函数,python解释器会将其视为一个generator,调用fab(5)不会执行fab函数，而是返回一个iterable对象。在for循环执行的时候，每次循环都会执行fab内部的代码，执行到yield b的时候，fab就返回一个迭代之，下次迭代时，代码从yieldb 的下一条语句执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到yield也可以调用fab(5)的next()方法进行回去每次计算的值。 yield函数的执行流程123456789101112131415&gt;&gt;&gt; f = fab(5)&gt;&gt;&gt; f.next()1&gt;&gt;&gt; f.next()1&gt;&gt;&gt; f.next()2&gt;&gt;&gt; f.next()3&gt;&gt;&gt; f.next()5&gt;&gt;&gt; f.next()Traceback (most recent call last): File \"&lt;stdin&gt;\". line 1, in &lt;module&gt; StopIteration 当函数执行结束的时候，generator自动自动抛出StopIteration的异常，表示迭代的结束，而在for循环中，我们不需要手动的进行处理异常，循环会自动的正常结束。 一个带有yield的函数就是一盒generator,它和普通的函数不同，声称一个generator看起来想函数调用，但是部执行任何函数代码，直到对其调用next()(注意在for循环中会自动调用next)才开始执行。虽然执行流程和普通函数一样，但是每执行到一个yield语句，就会中断，并返回一个迭代值，下次执行的时候从yield的下一个语句开始执行。看起来像是一个函数在正常执行的过程中被yield中断了数次，每次中断都会通过yield返回当前迭代器的值。yield的好处显而易见，把一个函数该写成generator就获得了迭代能力，比起在类的实例中保存状态计算下一个next的值，更加使代码清洁，而且执行流程非常清晰 判断是否为generator方法是使用isgeneratorfunction来进行判断12from inspect import isgeneratorfunctionisgeneratorfunction(fab) 注意fab不可迭代,而fab(5)可迭代 return的作用在一个generator function中，若函数中没有return语句，默认为函数执行到函数结尾，而如果中间遇到return语句，则直接判处StopIteration异常，结束迭代。使用yield进行读取文件的例子123456789def read_file(fpath): block_size = 1024 with open(fpath, \"rb\") as f: while True: block = f.read(block_size) if block: yield block else return 上述当文件读取完毕的时候奖直接返回StopIteration异常，结束迭代。","raw":null,"content":null,"categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"yield","slug":"yield","permalink":"http://yoursite.com/tags/yield/"}]},{"title":"python装饰其入门","slug":"python装饰其入门","date":"2016-12-02T13:43:51.000Z","updated":"2016-12-04T11:30:31.762Z","comments":true,"path":"2016/12/02/python装饰其入门/","link":"","permalink":"http://yoursite.com/2016/12/02/python装饰其入门/","excerpt":"","text":"python装饰器预备知识一级对象python将一切（包括函数）视为object的子类，即一切皆为对象，因此函数可以像变量一样被指向和传递，下面我们来看一个例子。 1234def foo(): pass#注意issubclass是python的一个内置函数,用于判断两个类是不是子类关系print issubclass(foo.__class__, object) 输出结果: 1True 上述代码说明了python中的函数都是object的子类，下面我们看一下函数被当做参数传递的效果 1234567def foo(func): func()def bar(): print \"bar\"foo(bar) 运行结果如下:1bar python中的作用域 namespacepython 提供namespace来重新实现函数/方法，变量等信息的区别，七一共有三种作用域: local namespace:作用范围为当前函数或者类方法 global namespace:作用范围为当前模块 build-in namespace:作用范围为所有模块 当变量或者方法出现重名的情况时，python会按照local-&gt;global-&gt;build-in的顺序去搜索,并以第一个找到的元素为当前的namespace，此种做法与C/C++中的相似 *args和**kwargs在python中我们使用*args和kwargs传递可变长参数,*args用作传递非命名键值可变长参数列表(位置参数)；**kwargs用作传递键值可变长参数 *args：把所有的参数按照出现顺序打包成一个list **kwargs：把所有的key-value形式的参数打包成一个dict 例子： 1234567def add(x, y): print x + yparams_list = (1, 2)dict_list = &#123;\"x\":1, \"y\":2&#125;add(*params_list)add(**dict_list) 打印结果:1233 python装饰器入门python允许你，作为程序员，使用函数完成一些很酷的事情。在python中，函数是一级对象(first-class)，这就意味着你可以像使用字符串，整数，或者其他对象一样使用函数。例如，你可以将函数赋值给变量：12345def square(n): return n * nprint square(4) #16alias = squareprint alias(5) #25 然而一等函数的真正威力在于你可以把函数传给其他函数，或者从其他函数中返回函数。函数的内值函数map利用了这种能力：给map传一个函数以及一个列表，他会依次以列表中的每个元素作为参数调用你传给它的函数，从而生成一个新的列表。如下所示的例子中应用了上面的square函数： 12number = [1,2,3,4]print map(square, number) #[1,4,9,16] 如果一个函数接受一个函数作为参数或者返回一个函数，则这个函数被称为高阶函数虽然map简单使用了我们传给它的函数，而没有改变这个函数，但我们也可以使用高阶函数去改变其他函数的行为。例如：假设有这样一个函数，会被调用很多次，以致运行待解非常昂贵:12def fib(n): return n if n in [0,1] else fib(n - 2) + fib(n - 1) 为了提高这个函数的效率，我们一般会保存计算过程中得出的中间结果，这样对于函数调用树中经常出现某个n，当需要计算n对应的结果时，就不需要重复计算了。有很多种方式可以实现这一点。例如我们可以将这些结果存在一个字典中，当某个值为参数调用fib函数的时候，首先去字典中查一下结果是否已经计算出来，如果计算出来直接返回反之计算。但是这样的话，每次我们想调用fib函数，都需要重复那段相同的字典检查样板式代码。相反，如果让fib函数自己在内部负责存储结果，那么在其他代码中调用fib，就非常方便，只要简单的调用它就好了。这种技术被称为memoization当然我们可以把这种memozition代码直接放入fib函数中，但是python给我们提供了一种更加优雅的选择因为可以编写修改其他函数的函数，那么我们就可以便携一个通用的memozation函数，以一个函数作为参考，并返回这个函数的memozation版本。123456789def memoze(fn): store_results = &#123;&#125; def memoized(args): try: return store_results[args] except: result = store_result[args] = fn(args) return result return memoized 如上，momoize函数以另一个函数作为参数，函数体中创建了一个字典对象来存储函数调用结果：键为被memoized包含后的函数的参数，值为以键为参数调用函数的返回值。memoize函数返回一个新的函数，这个函数会首先检查store_results中是否存在与当前参数对应的条目，如果有则直接返回，如果没有，则使用原始函数进行计算。memoize返回的这种新的函数常被称为包装器函数。因为它只是另外一个真正起作用的函数外面的一个薄层。很好，我们现在有了memoize函数，现在将fib函数传给它，从而得到了一个经过包装的fib，这个版本的fib函数不需要重复以前的那样繁重的工作：1234def fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1)fib = memoize(fib) 通过高阶函数memoize，我们获得了memoization带来的好处，并不需要对fib函数自己做出任何的改变，以免夹杂着memoization的代码而模糊了函数的实质工作。但是，你也许注意到上面的代码看着还是有点别扭，因为我们必须写三遍fib。由于这种模式(传递一个函数给另一个函数，然后将结果返回给与原来那个函数同名的函数变量，在使用包装器函数的代码中极为常见)，python提供了一种特殊的愈发：装饰器123@memoizedef fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1) 这里我们说memoize函数装饰了fib函数。需要注意的是这仅是语法上的简便写法（被称为“语法糖”）。这段代码与前面的代码片段做的是同样的事情：定义一个名为fib的函数，把它传给memoize函数，将返回结果存为名为fib的函数变量。特殊的(看起来有点奇怪的)@语法只是减少了冗余。 你可以使用多个装饰器，它会自底向上逐个起作用，例如假如有另外一个装饰器函数decorate1234@memoize@decoratedef fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1) 等价于：123def fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1)fib = memoize(decorator(fib)) 当装饰器函数含有参数的时候，方法是123@mimoize(\"172.168.1.1\")fib(n): return n if n in [0, 1] else fib(n - 2) + fib(n - 1)","raw":null,"content":null,"categories":[{"name":"python学习","slug":"python学习","permalink":"http://yoursite.com/categories/python学习/"}],"tags":[{"name":"装饰器","slug":"装饰器","permalink":"http://yoursite.com/tags/装饰器/"}]}]}