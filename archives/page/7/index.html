
<!DOCTYPE html>
<html lang="zh-CN">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="魏传柳">
    <title>Archives - 魏传柳</title>
    <meta name="author" content="魏传柳(2824759538@qq.com)">
    
        <meta name="keywords" content="hexo,javascript,">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="魏传柳">
<meta property="og:url" content="http://yoursite.com/archives/page/7/index.html">
<meta property="og:site_name" content="魏传柳">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="魏传柳">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/avar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-nuvue6sithwirecbhvw3dkaobiojqvtadsnhguwi7k04xklybw5djl1smadp.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">魏传柳</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avar.jpg"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avar.jpg"/>
            </a>
            <span class="sidebar-profile-name">魏传柳(2824759538@qq.com)</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">categories</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">archives</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">search</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">about</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/langzi989" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://blog.csdn.net/u014630623" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-csdn"></i>
                    <span class="sidebar-button-desc">CSDN</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/08/GRASP设计原则（职责分配原则）/">
                            GRASP设计原则（职责分配原则）
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-08T19:45:46+08:00">
	
		    1月 08, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/设计模式之路/">设计模式之路</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="GRASP设计原则（职责分配原则）"><a href="#GRASP设计原则（职责分配原则）" class="headerlink" title="GRASP设计原则（职责分配原则）"></a>GRASP设计原则（职责分配原则）</h1><p>GRASP(General responsibility assignment software Principle)设计原则是设计模式的基础,在GOF的23中设计模式中处处可以体现其中的一个或多个设计原则，所以在掌握设计模式之前需要对GRASP原则有一定的了解，本节我在这里总结一下grasp原则。</p>
<p>本文共分为以下几个内容：</p>
<ul>
<li>GRASP的九个原则</li>
<li>GRASP原则详解</li>
<li>GRASP原则在23中设计模式中的体现</li>
</ul>
<h2 id="GRASP的九个原则"><a href="#GRASP的九个原则" class="headerlink" title="GRASP的九个原则"></a>GRASP的九个原则</h2><ul>
<li>信息专家原则(information)</li>
<li>创造者原则(creator)</li>
<li>低耦合原则(low coupling)</li>
<li>高内聚原则(high cohesion)</li>
<li>控制器原则(controller)</li>
<li>多态原则(polymorphism)</li>
<li>纯虚构(pure Fabrication)</li>
<li>中介原则(indirect)</li>
<li>受保护变量原则(protected Variations)</li>
</ul>
<h2 id="Grasp原则详解"><a href="#Grasp原则详解" class="headerlink" title="Grasp原则详解"></a>Grasp原则详解</h2><h3 id="信息专家原则-information-expert"><a href="#信息专家原则-information-expert" class="headerlink" title="信息专家原则(information expert)"></a>信息专家原则(information expert)</h3><p>信息专家模式的本质指的是我们应该将<strong>职责委托给哪一个对象</strong>，这个职责可以是一个方法，也可以是一个算法或者其他内容。它是面向过程设计过程中最基本的原则。</p>
<p><strong>委托原则</strong>:我们在设计对象的时候，如果某个对象拥有完成某个职责所需要的所有信息，那么这个职责就分配给这个对象实现。这个时候，这个类就是相对于这个职责的信息专家。</p>
<p>示例：我们在设计购物网站的时候，为避免重复，一种商品只能在购物车中出现一次，如果多次出现，则需要将其数量增加。这个时候我们在将物品放入购物车的时候，要首先判断当前物品是否在购物车中，判断两个物品是否为同一个物品的方法这个职责应该委托给谁呢？显而易见，商品类中有唯一标识，所以这个职责由商品类实现，而不是购物车。</p>
<h3 id="创造者原则-creator"><a href="#创造者原则-creator" class="headerlink" title="创造者原则(creator)"></a>创造者原则(creator)</h3><p>creator原则的本质是创建类对象职责应该委托给那个对象，也就是谁应该负责产生某个类的实例。</p>
<p>解决方案:　如果符合下面的一个或者多个条件，则可以将创建A的实例的职责分配给B;</p>
<ul>
<li>B包含A</li>
<li>B聚合A</li>
<li>B拥有初始化A的数据并在创建A的实例时将数据传递给A</li>
<li>B记录A的实例</li>
<li>B频发使用A</li>
</ul>
<p>满足上述一种或者多种情况的时候，我们应该奖创建A的实例的职责分配给B。</p>
<p>合理的creator原则带来的<strong>优点</strong>：如果职责分配合理，设计就能降低耦合，提高设计的清晰度，封装性和重用性。</p>
<p>示例:例如订单和商品的关系是聚合关系，这个时候我们将在订单中创建商品。</p>
<h3 id="低耦合-Low-coupling"><a href="#低耦合-Low-coupling" class="headerlink" title="低耦合(Low coupling)"></a>低耦合(Low coupling)</h3><p><strong>耦合是评价一个系统中各个元素之间连接或者依赖关系强弱的尺度。</strong>低耦合的原则是我们在设计系统的时候尽量降低系统中各个元素之间的耦合度，这样对于系统的理解和维护都有很大的益处。</p>
<p>耦合性高的系统会带来的坏处:</p>
<ul>
<li>一个类的修改导致其他类产生较大的影响；</li>
<li>系统难以维护和理解；</li>
<li>系统的重用性差，在重用一个高耦合类的时候，不得不重用它所依赖的所有类。</li>
</ul>
<p>两个类具有以下特性中的其中一个，我们就说这两个类是耦合的：</p>
<ul>
<li>A具有一个类型为B的属性；</li>
<li>A调用B的方法</li>
<li>A的方法包含对B的引用(参数或者返回值的方式)</li>
<li>A是B的直接或者间接的子类</li>
<li>A是接口B的一种实现</li>
</ul>
<p>低耦合系统的<strong>设计方法</strong>：</p>
<ul>
<li>在类的划分上，尽量创建松耦合的类，类之间的耦合性越低，越有利于复用，修改一个类不会影响其他类。</li>
<li>在类的设计上，尽量降低类中成员和方法的访问权限。</li>
<li>在类的设计上，尽量将类设计为不变类</li>
<li>在类的引用上，将一个对象对另一个对象的引用降低到最小</li>
</ul>
<h3 id="高内聚-high-cohesion"><a href="#高内聚-high-cohesion" class="headerlink" title="高内聚(high cohesion)"></a>高内聚(high cohesion)</h3><p><strong>内聚是评价一个对象的职责被关联的尺度或者强弱，也可以说是功能性内聚的职责。</strong>也就是功能性紧密的相关职责应该放在同一个类中，并共同完成有限的功能。这样做更加有利于对类的理解和重用，也可以降低类的维护成本。</p>
<p>往往低内聚的系统设计会导致类的混乱，当对功能进行扩展或者改进的时候带来不必要的麻烦，低内聚的类也不利于重用，因为他们的职责如此之混乱。</p>
<p>为了达到高内聚，我们需要对类的职责进行分解，使分解出来的类具有独立的职责，满足单一职责原则。<strong>将一些需要在多个类中使用到的方法封装到一个类中，其他的类只负责他们需要负责的相关功能</strong>，这样我们可以提高类的内聚程度。</p>
<h3 id="控制器原则-controller"><a href="#控制器原则-controller" class="headerlink" title="控制器原则(controller)"></a>控制器原则(controller)</h3><p>控制器模式的实质是将一些<strong>系统事件的接受和处理</strong>委托给一个的对象controller，这个对象可以是一个<strong>类，系统或者子系统</strong>，它不与UI进行交互，它只负责系统信息的接收和处理。</p>
<p>一般情况下，控制器是一个系统，这个系统中包括多个处理器，分别对应处理不同的事务。通常情况下，一个控制器应当把要完成的功能委托给其他对象，而它只负责任务的协调控制和分配。</p>
<p>控制器原则与MVC模式相对应，MVC模式是一种比设计模式更高的架构模式。</p>
<h3 id="多态原则-polymorphism"><a href="#多态原则-polymorphism" class="headerlink" title="多态原则(polymorphism)"></a>多态原则(polymorphism)</h3><p>多态原则与面向对象设计原则中的多态概念类似，这里不再详细赘述。</p>
<h3 id="纯虚构-pure-Fabrication"><a href="#纯虚构-pure-Fabrication" class="headerlink" title="纯虚构(pure Fabrication)"></a>纯虚构(pure Fabrication)</h3><p>纯虚构原则与我们所说的纯虚函数类似。</p>
<p>　　纯虚构的作用是用来解决高内聚和低耦合之间的矛盾的。高内聚低耦合是我们系统设计的终极目标，高内聚意味着我们要将类拆分成多个功能集中的类，但是拆分的多个类之间需要进行协作才能正常工作，这样又增加了类之间的耦合性。</p>
<p>　　纯虚构原则是用来解决上述问题的方案。它要求将一部分类的职责转移到纯虚构类中，在理想的情况下，分配给这种虚构类的职责是为了达到高内聚低耦合的效果。在实际的操作过程中，纯虚构类的实现又很多种方式，例如将数据库中操作的方法从数据库实体中分离出来，形成专门的数据访问类；通过对类的分解来实现类的重用，新增加的数据访问类对应于数据的持久化存储，这是软件开发过程中为了方便虚构出来的一个概念。一般情况下，<strong>纯虚构模式通常基于功能进行划分的。</strong></p>
<h3 id="中介模式-indirect"><a href="#中介模式-indirect" class="headerlink" title="中介模式(indirect)"></a>中介模式(indirect)</h3><p>中介模式的目的是为了避免两个对象之间产生直接耦合，降低对象之间的耦合度。</p>
<p>解决方案是建立中间对象来协调两个对象之间的交互，避免耦合性过高。</p>
<h3 id="受保护模式-protected-variations"><a href="#受保护模式-protected-variations" class="headerlink" title="受保护模式(protected variations)"></a>受保护模式(protected variations)</h3><p>受保护模式的实质与OCP(开放闭合原则)类似，我们首先找到系统中不稳定的变化点，使用统一的接口封装起来，如果未来发生变化的时候，可以通过扩展接口来扩展新的功能，而不需要改变旧的代码。这样达到易于扩展的目的。</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/08/GRASP设计原则（职责分配原则）/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/08/创建型设计模式之build模式/">
                            创建型设计模式之build模式
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-08T01:36:19+08:00">
	
		    1月 08, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/设计模式之路/">设计模式之路</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="创建型设计模式之build模式"><a href="#创建型设计模式之build模式" class="headerlink" title="创建型设计模式之build模式"></a>创建型设计模式之build模式</h1><p>最近在读《设计模式-可复用面向对象软件设计的基础》一书，在阅读的过程中我会结合书中的相关知识和实例以及在网络上的博客对相关的模式的理解进行总结，并在此基础上加入自己的一些理解，总结模式中需要注意的一些点，记录在此博客，以供大家交流分享，同时防止自己对内容遗忘，如有不正确指出，欢迎批评指正。</p>
<p>本节的主要内容是设计模式中的创建型模式之一:builder模式</p>
<p>要用好builder模式，必须对其机制了解透彻，将该模式用在合适的软件中才能显出它真正的威力，第五部分中实例将为您展示它的真正威力。</p>
<p>本文内容分为以下几个方面:</p>
<ul>
<li>builder模式的意图</li>
<li>builder模式的适用性</li>
<li>builder模式的结构(通用UML类图)及详解</li>
<li>builder模式中的参与者</li>
<li>builder模式中各个成分之间的交互</li>
<li>builder模式比较好的一个实例</li>
<li>builder模式使用过程中注意的点</li>
<li>KFC套餐实例代码</li>
</ul>
<p><strong>builder模式的精髓都隐藏于builder模式的意图和实用性中，让你真正理解这两个方面，可以说你已经掌握了builder模式（以下意图和模式都摘自《设计模式》书中）</strong></p>
<h2 id="builder模式的意图"><a href="#builder模式的意图" class="headerlink" title="builder模式的意图"></a>builder模式的意图</h2><p>builder模式的意图是将一个<strong>复杂对象的构建</strong>与它的<strong>表示</strong>分离，使得同样的构建过程可以创建不同的表示。</p>
<h2 id="builder模式的适用性"><a href="#builder模式的适用性" class="headerlink" title="builder模式的适用性"></a>builder模式的适用性</h2><ul>
<li>当<strong>创建复杂对象的算法</strong>应该独立于<strong>该对象的组成部分</strong>以及<strong>它们的装配方式</strong>时。</li>
<li>当构造过程必须<strong>允许被构造的对象有不同的表示</strong>时。</li>
</ul>
<p>提前记录一下:装配的工作是由导向器(director)完成的，复杂对象的创建是由具体的建造器完成(concreteBuilder)，这里不明白没问题，等你看完全文再过来看这里你就理解了。</p>
<blockquote>
<p> 当且仅当上面两个条件均满足的情况下我们要使用builder模式（完全理解这两条不一件重要的事情，但是不要着急,当你读完这篇文章的时候就会拨开它的庐山真面目了）</p>
</blockquote>
<h2 id="builder模式的结构-UML类图-及详解"><a href="#builder模式的结构-UML类图-及详解" class="headerlink" title="builder模式的结构(UML类图)及详解"></a>builder模式的结构(UML类图)及详解</h2><p>builder模式的UML类图关系如下:</p>
<p><img src="/images/build_diagram.png" alt=""></p>
<p>注意的问题:</p>
<ul>
<li>在builder中一般不声明纯虚函数，而是把它们定义为空方法，这使客户只重定义他们感兴趣的操作。</li>
<li>在director中，注意我们不是把所有的buildPart都去执行一次，而是根据需要的客户的需求，进行定制的去buildPart部分构建，可以构建一次，也可以构建多次。</li>
<li>一般将m_product声明为protected成员，因为这样既保证了封装性，又能使得concreteBuilder能够正常操作product；</li>
</ul>
<h2 id="builder模式种的参与者"><a href="#builder模式种的参与者" class="headerlink" title="builder模式种的参与者"></a>builder模式种的参与者</h2><p>从上面的类图中我们也可以看出,在builder模式中的参与者有以下四种,以及他们的职责分别是:(此处为个人理解，与书中内容可能不一致,如果有问题欢迎指正)</p>
<ul>
<li>Director: 负责装配product的各个部件，使用Builder的类方法进行实现。它的作用是隔离了客户与product的具体生产过程；并负责控制product的生产过程。</li>
<li>Builder: 为创建一个product对象的各个部件指定抽象接口。一般情况下默认builderPart的操作默认为空。</li>
<li>concreteBuilder: 具体实现每一个部件的具体的复杂生产过程，如buildPartA()的具体实现，并提供一个检索产品的接口。</li>
<li>Product: 这个争议不大，即为被构造的复杂对象。此类对象会有不同的表示。</li>
</ul>
<h2 id="builder模式各个成分之间的交互方式"><a href="#builder模式各个成分之间的交互方式" class="headerlink" title="builder模式各个成分之间的交互方式"></a>builder模式各个成分之间的交互方式</h2><p>先上一张时序图:</p>
<p><img src="/images/builder_sequence.png" alt=""></p>
<p>从上面的时序图可以分析出，各个成分之间的交互方式如下:</p>
<ul>
<li>客户首先创建一个concreteBuilder对象,然后创建一个Director,</li>
<li>创建结束之后，使用concreteBuilder修饰对象Director,</li>
<li>然后调用Director的construct()方法，进行构造Product,</li>
<li>最后客户通过concreteBuilder的getResult()方法取回生成的Product</li>
</ul>
<h2 id="builder模式中一个较好的实例"><a href="#builder模式中一个较好的实例" class="headerlink" title="builder模式中一个较好的实例"></a>builder模式中一个较好的实例</h2><p>两个实例来自网络对两本书籍实例的纠正,改编</p>
<p>上面这篇文章深刻的分析了builder模式的本质以及诸多误区的分析，收益颇多，在此感谢博主分享。</p>
<p>在本例中,设备(Equipment)是一个复杂对象，由一个machine和一个或多个输入端口(InputPort)或者输出端口(outputPort)组成；其中输入或输出端口可能有不同的类型(ordinary和super)。现在要你设计一个生成不同型号的产品，要求产品可能包含一进一出(普通或super)，一进两出(普通或super)。</p>
<p>　　在设计中,我们首先定义一个LCDFactory对象充当director，一个设备生成器(EQPBuilder),相当于Builder。</p>
<p>​    首先ordinary和super是port的内部实现方式不同，所以我们需要定义两个具体类，即 ordinaryEQPBuilder和superEQPBuilder。</p>
<p>​    在EQPbuilder中，我们将定义四个函数，分别是:buildMachine(), addInputPort(), addOutputPort()和getEQP()。两个concrete类继承EQPBuilder。</p>
<p>​    当我们需要获取不同数目的port的设备，这属于组装方面的范畴，所以我们将在LCDFactory中的createEQP中做。其UML类图如下:</p>
<p><img src="/images/BuilderEquipment_thumb.jpg" alt=""></p>
<h2 id="builder模式在使用的过程中需要注意的问题"><a href="#builder模式在使用的过程中需要注意的问题" class="headerlink" title="builder模式在使用的过程中需要注意的问题"></a>builder模式在使用的过程中需要注意的问题</h2><p>这里所说的注意的问题可能上面已经提到了，但是这里还是要着重强调一下，因为我们稍不注意，就可能将模式滥用，导致系统设计的失败。</p>
<ul>
<li>在builder模式中Builder一定不要定义纯虚函数成员函数，而是定义为空方法的虚函数，这样就可以使得客户可以只定义他们感兴趣的操作。</li>
<li>Director负责<strong>装配产品</strong>，concreteBuilder负责实现<strong>复杂产品部件的具体实现</strong></li>
<li>在Director中调用Builder的buildPart函数的时候，并不是每个函数都被调用，而是根据要生成的product对其选择性调用，可能调用零次，也可能调用多次。</li>
<li>Builder中的m_product声明为protected,即保证对象的封装性，又能让具体类方便的使用。(这是我在写代码的时候的解决方法，如果有更好的将m_product声明为private的解决方法欢迎交流2824759538@qq.com)</li>
</ul>
<h2 id="KFC套餐实例代码"><a href="#KFC套餐实例代码" class="headerlink" title="KFC套餐实例代码"></a>KFC套餐实例代码</h2><p>这是本人使用KFC服务员生成套餐时的一种模拟，其实实际情况中并不需要使用builder模式，但是这里为了练手强行写成了builder模式，希望大家不要吐槽。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//KFCWaiter.hpp 注意此处water相当于Director的作用</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KFCWAITER_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KFCWAITER_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilder.hpp"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCWaiter</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setMealBuilder</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt; t_builder)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt; m_builder;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//KFCWaiter.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KFCWaiter.hpp"</span></span></div><div class="line"><span class="keyword">void</span> KFCWaiter::setMealBuilder(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt; t_builder) &#123;</div><div class="line">  m_builder = t_builder;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> KFCWaiter::construct() &#123;</div><div class="line">  m_builder-&gt;buildFood();</div><div class="line">  m_builder-&gt;buildDrink();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Meal.hpp Meal相当于Product</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MEAL_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MEAL_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Meal(<span class="built_in">std</span>::<span class="built_in">string</span> t_food = <span class="string">"hanbao"</span>, <span class="built_in">std</span>::<span class="built_in">string</span> t_drink = <span class="string">"kele"</span>);</div><div class="line">  ~Meal();</div><div class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getFood</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getDrink</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getMeal</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">buildFood</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t_food)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">buildDrink</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t_drink)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> m_food;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> m_drink;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Meal.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Meal.hpp"</span></span></div><div class="line">Meal::Meal(<span class="built_in">std</span>::<span class="built_in">string</span> t_food, <span class="built_in">std</span>::<span class="built_in">string</span> t_drink)</div><div class="line">    : m_food(t_food), m_drink(t_drink) &#123;&#125;</div><div class="line">Meal::~Meal() &#123;&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Meal::getFood() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_food; &#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Meal::getDrink() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_drink; &#125;</div><div class="line"><span class="keyword">void</span> Meal::getMeal() <span class="keyword">const</span> &#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"套餐为:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></div><div class="line">            &lt;&lt; <span class="string">"食物:"</span> &lt;&lt; m_food &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></div><div class="line">            &lt;&lt; <span class="string">"饮料:"</span> &lt;&lt; m_drink &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> Meal::buildFood(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t_food) &#123; m_food = t_food; &#125;</div><div class="line"><span class="keyword">void</span> Meal::buildDrink(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;t_drink) &#123; m_drink = t_drink; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilder.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BUILDER_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUILDER_HPP</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Meal.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MealBuilder();</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildFood</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildDrink</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt; getResult();</div><div class="line">  <span class="keyword">virtual</span> ~MealBuilder()&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt; m_meal;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilder.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilder.hpp"</span></span></div><div class="line">MealBuilder::MealBuilder() : m_meal(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt;(<span class="keyword">new</span> Meal())) &#123;&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt; MealBuilder::getResult() &#123; <span class="keyword">return</span> m_meal; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilderA.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MEALBUILDERA_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MEALBUILDERA_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilder.hpp"</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MealBuilderA</span> :</span> <span class="keyword">public</span> MealBuilder &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildFood</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildDrink</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilderA.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilderA.hpp"</span></span></div><div class="line"><span class="keyword">void</span> MealBuilderA::buildFood() &#123; m_meal-&gt;buildFood(<span class="string">"套餐A食物"</span>); &#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> MealBuilderA::buildDrink() &#123; m_meal-&gt;buildDrink(<span class="string">"套餐A饮料"</span>); &#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilderB.hpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MEALBUILDERB_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MEALBUILDERB_HPP_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilder.hpp"</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MealBuilderB</span> :</span> <span class="keyword">public</span> MealBuilder &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildFood</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildDrink</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MealBuilderB.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilderB.hpp"</span></span></div><div class="line"><span class="keyword">void</span> MealBuilderB::buildFood() &#123; m_meal-&gt;buildFood(<span class="string">"套餐B食物"</span>); &#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> MealBuilderB::buildDrink() &#123; m_meal-&gt;buildDrink(<span class="string">"套餐B饮料"</span>); &#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//main.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KFCWaiter.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilderA.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MealBuilderB.hpp"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt; Aptr =</div><div class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MealBuilder&gt;(<span class="keyword">new</span> MealBuilderA());</div><div class="line">  KFCWaiter k;</div><div class="line">  k.setMealBuilder(Aptr);</div><div class="line">  k.construct();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Meal&gt; current_meal = Aptr-&gt;getResult();</div><div class="line"></div><div class="line">  current_meal-&gt;getMeal();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/08/创建型设计模式之build模式/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/07/UML时序图详解/">
                            UML时序图详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-07T15:17:23+08:00">
	
		    1月 07, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/设计模式之路/">设计模式之路</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="UML时序图详解"><a href="#UML时序图详解" class="headerlink" title="UML时序图详解"></a>UML时序图详解</h1><p>　　这几天在阅读《设计模式》一书，书中总结了前人在面向对象软件设计过程中针对特定的问题提出的简洁而优雅的解决方案。在阅读的过程中，我一边理解书中给出的实例，一边结合自己写过的项目或者用过的框架与当前模式进行对比，发现之前的项目有一些还是有很大的改进空间。在阅读本书的过程中，书中很多例子都是通过UML类图和UML时序图进行说明，所以，理解这些例子的前提是对UML类图以及UML时序图有一定的了解，UML类图在前面的博客(<a href="https://langzi989.github.io/2017/01/05/UML%E5%9B%BE%E8%A1%A8%E7%A4%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/)中已经讲解，现在我们主要来看一下UML时序图中的重要概念。" target="_blank" rel="external">https://langzi989.github.io/2017/01/05/UML%E5%9B%BE%E8%A1%A8%E7%A4%BA%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/)中已经讲解，现在我们主要来看一下UML时序图中的重要概念。</a></p>
<p>　　UML类关系以及时序图在大三上《系统分析与设计》课的时候学过，但是那个时候不知道这东西有什么用，所以没有认真学和理解。随着实战经验的增多，越来越能体会到这些在软件设计的过程中重中之重，不管是描述你的设计思想还是与团队中其他人进行交流。所以还是建议大家在学到这一部分的时候对这门课认真对待。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>时序图是一种按照时间顺序显示对象之间的交互的图。时序图中显示的是参与交互的对象和对象之间消息传递的顺序。</p>
<h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><p>时序图中包含的主要的元素有:</p>
<ul>
<li>角色(Actor)</li>
<li>对象(Object)</li>
<li>生命线(life line)</li>
<li>控制焦点(focus of control)</li>
<li>消息(message)</li>
<li>自关联消息(self-associated message)</li>
<li>组合片段(combined fragment)</li>
</ul>
<h2 id="基本元素详解"><a href="#基本元素详解" class="headerlink" title="基本元素详解"></a>基本元素详解</h2><h3 id="角色-actor"><a href="#角色-actor" class="headerlink" title="角色(actor)"></a>角色(actor)</h3><p>角色指的是系统角色，这个角色可以是人，其他系统或者子系统</p>
<p>图形表示:</p>
<p><img src="/images/actor.png" alt=""></p>
<h3 id="对象-object"><a href="#对象-object" class="headerlink" title="对象(object)"></a>对象(object)</h3><p>对象包括三种:</p>
<ul>
<li>指定类名和对象名的对象objectName: className</li>
<li>指定类名但没有对象名的对象(匿名对象) :className</li>
<li>指定对象名但不指定类名的对象 objectName</li>
</ul>
<p>图形表示：<br>第一类:</p>
<p><img src="/images/object1.png" alt=""></p>
<p>第二类:</p>
<p><img src="/images/object2.png" alt=""></p>
<p>第三类:</p>
<p><img src="/images/object3.png" alt=""></p>
<h3 id="生命线-life-line"><a href="#生命线-life-line" class="headerlink" title="生命线(life line)"></a>生命线(life line)</h3><p>生命线在时序图中使用向下的虚线表示,它指的是其所对应的对象的存活时间。从上到下表示时间的推后。</p>
<p>图像表示:</p>
<p><img src="/images/lifeline.png" alt=""></p>
<h3 id="控制焦点-focus-of-control"><a href="#控制焦点-focus-of-control" class="headerlink" title="控制焦点(focus of control)"></a>控制焦点(focus of control)</h3><p>控制焦点在时序图中以方块的形式出现，它是一种表示时间段的方式，对象在这一时间段中执行相应的操作。</p>
<p>图像表示:</p>
<p><img src="/images/control.png" alt=""></p>
<h3 id="消息-message"><a href="#消息-message" class="headerlink" title="消息(message)"></a>消息(message)</h3><p>消息有三种类型</p>
<ul>
<li>同步消息：发送者发送请求后被阻塞，直到接受者返回消息或者做完其他处理之后发送者才能继续执行之后的操作</li>
<li>异步消息：发送者发送消息给接受者之后不等待接受者返回响应而继续执行下面的操作。</li>
<li>返回消息:接受者返回消息给发送者</li>
</ul>
<p>消息的图形表示：<br>同步消息:</p>
<p><img src="/images/message1.png" alt=""></p>
<p>异步消息:</p>
<p><img src="/images/message2.png" alt=""></p>
<p>返回消息:</p>
<p><img src="/images/message3.png" alt=""></p>
<h3 id="自关联消息-self-associated-message"><a href="#自关联消息-self-associated-message" class="headerlink" title="自关联消息(self-associated message)"></a>自关联消息(self-associated message)</h3><p>自关联消息一般指的是当前类调用自己的函数的情况</p>
<h3 id="组合片段-combined-fragment"><a href="#组合片段-combined-fragment" class="headerlink" title="组合片段(combined fragment)"></a>组合片段(combined fragment)</h3><p>组合片段中包括四个部分:</p>
<ul>
<li><p>Alternative fragment(alt表示):与if…then…else…对应</p>
</li>
<li><p>option fragment(opt表示):与switch对应</p>
</li>
<li><p>parallel fragment(par表示):表示同时发生</p>
</li>
<li><p>Loop Fragment(loop表示):与循环对应</p>
<p>图形表示:</p>
<p>alt:</p>
<p><img src="/images/alt.png" alt=""></p>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/07/UML时序图详解/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/01/05/UML图表示常见的类之间的关系/">
                            UML图表示常见的类之间的关系
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-01-05T21:12:28+08:00">
	
		    1月 05, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/设计模式之路/">设计模式之路</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="UML图表示常见的类之间的关系"><a href="#UML图表示常见的类之间的关系" class="headerlink" title="UML图表示常见的类之间的关系"></a>UML图表示常见的类之间的关系</h1><p>类之间的关系常见的主要包括以下几种:</p>
<ul>
<li>继承</li>
<li>实现</li>
<li>依赖</li>
<li>关联</li>
<li>聚合</li>
<li>组合</li>
</ul>
<h2 id="继承（inheritance）"><a href="#继承（inheritance）" class="headerlink" title="继承（inheritance）"></a>继承（inheritance）</h2><p>继承的概念大家都比较熟悉，他主要指的是派生类继承父类或者接口之间的继承，派生类继承了父类中原有的功能，并在此基础上添加了新的功能。例如public继承实质上是一种is-a的关系,(子类is a 基类)</p>
<p>图形表示:</p>
<p><img src="/images/继承.png" alt=""></p>
<h2 id="实现-implement"><a href="#实现-implement" class="headerlink" title="实现(implement)"></a>实现(implement)</h2><p>实现指的是一个类实现一个接口,一个类可以实现一个或者多个接口。实现是类和接口之间常见的一种关系。在java中通常通过implements实现。</p>
<p>图形表示：</p>
<p><img src="/images/实现.png" alt=""></p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>依赖指的是一个类A使用另外一个类B,这种该使用关系是偶然性的，临时的，非常弱的一种关系。但是类B的变化会影响到类A;比如人要使用船过河中，这个时候人和船就是一种依赖关系。具体表现在代码中就是<strong>B是类A中的某个方法的参数。</strong></p>
<p>图形表示:</p>
<p><img src="/images/依赖.png" alt=""></p>
<h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>关联是指俩个类之间的或者类和接口之间的一种强依赖关系。而这种强依赖关系不是偶然性的，而是长期的，而且双方的关系是平等的，关联可以是单向的，也可以是双向的。具体表现在代码中是<strong>(1):B以类属性的方式出现在类A中（２）A引用类型为B的全局变量</strong></p>
<p>图形表示:</p>
<p><img src="/images/关联.png" alt=""></p>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>聚合是关联关系的一种特例，它表现的是一种has-a的关系，即整体与部分的关系，此时整体与部分可以是分离的，他们可以具有各自的声明周期，部分可以属于多个整体对象，也可以被多个整体对象共享；如计算机与CPU的关系<strong>聚合中部分和整体都有各自的生命周期，并且互相影响</strong></p>
<p>图形表示：</p>
<p><img src="/images/聚合.png" alt=""></p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>组合也是关联的一种特例，它体现的是一种contain-a的关系，这种关系比聚合强；这个时候整体和部分是不可分离的，<strong>整体的声明周期与部分的声明周期相同，当整体的周期结束时，部分的周期也随之结束</strong>。如人和大脑的关系</p>
<p>图形表示：</p>
<p><img src="/images/组合.png" alt=""></p>
<h2 id="依赖性强弱"><a href="#依赖性强弱" class="headerlink" title="依赖性强弱:"></a>依赖性强弱:</h2><p>组合&gt;聚合&gt;关联&gt;依赖</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/01/05/UML图表示常见的类之间的关系/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/29/docker防止fork炸弹/">
                            docker防止fork炸弹
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-29T19:00:25+08:00">
	
		    12月 29, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/docker技术/">docker技术</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="docker防止fork炸弹"><a href="#docker防止fork炸弹" class="headerlink" title="docker防止fork炸弹"></a>docker防止fork炸弹</h1><p>在开发过程中，我们使用了docker作为容器来进行编程语言代码的评测，以用于防止有害代码破坏宿主物理机器，但是在昨天发现docker还是会受fork炸弹的影响将宿主物理机器挂掉。针对这个问题，我在docker官网找到了相关的解决方法，记录分享并以备之后再次遇到此类问题可以很快找到解决方案。<br>当前解决方案只适用于docker1.1版本及之后(通过docker.io进行安装,sudo apt install docker.io)。<br>解决方案的思想就是:在启动docker的时候给其加上启动选项–pids-limit来限制cgroup中的fork的进程的最大数，我这里限制的30,可以根据自己的需求去限制。<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it --pids-limit <span class="number">30</span> Ubuntu:<span class="number">14.04</span></div></pre></td></tr></table></figure></p>
<p>上述方法即可防止fork炸弹。<br>以下内容转载自<a href="http://blog.csdn.net/thinkhy/article/details/50995720" target="_blank" rel="external">http://blog.csdn.net/thinkhy/article/details/50995720</a></p>
<h2 id="Docker容器与安全"><a href="#Docker容器与安全" class="headerlink" title="Docker容器与安全"></a>Docker容器与安全</h2><p>Docker能否大规模用于生产环境，尤其是公有云环境，就在于Docker是否能提供安全的环境。本文将总结《Docker容器与容器云》一书3.9节『Docker与容器安全』的主要内容，包括Docker现有安全机制、存在的安全问题以及Docker安全增强三个方面。</p>
<h3 id="1-Docker的安全机制"><a href="#1-Docker的安全机制" class="headerlink" title="1. Docker的安全机制"></a>1. Docker的安全机制</h3><h4 id="1-1-Docker-daemon安全"><a href="#1-1-Docker-daemon安全" class="headerlink" title="1.1 Docker daemon安全"></a>1.1 Docker daemon安全</h4><ul>
<li>Docker向外界服务提供了四种通信方式，默认是以Unix域套接字的方式来与客户端通信，这种方式较TCP形式更为安全。</li>
<li>Docker也提供了TLS传输层安全协议，通过–tlsverify(安全传输校验），–tlscacert(信任证书)、–tlskey(服务器或者客户端秘钥）、–tlscert（证书位置）来配置。<h4 id="1-2-镜像安全"><a href="#1-2-镜像安全" class="headerlink" title="1.2 镜像安全"></a>1.2 镜像安全</h4></li>
<li><p>Docker registry镜像库访问控制</p>
<ul>
<li>Docker daemon第一次启动时，通过公网（Amazon CDN）载入official.json包，饮食公共image和用户image的目录以及数字签名信息。</li>
<li>official.json在Docker daemon启动时加载到MemoryGraph，MemoryGraph用于存储公钥以及命名之间的授权映射，默认授权节点对授权空间有读写权限。</li>
</ul>
</li>
<li><p>镜像校验和</p>
<ul>
<li>镜像校验和用来保证镜像的完整性，以预防可能出现的镜像破环。</li>
<li>目前Docker对于镜像校验和和验证失败不采取任何措施，仅输出警告信息<h4 id="1-3-内核安全"><a href="#1-3-内核安全" class="headerlink" title="1.3 内核安全"></a>1.3 内核安全</h4></li>
</ul>
</li>
<li>内核为容器提供了两种技术cgroup和namespace，分别对容器进行资源限制和资源隔离。<ul>
<li>容器本质是进程，cgroup用来限制容器的资源使用量，避免单个容器耗尽系统资源。</li>
</ul>
</li>
<li>namespace用来隔离容器与宿主机，以及不同的容器。<ul>
<li>Docker目前仅完整支持uts、ipc、pid、network、mount这5种ns,user ns尚未完全支持。</li>
<li>系统资源未进行隔离，如/proc，/sys、SELinux、time、syslog、/dev设备信息等均未进行隔离。<h4 id="1-4-容器之间的网络安全"><a href="#1-4-容器之间的网络安全" class="headerlink" title="1.4 容器之间的网络安全"></a>1.4 容器之间的网络安全</h4></li>
</ul>
</li>
<li>Docker可通过iptabls设定规则实现禁止或允许容器之间的通信。<h4 id="1-5-Docker容器Capability限制"><a href="#1-5-Docker容器Capability限制" class="headerlink" title="1.5 Docker容器Capability限制"></a>1.5 Docker容器Capability限制</h4></li>
<li>容器的行为通过Linux超级用户分组限制，具体包括了CHOWN、DAC_OVERRIDe、FSETID、FOWNER、MKNOD、NET_RAW、SETGID、SETUID、SETFCAP、SETPCAP、NET_BIND_SERVICE、SYS_CHROOT、KILL和AUDIT_WRITE。</li>
<li>Docker进程的Capability可通过docker run命令的参数进行配置<h3 id="2-Docker安全问题"><a href="#2-Docker安全问题" class="headerlink" title="2. Docker安全问题"></a>2. Docker安全问题</h3><h4 id="2-1-磁盘资源限制问题"><a href="#2-1-磁盘资源限制问题" class="headerlink" title="2.1 磁盘资源限制问题"></a>2.1 磁盘资源限制问题</h4></li>
<li>Docker容器通过镜像层叠的方式来构建容器内的文件系统，本质上还是在宿主机文件系统的目录(/var/lib/docker)下存储文件。</li>
<li>极有可能出现一个容器将宿主机上所有的磁盘空间耗尽，导致其它容器无法存储文件，所以有必要对容器的磁盘使用量进行限制。<h4 id="2-2-容器逃逸问题"><a href="#2-2-容器逃逸问题" class="headerlink" title="2.2 容器逃逸问题"></a>2.2 容器逃逸问题</h4></li>
<li>Docker使用操作系统进行虚拟化，共享内核、内存、CPU以及磁盘，易造成容器逃逸问题。</li>
<li>Docker1.0之后采用白名单来限制容器的能力，会给出默认的容器Capability清单，禁止容器拥有清单之外的Capability。<h4 id="2-3-容器DoS攻击与流量限制问题"><a href="#2-3-容器DoS攻击与流量限制问题" class="headerlink" title="2.3 容器DoS攻击与流量限制问题"></a>2.3 容器DoS攻击与流量限制问题</h4></li>
<li>公有云基于虚拟化技术实现，攻击数据包可能不需要通过物理网卡就可以攻击同一个宿主机下的其他容器，传统Dos预防措施无法适用容器之间的攻击。</li>
<li>的Docker容器连接在网桥上，通过veth pari技术创建网卡，其一端在容器内命名为eth0，另一张网上驻留在宿主机环境之中。</li>
<li>同一宿主机下所有容器共用一张物理网卡，如果一个容器抢占大部分带宽，会影响其它容器使用。<h4 id="2-4-超级权限问题"><a href="#2-4-超级权限问题" class="headerlink" title="2.4 超级权限问题"></a>2.4 超级权限问题</h4></li>
<li>docker run时加入–privileged参数能使容器获得所有的超级用户权限能力，并将所有的宿主机的所有设备挂载到容器内。<h3 id="3-Docker安全的解决方案"><a href="#3-Docker安全的解决方案" class="headerlink" title="3. Docker安全的解决方案"></a>3. Docker安全的解决方案</h3><h4 id="3-1-SELinux"><a href="#3-1-SELinux" class="headerlink" title="3.1 SELinux"></a>3.1 SELinux</h4></li>
<li>SELinux三种控制方式<ul>
<li>Type Enforcement: 主要的访问控制机制。</li>
<li>Role-Based Access Control(RBAC)：基于SELinux用户的权限控制手段。</li>
<li>Multi-Level Security(MLS): 多级分类安全，指定level标签。</li>
</ul>
</li>
<li>为什么要在Docker中使用SELinux<ul>
<li>SELinux将所有进程和文件打上标签，而容器以进程方式运行，所以控制进程如何访问资源，也就是限制容器如何去访问资源。</li>
<li>SELinux策略是全局的，它不是针对具体用户设定，而是强制整个系统遵循。</li>
<li>减少提权攻击风险。<h4 id="3-2-user-namespace"><a href="#3-2-user-namespace" class="headerlink" title="3.2 user namespace"></a>3.2 user namespace</h4></li>
</ul>
</li>
<li>容器的超级用户权限通过ns映射到宿主机是一个普通用户。</li>
<li>容器被恶意程序攻击，所做的也就是这个普通用户的权限，而非宿主机的超级权限。<h4 id="3-3-磁盘限额"><a href="#3-3-磁盘限额" class="headerlink" title="3.3 磁盘限额"></a>3.3 磁盘限额</h4></li>
<li>Docker仅对Device Mapper文件系统的限额提供了–storage-opt参数进行限制。</li>
<li>cgroup没有对磁盘进行限制，Linux磁盘限额技术主要基于用户和文件系统。</li>
<li>可能的解决方案<ul>
<li>所有用户共有宿主机的一块磁盘，限制用户在磁盘上的使用量来限定容器的磁盘使用量。</li>
<li>选择支持目录限额的文件系统，如XFS。</li>
<li>Docker定期检查每一个容器磁盘使用量，会对性能造成影响。</li>
<li>创建虚拟文件系统，些文件系统仅供某一个容器使用。<h4 id="3-4-容器流量限制"><a href="#3-4-容器流量限制" class="headerlink" title="3.4 容器流量限制"></a>3.4 容器流量限制</h4></li>
</ul>
</li>
<li>Docker没对容器的网络带宽做限制。</li>
<li>可以采用Traffic Controller容器对容器网卡流量进行限制，一定程序上减少容器Dos攻击危害。<h4 id="3-5-GRSecurity内核安全增强工具"><a href="#3-5-GRSecurity内核安全增强工具" class="headerlink" title="3.5 GRSecurity内核安全增强工具"></a>3.5 GRSecurity内核安全增强工具</h4></li>
<li>Docker容器共享宿主机的内存，在内存安全上存在不少问题，需要针对内存破坏做防御。</li>
<li>GRSecurity是一个对内核的安全扩展，通过智能访问控制来阻止内存破坏，预防0day漏洞。<h4 id="3-6-fork炸弹"><a href="#3-6-fork炸弹" class="headerlink" title="3.6 fork炸弹"></a>3.6 fork炸弹</h4></li>
<li>fork炸弹以极快速度创建大量进程，以此消耗系统资源，使系统无法运行新程序，现有进程运行速度放缓。</li>
<li>容器本身在内核层面隔离性不足，fork bomb会给容器带来灾难性影响。</li>
<li>fork bomb受到社区关注（Issue 6479），但目前还没有完美解决方案。</li>
<li>Docker无法使用ulimit来限制forkbomb问题，因为一个宿主机用户可能同时启动多个容器，无法对每个容器做进程数的限制。</li>
</ul>
<ol>
<li>总结<br>Docker自身已经提供了不少安全机制，但Docker目前仍然只适于运行可信应用程序（内部使用），如果需要运行任意代码，安全很难得到保证。在日常应用中，还可以通过SELinux、GRSecurity、seccomp等工具来增强容器安全。</li>
</ol>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/12/29/docker防止fork炸弹/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/27/time命令详解/">
                            time命令详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-27T21:18:33+08:00">
	
		    12月 27, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/linux笔记/">linux笔记</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Linux-time命令详解"><a href="#Linux-time命令详解" class="headerlink" title="Linux time命令详解"></a>Linux time命令详解</h1><p>参考:<a href="http://blog.he96.com/2011/01/linux-timewhat-do-real-user-and-sys.html" target="_blank" rel="external">http://blog.he96.com/2011/01/linux-timewhat-do-real-user-and-sys.html</a></p>
<h2 id="real-user-sys"><a href="#real-user-sys" class="headerlink" title="real,user,sys"></a>real,user,sys</h2><p>我们常用linux中的time命令计算某个程序的运行耗时，用户态CPU耗时，系统态COU耗时。<br>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">time foo</div><div class="line">real	0m0.020s</div><div class="line">user	0m0.020s</div><div class="line">sys	0m0.000s</div></pre></td></tr></table></figure></p>
<p>现在我们探讨一下上述三个时间分别代表的含义:</p>
<ul>
<li>real: 表示a.out程序的实际的运行耗时，也就是在a.out运行开始时刻你看了一下手表，a.out运行结束时刻看了一眼手表，两次时间的差值就是real的值。例如使用time sleep 2的时候real值为2</li>
<li>user: a.out运行在用户态CPU的时间</li>
<li>sys: a.out运行在核心态CPU的时间</li>
</ul>
<h2 id="用户态和核心态"><a href="#用户态和核心态" class="headerlink" title="用户态和核心态"></a>用户态和核心态</h2><p>然后我们讲一下用户态和核心态：</p>
<ul>
<li>核心态(kernal mode): 在内核态，代码拥有完全的，不受任何限制的访问底层硬件的能力。可以执行任意的CPU指令，访问任意的内存地址。内核态通常情况下，都是为哪些最底层的，由操作系统提供的，可信可靠耳朵代码来运行的。内核态崩溃将是灾难性的，它会影响到整个系统。</li>
<li>用户态(User mode):在用户态，代码不具备直接访问底层硬件或者内存的能力，而必须借助操作系统提供的可靠的,底层的API来访问硬件或者内存。由于这种隔离带来的保护作用，用户态代码崩溃，操作系统可以正常恢复。我们大多数代码是运行在用户态。</li>
</ul>
<blockquote>
<p>区分内核态和用户态的<strong>作用</strong>:隔离保护，使得系统更稳定。<br>使用这三个时间我们可以计算当前程序CPU的使用率：<br>CPU Usage = (user + sys) / real_time</p>
</blockquote>
<h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><ul>
<li>realtime = user + sys</li>
<li>realtime &gt; user + sys<br>由于有一些程序需要等待I/O等导致realtime与user+sys不相等<br>当在多核CPU的情况下第二种情况不成立</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/12/27/time命令详解/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/22/C-前置声明/">
                            C++前置声明
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-22T22:08:31+08:00">
	
		    12月 22, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/C-学习/">C++学习</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="C-前置声明"><a href="#C-前置声明" class="headerlink" title="C++前置声明"></a>C++前置声明</h1><p>以个人理解，C++的前置声明的意思是在类定义之前对其进行声明。它在现实编程的场景中可以解决很多问题。比如解决两个类相互依赖的问题，降低类之间的编译依存关系等等。</p>
<h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><p>我们分别定义一个锁(Lock)和钥匙(Key)的类(默认一把钥匙只能开一把锁，一把锁只能被一把钥匙打开)。代码如下：<br>Lock.hpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Key.hpp"</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Lock();</div><div class="line">		<span class="keyword">virtual</span> ~Lock();</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		Key m_key;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Key.hpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Lock.hpp"</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> &#123;</span></div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Key();</div><div class="line">		<span class="keyword">virtual</span> ~Key();</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		m_lock;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候出现了两个类相互包含的情况，因为在编译Lock.cpp的时候，我们需要去查看Key的定义，于是去定义Key,在Key中需要Lock的定义，于是又去构造Lock,这样下去，就出现了一个无限循环包含的情况，有些编译器会直接编译错误，而其他编译器会无限包含下去。<br>这该怎么办呢？有办法，C++为我们提供了前置声明。前置声明是什么？就这个例子来讲，我们要造一把锁，光有锁不行啊，我们还得有能打开这把锁的钥匙。但是锁还没有造好，总不能先打造钥匙吧，钥匙的形状我定了，改天在造。先把锁造好，造锁的时候我要先给要是留一个位置，等锁造好了，我再决定造什么样的钥匙。<strong>前置声明就是我在声明一个类(Lock)的时候,用到了另外一个类（Key）的定义，但是Key还没定义呢，而且我先不需要Key的定义，只需要直到Key是一个类就好了。那好，我就先声明类Key,告诉编译器Key是一个类(不需要包含Key.hpp)</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span>;</span></div></pre></td></tr></table></figure></p>
<p>然后在Lock中用到Key的时候，都用指针或者引用代替(因为指针是固定大小的，但Key的大小只有知道了Key的定义才能确定)。然后上面的代码就可以改造为如下：</p>
<p>Lock.hpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span>;</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		Key *mp_key;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Lock();</div><div class="line">		<span class="keyword">virtual</span> ~Lock();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Key.hpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>;</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> &#123;</span></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		Lock* mp_lock;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		Key();</div><div class="line">		<span class="keyword">virtual</span> ~Key();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="前置声明注意的问题"><a href="#前置声明注意的问题" class="headerlink" title="前置声明注意的问题"></a>前置声明注意的问题</h2><h3 id="必须使用前置声明的指针或引用形式"><a href="#必须使用前置声明的指针或引用形式" class="headerlink" title="必须使用前置声明的指针或引用形式"></a>必须使用前置声明的指针或引用形式</h3><p>在需要使用前置声明的文件中，不可以使用类的定义式，因为类的定义式只有在类定义之后才能获取，这个时候类还没有定义，所以会出错。另一个类在构造的时候编译器是需要计算该对象所占的字节的大小给其分配内存的，但是如果使用类的定义式，这个时候类还未定义，所以无法计算其大小，所以只能使用指针或者引用的形式进行引用。</p>
<h3 id="避免在Lock中使用Key的方法"><a href="#避免在Lock中使用Key的方法" class="headerlink" title="避免在Lock中使用Key的方法"></a>避免在Lock中使用Key的方法</h3><h3 id="避免在Key定义之前调用Key的析构函数"><a href="#避免在Key定义之前调用Key的析构函数" class="headerlink" title="避免在Key定义之前调用Key的析构函数"></a>避免在Key定义之前调用Key的析构函数</h3>
                    
                        
                    
                    
                        <p>
                            <a href="/2016/12/22/C-前置声明/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/21/条款27-尽量少做转型动作/">
                            条款27:尽量少做转型动作
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-21T20:57:15+08:00">
	
		    12月 21, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/effective-C/">effective C++</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="条款27-尽量少做转型动作-Effective-C"><a href="#条款27-尽量少做转型动作-Effective-C" class="headerlink" title="条款27:尽量少做转型动作(Effective C++)"></a>条款27:尽量少做转型动作(Effective C++)</h1><p>C++规则设计的目标之一是，保证类型错误决不可能发生。理论上如果你的程序很干净的通过编译，就表示它并不企图在任何对象身上执行任何不安全，无意义，愚蠢荒谬的操作。这是一个及其具有价值的保证，不要轻易放弃它。<br>但是在很多种情况下，我们不得不进行转型操作，转型操作破坏了类型系统。这可能会导致任何可能种类的麻烦，有些容易辨识，但是有些可能会很隐晦。所以在需要进行转型操作的时候一定要慎重，尽量通过设计避免不必要的转型操作。</p>
<h2 id="类型转换的形式"><a href="#类型转换的形式" class="headerlink" title="类型转换的形式"></a>类型转换的形式</h2><p>首先我们回顾一下类型转换的语法，因为通常有三种不同的形式，可写出相同的类型转换动作。</p>
<ul>
<li>C风格类型转换： (T)expression    //将expression转换为类型T</li>
<li>函数式风格类型转换： T(expression) //同上<br>上面的两种形式并无差别，纯粹只是把小括号摆放的位置不同而已，我们称上述两种转为为”旧式转型”(old style cast)。</li>
</ul>
<p>C++还提供四中新式转型(new style):</p>
<ul>
<li>const_cast&lt; T &gt;(expression)</li>
<li>dynamic_cast&lt; T &gt;(expression)</li>
<li>reinterpret_cast&lt; T &gt;(expression)</li>
<li><p>static_cast&lt; T &gt;(expression)</p>
</li>
<li><p>const_cast通常被用来将对象的常量性移除(cast away the constness)。它也是唯一有此能力的C++-style转型操作符。</p>
</li>
<li>dynamic_cast主要用来执行类型向下转型(safe downcasting),也就是用来决定某对象是否归属继承体系中的某个类型。它是<strong>唯一无法由旧式语法执行的动作，也是唯一一个可能耗费重大运行成本的转型动作</strong>。</li>
<li>reinterpret_cast 意图执行低级转型，实际动作及结果可能取决于编译器。这也就表示它<strong>不可移植</strong>，例如将一个pointer to int 转型为int。这一类型转换在低级代码以外很少见。</li>
<li>static_cast 用来强迫隐式转换(implicit conversion)，例如将non-const对象转换为const对象，或者将int转换为double等等。也可以用来执行上述多种转换的反向转换,例如将void指针转换为type指针，将pointer to derive 转化为point to bas。但是无法将const转换为non-const。</li>
</ul>
<h2 id="dynamic-cast与static-cast详解"><a href="#dynamic-cast与static-cast详解" class="headerlink" title="dynamic_cast与static_cast详解"></a>dynamic_cast与static_cast详解</h2><p> static_cast是用来强迫隐式类型转换，它可以用于1.基本数据类型以及指针之间的转换；2.类层次中基类与子类成员函数指针的转换；3.类层次结构中基类与子类指针或者引用之间的转换。<br> dynamic_cast可以用于1.继承关系中类指针或者引用之间的转换；2.包含虚函数之间对象指针的转换3.以及保证转换的安全性。</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><h4 id="用于基本数据类型转换和指针之间的转换"><a href="#用于基本数据类型转换和指针之间的转换" class="headerlink" title="用于基本数据类型转换和指针之间的转换"></a>用于基本数据类型转换和指针之间的转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a;</div><div class="line"><span class="keyword">int</span> b = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(a);</div><div class="line"><span class="keyword">char</span> c = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(b);</div><div class="line"><span class="keyword">char</span> *pa = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">int</span> *pb = (<span class="keyword">int</span>*)pa;</div><div class="line">pb = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pa); <span class="comment">//编译错误static_cast只能用于void指针和type指针之间的转换</span></div><div class="line"><span class="keyword">void</span> *pv = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(pa); <span class="comment">//正确</span></div><div class="line">pb = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pv);</div></pre></td></tr></table></figure>
<h4 id="类层次中基类与子类成员函数指针的转换"><a href="#类层次中基类与子类成员函数指针的转换" class="headerlink" title="类层次中基类与子类成员函数指针的转换"></a>类层次中基类与子类成员函数指针的转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  base(<span class="keyword">int</span> t_data) : m_data(t_data) &#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printData</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">int</span> m_data;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">child</span> :</span> <span class="keyword">public</span> base &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  child(<span class="keyword">int</span> t_data) : base(t_data) &#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printData</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"this is in the child"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(base::*basefun)</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="function">base <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line">  basefun func = &amp;base::printData;</div><div class="line">  func = <span class="keyword">static_cast</span>&lt;basefun&gt;(&amp;child::printData);</div><div class="line">  (a.*func)();  <span class="comment">//this is in the child</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="类层次结构中基类与子类指针或者引用之间的转换"><a href="#类层次结构中基类与子类指针或者引用之间的转换" class="headerlink" title="类层次结构中基类与子类指针或者引用之间的转换"></a>类层次结构中基类与子类指针或者引用之间的转换</h4><p>上行转换:子类指针或引用转换为基类的指针或引用 —安全<br>下行转换:基类的指针或者引用转换为子类的指针或引用 —危险(避免这样做)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A objA;</div><div class="line">B objB;</div><div class="line">A* pObjA = <span class="keyword">new</span> A();</div><div class="line">B* pObjB = <span class="keyword">new</span> B();</div><div class="line">C* pObjC = <span class="keyword">new</span> C();</div><div class="line">D* pObjD = <span class="keyword">new</span> D();</div><div class="line"></div><div class="line">objA = <span class="keyword">static_cast</span>&lt;A&amp;&gt;(objB);     <span class="comment">//转换为基类引用    </span></div><div class="line">objA = <span class="keyword">static_cast</span>&lt;A&gt;(objB);</div><div class="line">objB = <span class="keyword">static_cast</span>&lt;B&gt;(objA);      <span class="comment">//error 不能进行转换  </span></div><div class="line"></div><div class="line">pObjA = pObjB;                    <span class="comment">//right 基类指针指向子类对象</span></div><div class="line"><span class="comment">//objB = objA;                      //error 子类指针指向基类对象</span></div><div class="line">pObjA = <span class="keyword">static_cast</span>&lt;A*&gt;(pObjB);   <span class="comment">//right 基类指针指向子类</span></div><div class="line">pObjB = <span class="keyword">static_cast</span>&lt;B*&gt;(pObjA);   <span class="comment">//强制转换 OK 基类到子类</span></div><div class="line"><span class="comment">//pObjC = static_cast&lt;C*&gt;(pObjB);   //error 继承于统一类的派生指针之间转换</span></div><div class="line"><span class="comment">//pObjD = static_cast&lt;D*&gt;(pObjC);   //error 两个无关联之间转换</span></div></pre></td></tr></table></figure></p>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><h4 id="继承关系的类指针对象或者引用之间的转换"><a href="#继承关系的类指针对象或者引用之间的转换" class="headerlink" title="继承关系的类指针对象或者引用之间的转换"></a>继承关系的类指针对象或者引用之间的转换</h4><p>若积累中没有虚函数，使用dynamic_cast可以将子类的指针或引用转换为基类的指针或引用，与static_cast用法相同，不同的是,这个时候使用dynamic_cast将基类指针转换为子类指针的时候会出现编译错误(static_cast不会，但是很危险)。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">A objA;</div><div class="line">B objB;</div><div class="line">A* pObjA = <span class="keyword">new</span> A();</div><div class="line">B* pObjB = <span class="keyword">new</span> B();</div><div class="line">C* pObjC = <span class="keyword">new</span> C();</div><div class="line">D* pObjD = <span class="keyword">new</span> D();</div><div class="line"><span class="comment">//objA = dynamic_cast&lt;A&gt;(objB);         //error 非引用</span></div><div class="line"></div><div class="line">objA = <span class="keyword">dynamic_cast</span>&lt;A&amp;&gt;(objB);</div><div class="line"><span class="comment">//objB = dynamic_cast&lt;B&amp;&gt;(objA);      //error A 不是多态类型不能转换 若有虚函数则可以进行转换</span></div><div class="line"></div><div class="line">pObjA = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(pObjB);</div><div class="line"><span class="comment">//pObjB = dynamic_cast&lt;B*&gt;(pObjA);    //error A 继承关系 不是多态类型不能转换</span></div><div class="line"><span class="comment">//pObjB = dynamic_cast&lt;B*&gt;(pObjC);    //error C 兄弟关系 不是多态类型不能转换</span></div><div class="line"><span class="comment">//pObjB = dynamic_cast&lt;B*&gt;(pObjD);    //error D 没有关系 不是多态类型不能转换</span></div></pre></td></tr></table></figure></p>
<h4 id="包含有虚函数之间的对象指针的转换"><a href="#包含有虚函数之间的对象指针的转换" class="headerlink" title="包含有虚函数之间的对象指针的转换"></a>包含有虚函数之间的对象指针的转换</h4><p>使用dynamic_cast将基类指针转换为子类指针的时候并不是永远有效：只有基类指针本身指向的就是一个派生类对象的时候有效。其他时候结果为NULL;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">&#123;</div><div class="line">Public:</div><div class="line">     Virtual ~A()&#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></div><div class="line">&#123;</div><div class="line">Public:</div><div class="line">Virtual ~D()&#123;&#125;</div><div class="line">&#125;;</div><div class="line">pObjB = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pObjA);    <span class="comment">// worning 继承关系 父类具有虚函数 多态</span></div><div class="line">pObjB = <span class="keyword">dynamic_cast</span>&lt;B*&gt;(pObjD);    <span class="comment">//worning 没有关系 D是多态类型可以转换</span></div><div class="line"><span class="comment">//以上结果：pObjB == NULL 此处会发生一个运行时错误</span></div></pre></td></tr></table></figure></p>
<h4 id="dynamic-cast转换的安全性"><a href="#dynamic-cast转换的安全性" class="headerlink" title="dynamic_cast转换的安全性"></a>dynamic_cast转换的安全性</h4><p>当涉及到基类和派生类对象之间的转换的时候，总使用dynamic_cast会避免很多错误，它是安全的，但是它会给程序运行带来巨大的开销。<br>当子类指针转换为基类指针的时候,两种转型都OK,dynamic_cast开销较大。<br>当基类指针转换为派生类指针的时候，若基类中没有虚函数，static_cast不会报错，但是做法很危险，dynamic_cast编译不通过。当含有虚函数的时候，若基类指针没有指向派生类，这个时候会返回NULL,所以也是安全的。</p>
<h4 id="虚函数对于dynamic-cast转换的作用"><a href="#虚函数对于dynamic-cast转换的作用" class="headerlink" title="虚函数对于dynamic_cast转换的作用"></a>虚函数对于dynamic_cast转换的作用</h4><p>为什么dynamic_cast转换类指针的时候需要虚函数呢？<br>dynamic_cast转换是在运行时进行转换，运行时转换就需要知道类对象的信息(继承关系等)。<br>在运行时或者这个信息的是虚函数表指针，通过这个指针可以获取到该类对象的所有的虚函数，包括父类的。因为派生类会继承基类的虚函数表，所以通过这个虚函数表，我们就可以知道类对象的父类，在转换的时候就可以用来判断对象有无继承关系。<br><strong>所以虚函数对于正确的基类指针转换为子类指针是非常重要的。</strong></p>
<h2 id="effective的三点建议"><a href="#effective的三点建议" class="headerlink" title="effective的三点建议"></a>effective的三点建议</h2><ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏与某个函数的背后。客户随后可以调用该函数，而不需要将转型放到他们自己的代码中。</li>
<li>宁可使用C++-style转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/12/21/条款27-尽量少做转型动作/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/19/通过-proc-meminfo实时获取系统内存使用情况/">
                            通过/proc/meminfo实时获取系统内存使用情况
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-19T23:43:49+08:00">
	
		    12月 19, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/linux笔记/">linux笔记</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="通过-proc-meminfo实时获取系统内存使用情况-Linux"><a href="#通过-proc-meminfo实时获取系统内存使用情况-Linux" class="headerlink" title="通过/proc/meminfo实时获取系统内存使用情况(Linux)"></a>通过/proc/meminfo实时获取系统内存使用情况(Linux)</h1><p>linux内核提供了一种通过/proc文件系统来在运行时访问内核内部数据结构，改变内核设置的机制，各种硬件平台上的linux系统的/proc文件系统的基本概念都是相同的。<br>/proc文件系统是一种内核和内核模块用来向进程发送信息的机制。这个伪文件系统可以和内核内部的数据结构进行交互，获取实时的进程信息。注意，<strong>/proc文件系统是存储与内存而不是硬盘,/proc虚拟文件系统实质是以文件系统的形式访问内核数据的接口</strong>。</p>
<h2 id="proc-meminfo"><a href="#proc-meminfo" class="headerlink" title="/proc/meminfo"></a>/proc/meminfo</h2><p>linux系统中/proc/meminfo这个文件用来记录了系统内存使用的详细情况。其中top，free命令中的数据是通过这个文件中的信息计算并按照特定的格式进行显示。<br>/proc/meminfo内容详解：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$cat</span> /proc/meminfo</div><div class="line">MemTotal:        <span class="number">8052444</span> kB</div><div class="line">MemFree:         <span class="number">2754588</span> kB</div><div class="line">MemAvailable:    <span class="number">3934252</span> kB</div><div class="line">Buffers:          <span class="number">137128</span> kB</div><div class="line">Cached:          <span class="number">1948128</span> kB</div><div class="line">SwapCached:            <span class="number">0</span> kB</div><div class="line">Active:          <span class="number">3650920</span> kB</div><div class="line">Inactive:        <span class="number">1343420</span> kB</div><div class="line">Active(anon):    <span class="number">2913304</span> kB</div><div class="line">Inactive(anon):   <span class="number">727808</span> kB</div><div class="line">Active(file):     <span class="number">737616</span> kB</div><div class="line">Inactive(file):   <span class="number">615612</span> kB</div><div class="line">Unevictable:         <span class="number">196</span> kB</div><div class="line">Mlocked:             <span class="number">196</span> kB</div><div class="line">SwapTotal:       <span class="number">8265724</span> kB</div><div class="line">SwapFree:        <span class="number">8265724</span> kB</div><div class="line">Dirty:               <span class="number">104</span> kB</div><div class="line">Writeback:             <span class="number">0</span> kB</div><div class="line">AnonPages:       <span class="number">2909332</span> kB</div><div class="line">Mapped:           <span class="number">815524</span> kB</div><div class="line">Shmem:            <span class="number">732032</span> kB</div><div class="line">Slab:             <span class="number">153096</span> kB</div><div class="line">SReclaimable:      <span class="number">99684</span> kB</div><div class="line">SUnreclaim:        <span class="number">53412</span> kB</div><div class="line">KernelStack:       <span class="number">14288</span> kB</div><div class="line">PageTables:        <span class="number">62192</span> kB</div><div class="line">NFS_Unstable:          <span class="number">0</span> kB</div><div class="line">Bounce:                <span class="number">0</span> kB</div><div class="line">WritebackTmp:          <span class="number">0</span> kB</div><div class="line">CommitLimit:    <span class="number">12291944</span> kB</div><div class="line">Committed_AS:   <span class="number">11398920</span> kB</div><div class="line">VmallocTotal:   <span class="number">34359738367</span> kB</div><div class="line">VmallocUsed:           <span class="number">0</span> kB</div><div class="line">VmallocChunk:          <span class="number">0</span> kB</div><div class="line">HardwareCorrupted:     <span class="number">0</span> kB</div><div class="line">AnonHugePages:   <span class="number">1380352</span> kB</div><div class="line">CmaTotal:              <span class="number">0</span> kB</div><div class="line">CmaFree:               <span class="number">0</span> kB</div><div class="line">HugePages_Total:       <span class="number">0</span></div><div class="line">HugePages_Free:        <span class="number">0</span></div><div class="line">HugePages_Rsvd:        <span class="number">0</span></div><div class="line">HugePages_Surp:        <span class="number">0</span></div><div class="line">Hugepagesize:       <span class="number">2048</span> kB</div><div class="line">DirectMap4k:      <span class="number">201472</span> kB</div><div class="line">DirectMap2M:     <span class="number">5967872</span> kB</div><div class="line">DirectMap1G:     <span class="number">3145728</span> kB</div></pre></td></tr></table></figure></p>
<p>详解：</p>
<ul>
<li>MemTotal: 所有内存(RAM)大小,减去一些预留空间和内核的大小。</li>
<li>MemFree: 完全没有用到的物理内存，lowFree+highFree</li>
<li>MemAvailable: 在不使用交换空间的情况下，启动一个新的应用最大可用内存的大小，计算方式：MemFree+Active(file)+Inactive(file)-(watermark+min(watermark,Active(file)+Inactive(file)/2))</li>
<li>Buffers:  块设备所占用的缓存页，包括：直接读写块设备以及文件系统元数据(metadata)，比如superblock使用的缓存页。</li>
<li>Cached:  表示普通文件数据所占用的缓存页。</li>
<li>SwapCached:  swap cache中包含的是被确定要swapping换页，但是尚未写入物理交换区的匿名内存页。那些匿名内存页，比如用户进程malloc申请的内存页是没有关联任何文件的，如果发生swapping换页，这类内存会被写入到交换区。</li>
<li>Active:  active包含active anon和active file</li>
<li>Inactive:  inactive包含inactive anon和inactive file</li>
<li>Active(anon):  anonymous pages（匿名页），用户进程的内存页分为两种：与文件关联的内存页(比如程序文件,数据文件对应的内存页)和与内存无关的内存页（比如进程的堆栈，用malloc申请的内存），前者称为file pages或mapped pages,后者称为匿名页。</li>
<li>Inactive(anon):   见上</li>
<li>Active(file):  见上</li>
<li>Inactive(file): 见上</li>
<li>SwapTotal:  可用的swap空间的总的大小(swap分区在物理内存不够的情况下，把硬盘空间的一部分释放出来，以供当前程序使用)</li>
<li>SwapFree:   当前剩余的swap的大小</li>
<li>Dirty:   需要写入磁盘的内存去的大小</li>
<li>Writeback:  正在被写回的内存区的大小</li>
<li>AnonPages:  未映射页的内存的大小</li>
<li>Mapped:   设备和文件等映射的大小</li>
<li>Slab:  内核数据结构slab的大小</li>
<li>SReclaimable:  可回收的slab的大小</li>
<li>SUnreclaim:   不可回收的slab的大小</li>
<li>PageTables:   管理内存页页面的大小</li>
<li>NFS_Unstable:   不稳定页表的大小</li>
<li>VmallocTotal:   Vmalloc内存区的大小</li>
<li>VmallocUsed:     已用Vmalloc内存区的大小</li>
<li>VmallocChunk:  vmalloc区可用的连续最大快的大小</li>
</ul>
<h2 id="通过-proc-meminfo实时获取系统内存使用情况"><a href="#通过-proc-meminfo实时获取系统内存使用情况" class="headerlink" title="通过/proc/meminfo实时获取系统内存使用情况"></a>通过/proc/meminfo实时获取系统内存使用情况</h2><p><a href="http://man.linuxde.net/free" target="_blank" rel="external">http://man.linuxde.net/free</a><br>目前我们希望实时获取系统中内存的使用情况，实际可以挪用的内存数为free+cache+buffer,实际使用的内存数为used-cache-buffer(total-free-cache-buffer),</p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/12/19/通过-proc-meminfo实时获取系统内存使用情况/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2016/12/19/通过-proc-stat计算linux系统即时CPU使用率/">
                            通过/proc/stat计算linux系统即时CPU使用率
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2016-12-19T06:03:09+08:00">
	
		    12月 19, 2016
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/linux笔记/">linux笔记</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="通过-proc-stat计算linux系统即时CPU使用率"><a href="#通过-proc-stat计算linux系统即时CPU使用率" class="headerlink" title="通过/proc/stat计算linux系统即时CPU使用率"></a>通过/proc/stat计算linux系统即时CPU使用率</h1><h2 id="proc-stat"><a href="#proc-stat" class="headerlink" title="/proc/stat"></a>/proc/stat</h2><p>/proc文件系统是一个伪文件系统，它存在于内存中，不占用外存空间。它以文件系统的方式为内核与进程提供通信接口。用户和应用程序可以通过/proc得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程是动态改变的，所以用户或应用程序读取/proc目录中的文件的时，/proc文件系统是动态从系统内核读出所需信息并提交的。<br>在linux或Ubuntu系统中，/proc/stat文件记录了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前的值。我们可以通过一个较小的时间段的CPU利用率值来估算某一个时刻的CPU利用率。首先我们先来查看一下/proc/stat中的内容：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ cat /proc/stat</div><div class="line">cpu  <span class="number">15543</span> <span class="number">334</span> <span class="number">4963</span> <span class="number">142337</span> <span class="number">3413</span> <span class="number">0</span> <span class="number">180</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">cpu0 <span class="number">3877</span> <span class="number">142</span> <span class="number">1137</span> <span class="number">35988</span> <span class="number">615</span> <span class="number">0</span> <span class="number">28</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">cpu1 <span class="number">3866</span> <span class="number">23</span> <span class="number">1068</span> <span class="number">35982</span> <span class="number">608</span> <span class="number">0</span> <span class="number">74</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">cpu2 <span class="number">4104</span> <span class="number">159</span> <span class="number">1333</span> <span class="number">35395</span> <span class="number">735</span> <span class="number">0</span> <span class="number">59</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">cpu3 <span class="number">3695</span> <span class="number">9</span> <span class="number">1424</span> <span class="number">34970</span> <span class="number">1454</span> <span class="number">0</span> <span class="number">18</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>上面的信息中前八个是比较重要的。</p>
<ul>
<li>user(15543): 从系统启动到当前时刻，处于用户态的时间(用户空间的CPU时间)，不包括nice为负值的进程。</li>
<li>nice(334): 从系统启动到当前时刻，nice值为负的进程所占的CPU时间。</li>
<li>system(4963): 从系统启动到当前时刻，处于内核状态的CPU时间。</li>
<li>idle(142337): 从系统启动到当前时刻，除了I/O等待时间以外的其他等待时间</li>
<li>iowait(3413): ~，IO等待时间</li>
<li>irq(0): ~, 硬中断时间</li>
<li>softrq(180): ~,软中断时间。</li>
<li>steal: ~,在虚拟环境中运行的时间。</li>
</ul>
<blockquote>
<p>总的CPU时间为：total = user+nice+system+idle+iowait+irq+softrq</p>
</blockquote>
<h2 id="计算当前时刻的CPU使用率"><a href="#计算当前时刻的CPU使用率" class="headerlink" title="计算当前时刻的CPU使用率"></a>计算当前时刻的CPU使用率</h2><p>我们使用距离当前时刻较小的间隔的时间段的CPU使用率近似当前时刻的CPU使用率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CPU Usage=1 - (△idle+△iowait) / △total_time</div><div class="line">		 =1 - (idle2+iowait2 - idle1 - iowait1) / (total_time2 - total_time1)</div></pre></td></tr></table></figure></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2016/12/19/通过-proc-stat计算linux系统即时CPU使用率/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/archives/page/6/">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>NEWER POSTS</span>
            </a>
        </li>
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/page/8/">
                    <span>OLDER POSTS</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">page 7 of 8</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 魏传柳(2824759538@qq.com). All Rights Reserved.
    </span>
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
     </script>
   </br></br>本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avar.jpg"/>
        
            <h4 id="about-card-name">魏传柳(2824759538@qq.com)</h4>
        
            <h5 id="about-card-bio"><p>author.bio</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Guangzhou,China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script-i4qo6jx6jji9fg0dftpya6ivemizsbow4fhow76d8dwpm7m1wbvi378ssumx.min.js"></script>
<!--SCRIPTS END-->



</html>
