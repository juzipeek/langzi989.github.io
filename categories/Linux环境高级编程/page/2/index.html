
<!DOCTYPE html>
<html lang="zh-CN">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="魏传柳">
    <title>Category: Linux环境高级编程 - 魏传柳</title>
    <meta name="author" content="魏传柳(langzi989)">
    
        <meta name="keywords" content="hexo,javascript,">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta property="og:type" content="blog">
<meta property="og:title" content="魏传柳">
<meta property="og:url" content="http://yoursite.com/categories/Linux环境高级编程/page/2/index.html">
<meta property="og:site_name" content="魏传柳">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="魏传柳">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/avar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-nuvue6sithwirecbhvw3dkaobiojqvtadsnhguwi7k04xklybw5djl1smadp.min.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">魏传柳</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avar.jpg"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avar.jpg"/>
            </a>
            <span class="sidebar-profile-name">魏传柳(langzi989)</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">categories</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">archives</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link st-search-show-outputs"
                         href="#search"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                    <span class="sidebar-button-desc">search</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">about</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/langzi989" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="http://blog.csdn.net/u014630623" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-csdn"></i>
                    <span class="sidebar-button-desc">CSDN</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    

<section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/04/cgi原理/">
                            cgi原理
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-04T20:36:55+08:00">
	
		    5月 04, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="CGI原理"><a href="#CGI原理" class="headerlink" title="CGI原理"></a>CGI原理</h1><p>CGI（Common Gateway Interface）通用网关接口，CGI描述了服务器和请求处理程序之间传输数据局的一种标准。在理解的过程中我们需要区分CGI和CGI程序，CGI是一种数据传输的标准，而CGI程序是实际处理业务的一个程序。webserver每请求一次，CGI程序就会fork出一个子进程进行处理。CGI程序的参数通过环境变量和标准输入获得，它的相应通过标准输出传递给webServer。</p>
<h2 id="CGI的工作原理是："><a href="#CGI的工作原理是：" class="headerlink" title="CGI的工作原理是："></a>CGI的工作原理是：</h2><ul>
<li>客户端通过http将请求发送到web服务器</li>
<li>web服务器接收并收集用户请求，然后交给CGI程序进行处理</li>
<li>CGI程序把处理后的结果发送给服务器</li>
<li>服务器将结果传送给浏览器</li>
</ul>
<p>其中上述第二步web服务器通过环境变量或标准输入将请求发送给CGI程序，第三步CGI通过标准输出将结果发送给webServer</p>
<h2 id="CGI接口标准：标准输入-环境变量以及标准输出"><a href="#CGI接口标准：标准输入-环境变量以及标准输出" class="headerlink" title="CGI接口标准：标准输入,环境变量以及标准输出"></a>CGI接口标准：标准输入,环境变量以及标准输出</h2><table>
<thead>
<tr>
<th style="text-align:left">借口标准</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">标准输入</td>
<td>CGI程序像其他可执行程序一样,可通过标准输入(stdin)从Web服务器得到输入信息,如Form中的数据,这就是所谓的向CGI程序传递数据的POST方法。这意味着在操作系统命令行状态可执行CGI程序,对CGI程序进行调试。POST方法是常用的方法。</td>
</tr>
<tr>
<td style="text-align:left">环境变量</td>
<td>操作系统提供了许多环境变量,它们定义了程序的执行环境,应用程序可以存取它们。Web服务器和CGI接口又另外设置了自己的一些环境变量,用来向CGI程序传递一些重要的参数。CGI的GET方法还通过环境变量QUERY-STRING向CGI程序传递Form中的数据。</td>
</tr>
<tr>
<td style="text-align:left">标准输出</td>
<td>CGI程序通过标准输出(stdout)将输出信息传送给Web服务器。传送给Web服务器的信息可以用各种格式,通常是以纯文本或者HTML文本的形式,这样我们就可以在命令行状态调试CGI程序,并且得到它们的输出。</td>
</tr>
</tbody>
</table>
<p>###常用的环境变量<br>Linux中的环境变量是一系列的键值对集合，它们的值可以通过shell设置，也可以被其他进程或程序设置和访问，它们是web服务器传递给CGI程序的一种最简单的方式，之所以叫做环境变量是因为它们是全局变量，任何程序都可以存取它们。</p>
<table>
<thead>
<tr>
<th style="text-align:center">key</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SERVER_NAME</td>
<td>CGI脚本运行时的主机名和IP地址</td>
</tr>
<tr>
<td style="text-align:center">SERVER_SOFTWARE</td>
<td>你的服务器的类型如： CERN/3.0 或 NCSA/1.3.</td>
</tr>
<tr>
<td style="text-align:center">GATEWAY_INTERFACE</td>
<td>运行的CGI版本. 对于UNIX服务器, 这是CGI/1.1</td>
</tr>
<tr>
<td style="text-align:center">SERVER_PROTOCOL</td>
<td>服务器运行的HTTP协议. 这里当是HTTP/1.0.</td>
</tr>
<tr>
<td style="text-align:center">SERVER_PORT</td>
<td>服务器运行的TCP口，通常Web服务器是80.</td>
</tr>
<tr>
<td style="text-align:center">REQUEST_METHOD</td>
<td>POST 或 GET, 取决于你的表单是怎样递交的</td>
</tr>
<tr>
<td style="text-align:center">HTTP_ACCEPT</td>
<td>浏览器能直接接收的Content-types, 可以有HTTP Accept header定义.</td>
</tr>
<tr>
<td style="text-align:center">HTTP_USER_AGENT</td>
<td>递交表单的浏览器的名称、版本 和其他平台性的附加信息。</td>
</tr>
<tr>
<td style="text-align:center">HTTP_REFERER</td>
<td>递交表单的文本的 URL，不是所有的浏览器都发出这个信息，不要依赖它</td>
</tr>
<tr>
<td style="text-align:center">PATH_INFO</td>
<td>附加的路径信息, 由浏览器通过GET方法发出.</td>
</tr>
<tr>
<td style="text-align:center">PATH_TRANSLATED</td>
<td>在PATH_INFO中系统规定的路径信息.</td>
</tr>
<tr>
<td style="text-align:center">SCRIPT_NAME</td>
<td>指向这个CGI脚本的路径, 是在URL中显示的(如, /cgi-bin/thescript).</td>
</tr>
<tr>
<td style="text-align:center"><strong>QUERY_STRING</strong></td>
<td><strong>脚本参数或者表单输入项(如果是用GET递交). QUERY_STRING包含URL中问号后面的参数</strong></td>
</tr>
<tr>
<td style="text-align:center">REMOTE_HOST</td>
<td>递交脚本的主机名，这个值不能被设置.</td>
</tr>
<tr>
<td style="text-align:center">REMOTE_ADDR</td>
<td>递交脚本的主机IP地址.</td>
</tr>
<tr>
<td style="text-align:center">REMOTE_USER</td>
<td>递交脚本的用户名. 如果服务器的authentication被激活，这个值可以设置。</td>
</tr>
<tr>
<td style="text-align:center">REMOTE_IDENT</td>
<td>如果Web服务器是在ident (一种确认用户连接你的协议)运行, 递交表单的系统也在运行ident, 这个变量就含有ident返回值.</td>
</tr>
<tr>
<td style="text-align:center">CONTENT_TYPE</td>
<td>如果表单是用POST递交, 这个值将是 application/x-www-form-urlencoded. 在上载文件的表单中, content-type 是个 multipart/form-data.</td>
</tr>
<tr>
<td style="text-align:center"><strong>CONTENT_LENGTH</strong></td>
<td><strong>对于用POST递交的表单,标准输入口的字节数.</strong></td>
</tr>
</tbody>
</table>
<h2 id="CGI的工作原理图"><a href="#CGI的工作原理图" class="headerlink" title="CGI的工作原理图"></a>CGI的工作原理图</h2><p><img src="../assets/images/CGI" alt=""></p>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/04/cgi原理/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/04/Wait函数详解/">
                            Wait函数详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-04T15:40:48+08:00">
	
		    5月 04, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Wait函数详解"><a href="#Wait函数详解" class="headerlink" title="Wait函数详解"></a>Wait函数详解</h1><h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>sys/types.h<br>signal.h</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>int kill(pid_t pid, int sig);</p>
<p>返回值：执行成功返回0，执行失败返回-1。</p>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>pid为进程ID,sig标识要发送的信号。</p>
<p>kill()函数的作用是用来向指定的进程或进程组发送信号。其中pid有一下<br>几种类型:</p>
<ul>
<li>pid &gt; 0： 发送信号给<strong>进程</strong>标识为pid的进程</li>
<li>pid = 0： 发送信号给当前进程<strong>相同进程组</strong>的所有进程</li>
<li>pid = -1：发送信号给<strong>系统内除了1号进程以外</strong>的所有进程</li>
<li>pid &lt; -1：发送信号给<strong>进程组</strong>标识为-pid的进程。</li>
</ul>
<p>当sig=0时没有信号发出，但是系统会执行错误检查，通常会利用sig值为0来检查某个进程是否在执行。</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>相关知识：WIFSIGNALED和WIFEXITED两个宏是用来判断当前程序的子进程的退出方式，是接收到信号异常退出<br>还是正常调用exit()或return退出。</p>
<ul>
<li>WIFEXITED: 调用exit()或return退出</li>
<li>WIFSIGNALED:接收到信号异常退出 此时可以使用WTERMSIG(status)获取其接受信号的内容。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line">main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line">    <span class="keyword">int</span> status;</div><div class="line">    <span class="keyword">if</span>(!(pid= fork()))</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Hi I am child process!\n"</span>);</div><div class="line">        sleep(<span class="number">10</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"send signal to child process (%d) \n"</span>, pid);</div><div class="line">        sleep(<span class="number">1</span>);</div><div class="line">        kill(pid, SIGABRT);</div><div class="line">        wait(&amp;status);</div><div class="line">        <span class="keyword">if</span>(WIFSIGNALED(status))</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"chile process receive signal %d\n"</span>, WTERMSIG(status));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="wait-与waitpid"><a href="#wait-与waitpid" class="headerlink" title="wait()与waitpid()"></a>wait()与waitpid()</h2><h3 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h3><p>sys/wait.h</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><p>pid_t wait(int<em> status);<br>pid_t waitpid(pid_t pid, int</em> status, int options);</p>
<h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>父进程创建子进程之后，父进程使用wait和waitpid具有监视子进程的运行状态的能力。这两个函数用于<strong>等待子进程的状态发生变化回调并且获取状态发生变化的信息</strong>，所能获取的状态变化包括：<strong>子进程运行结束,子进程被信号量暂停，子进程被信号量回复运行</strong>。</p>
<p>父进程执行wait函数之后，父进程会被阻塞在此处，如果子进程状态发生变化，则wait函数会立即返回结果；否则wait函数会一直阻塞直到子进程状态发生变化。</p>
<p>通常意义上，，如果子进程状态发生了变化，但是还是未被其父进程或者其他系统回调执行wait函数，此时的子进程被称为可等待的。</p>
<p>子进程运行结束后父进程执行wait函数可以推动系统释放与子进程相关的资源；否则子进程将会被维持在<strong>僵尸进程</strong>（子进程已结束，而父进程还在运行）的状态下一直存在。</p>
<h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li>pid：要监听的进程的ID(&lt;-1, =-1, =0, &gt; 0)</li>
<li>status: 用于存储出发状态变化时的信号值和exit(code)中的code值。</li>
<li>options 提供一些额外的选项控制waitpid,目前linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数宏，可以使用|连接使用.</li>
</ul>
<p><strong>pid详细说明</strong>:</p>
<ul>
<li>pid &lt; -1 : 监听范围为进程组为-pid的所有子进程</li>
<li>pid = -1 : 监听范围为调用wait/waitpid的所有子进程</li>
<li>pid = 0: 监听范围为子进程的进程组ID（与父进程相等）</li>
<li>pid &gt; 0: 监听特定pid的进程</li>
</ul>
<p><strong>status详细说明</strong></p>
<p>status用于保存出发wait的信号值或者退出时exit(code)中的code值</p>
<p><strong>options详细说明</strong></p>
<ul>
<li>WNOHANG : 使用此参数调用waitpid,即使子进程没有退出，他也会立即返回，而不是像wait一直等下去</li>
<li>WUNTRACED : 用于调试，极少用</li>
</ul>
<p>一般情况下使用值为0即可。</p>
<h3 id="wait与waitpid关系"><a href="#wait与waitpid关系" class="headerlink" title="wait与waitpid关系"></a>wait与waitpid关系</h3><p>wait实质上是waitpid中pid=-1,options=0时封装，即</p>
<p>wait(&amp;status)与waitpid(-1, &amp;status, 0)完全相同</p>
<h3 id="相关宏"><a href="#相关宏" class="headerlink" title="相关宏"></a>相关宏</h3><p>wait.h中定义了一些宏用于解析status的值：</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WIFEXITED(status)</td>
<td>子进程正常退出返回true否则false</td>
</tr>
<tr>
<td style="text-align:center">WEXITSTATUS(status)</td>
<td>当正常退出时，返回exit(code)中的code</td>
</tr>
<tr>
<td style="text-align:center">WIFSIGNALED</td>
<td>子进程接受信号退出时返回true，否则false</td>
</tr>
<tr>
<td style="text-align:center">WTERMSIG</td>
<td>被信号量杀死时，返回信号量的值</td>
</tr>
<tr>
<td style="text-align:center">WIFSTOPED(status)</td>
<td>当子进程被信号量暂停时返回true</td>
</tr>
<tr>
<td style="text-align:center">WSTOPSIG(status)</td>
<td>被信号量暂停时信号量的值</td>
</tr>
</tbody>
</table>
<p><strong>options值</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WNOHANG</td>
<td>调用wait时制定pid仍未返回，wait立即返回0，用于判断子进程有没有结束</td>
</tr>
<tr>
<td style="text-align:center">WUNTRACED</td>
<td>当子进程被暂停时，则wait立即返回子进程的pid</td>
</tr>
<tr>
<td style="text-align:center">WCONTINUED</td>
<td>当被暂停的子进程又被信号量恢复后，则wait立即返回子进程的pid。Linux 2.6.10及以后生效。在Mac 0S X 10.9.5上未生效。</td>
</tr>
</tbody>
</table>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/04/Wait函数详解/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/05/01/Linux用于IO的数据结构及fcntl函数详解/">
                            Linux用于IO的数据结构及fcntl函数详解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-05-01T23:31:31+08:00">
	
		    5月 01, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Linux环境高级编程/">Linux环境高级编程</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h1 id="Linux用于I-O的数据结构及fcntl函数详解"><a href="#Linux用于I-O的数据结构及fcntl函数详解" class="headerlink" title="Linux用于I/O的数据结构及fcntl函数详解"></a>Linux用于I/O的数据结构及fcntl函数详解</h1><h2 id="Linux内核用于IO的数据结构"><a href="#Linux内核用于IO的数据结构" class="headerlink" title="Linux内核用于IO的数据结构"></a>Linux内核用于IO的数据结构</h2><p>内核使用<strong>三种数据结构</strong>表示打开的文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响.</p>
<ul>
<li>进程表项 每个进程在记录表中都有一个记录项，记录项中包含一张打开的文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：<ul>
<li>文件描述符标志(close_on_exec,close_on_exec是一个进程所有文件描述符的标记位图，每个比特位代表一个打开的文件描述符，用于确定在系统调用execve()时需要关闭的文件句柄)。</li>
<li>指向一个文件表项的指针</li>
</ul>
</li>
<li>文件表项 内核为所有打开文件维护一张文件表（<strong>不同进程打开相同文件将有两条记录</strong>），每个文件表项中包括：<ul>
<li>文件状态标志(read,write,append,async,nonblock等)</li>
<li>当前文件偏移量</li>
<li>指向该文件v(i)节点表项的指针</li>
</ul>
</li>
<li>节点表项。每个打开的文件都有一个v-node结构，v-node中包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，V-node中还包含了文件inode节点信息，这些信息是打开文件时从磁盘上读入内存的，所以文件所有信息都是随时可用的。<ul>
<li>v节点的信息</li>
<li>当前文件的长度</li>
<li>i节点的信息</li>
</ul>
</li>
</ul>
<blockquote>
<p>close_on_exec是一个进程所有文件描述符（文件句柄）的位图标志，<strong>每个bit代表一个打开的文件描述符，用于<br>确定在系统调用execve()时是否需要关闭文件句柄。</strong>当一个进程fork出一个子进程时，通常会在子进程中调用execve()函数<br>加载执行另一个新程序。此时子进程将完全被新程序替换掉，并在子进程中执行新程序。若一个文件描述符在close_on_exec中对应的<br>bit被设置，那么在执行execve()时该文件描述符将被关闭，否则该文件描述符将始终处于打开状态。<br>当打开一个文件的时候，默认情况下文件句柄在子进程中也处于打开状态。<br>注意文件描述符和文件描述符标志的区别，文件描述符是文件进程打开文件时的文件句柄，文件描述符标志为close_on_exec。</p>
</blockquote>
<p>下图显示了一个进程打开两个不同文件时三张表对应的关系：</p>
<p><img src="../assets/images/singleProcessmultifile.png" alt=""></p>
<p>如果两个独立的进程同时打开同一个文件，三张表之间的对应关系如下：</p>
<p><img src="../assets/images/multiProcesssinglefile.png" alt=""><br>从上面可以看出，不同进程打开相同的文件时每个进程将获得各自的文件表项，这是因为不同的进程都有各自的文件偏移量。<br>当我们对文件进行操作的时候，上面三种表项之间的变化关系如下：</p>
<ul>
<li>当对文件进行写操作时（write），在文件表项中的文件偏移量将增加写入的字节数。如果此时文件偏移量超过了文件长度，更新文件长度为当前的文件偏移量</li>
<li>当用O_APPEND标志打开一个文件，则相应的标志也被设置到文件表项的文件标志状态中。每次对这种具有追加标志的文件进行写操作时，<strong>首先将当前文件偏移量设置为文件文件长度</strong>，这就使得每次增加的内容都会写到文件末尾。</li>
<li>若使用lseek定位到文件末尾，则文件表项中偏移量被设置为文件长度</li>
<li>lseek函数只修改文件表项中的偏移量，不进行任何IO操作。</li>
</ul>
<p><strong>注意问题：</strong></p>
<ul>
<li>可能有多个文件描述符指向同一个文件表项，如在fork的时候就有可能发生</li>
<li>注意文件描述符和文件状态标志在作用范围方面的区别。前者只用于一个进程的描述符，而后者则应用于指向该给定文件表项的任何进程中的所有描述符。</li>
</ul>
<h2 id="函数fcntl功能及用法"><a href="#函数fcntl功能及用法" class="headerlink" title="函数fcntl功能及用法"></a>函数fcntl功能及用法</h2><p><strong>函数原型</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/*int args or lock args*/</span>)</span></span>;</div></pre></td></tr></table></figure>
<p><strong>函数功能</strong>:<br>fcntl的作用是改变已经打开的文件属性。</p>
<p><strong>参数说明</strong>:</p>
<ul>
<li>fd 为file descriptor,即文件打开之后的文件描述符</li>
<li>cmd为命令，即需要对fd操作的命令,一般为几个宏定义中的其中一个</li>
<li>args 参数，此参数为执行cmd命令所需要的参数</li>
</ul>
<p><strong>cmd参数命令及功能</strong>:</p>
<p>fcntl的功能可以分为5种:</p>
<ul>
<li>复制一个已有的文件描述符<ul>
<li>cmd = F_DUPFD，此功能<strong>返回一个文件描述符，新的描述符的值为大于或等于args的可用的<br>（尚未打开）文件描述符的最小值，新描述符与fd共用一个文件表项</strong>。但是新的文件描述符有<br> 它自己的一套文件描述符标志.</li>
<li>cmd = F_DUPFD_CLOEXEC.与上述功能一致，唯一不同的是使用此命令会设置CLOSE_ON_EXEC，<br>即当执行execve的时候，文件描述符将被关闭。</li>
</ul>
</li>
<li>获取或设置文件描述符标志<ul>
<li>cmd = F_GETFD <strong>返回与fd关联的close_on_exec标志</strong>，第三个参数被忽略。</li>
<li>cnd = F_SETFD <strong>将文件描述符标志close_on_exec设置为第三个参数</strong>。</li>
</ul>
</li>
<li>获取或设置文件状态标志<ul>
<li>cmd = F_GETFL <strong>获取fd对应的文件的状态标志（存储于文件表项）</strong></li>
<li>cmd = F_SETFL <strong>设置fd对应文件的状态标志</strong></li>
</ul>
</li>
<li>获取或设置异步IO所有权<ul>
<li>cmd = F_GETOWN 获取当前接受SIGIO和SIGURG信号的进程IO或者进程组ID。</li>
<li>cmd = F_SETOWN 设置接受SIGIO和SIGURG信号的进程ID或进程组ID。返回值为正则为进程，返回值为负数即为进程组。</li>
</ul>
</li>
<li>获取或记录锁（cmd=F_GETLK、F_SETLK、F_SETLKW），此处不详解</li>
</ul>
<p><strong>文件状态标志说明</strong>：</p>
<p>文件状态标志存储与文件表项中，它用于说明进程对当前文件的可操作权限。文件的<br>操作权限说明如下图表所示，权限设置可使用|或者&amp;进行设置.</p>
<table>
<thead>
<tr>
<th style="text-align:center">文件状态标志</th>
<th style="text-align:left">功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">O_RDONLY</td>
<td style="text-align:left">只读权限</td>
</tr>
<tr>
<td style="text-align:center">O_WRONLY</td>
<td style="text-align:left">只写权限</td>
</tr>
<tr>
<td style="text-align:center">O_RDWR</td>
<td style="text-align:left">读写权限</td>
</tr>
<tr>
<td style="text-align:center">O_EXEC</td>
<td style="text-align:left">可执行权限</td>
</tr>
<tr>
<td style="text-align:center">O_SEARCH</td>
<td style="text-align:left">只搜索打开权限</td>
</tr>
<tr>
<td style="text-align:center">O_APPEND</td>
<td style="text-align:left">追加写</td>
</tr>
<tr>
<td style="text-align:center">O_NONBLOCK</td>
<td style="text-align:left">非阻塞模式</td>
</tr>
<tr>
<td style="text-align:center">O_SYNC</td>
<td style="text-align:left">等待写完成（数据和属性）</td>
</tr>
<tr>
<td style="text-align:center">O_DSYNC</td>
<td style="text-align:left">等待写完成（仅数据）</td>
</tr>
<tr>
<td style="text-align:center">O_RSYNC</td>
<td style="text-align:left">同步读写</td>
</tr>
<tr>
<td style="text-align:center">O_FSYNC</td>
<td style="text-align:left">等待写完成</td>
</tr>
<tr>
<td style="text-align:center">O_ASYNC</td>
<td style="text-align:left">异步IO</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意O_RDONLY、O_WRONLY、O_RDWR、O_EXEC、O_SEARCH这个五个标志并不各占<br>一位，一个文件的访问方式只能取这五个里面的一个。因此检查当前文件的是这<br>五个标志中的哪一个需要使用屏蔽字O_ACCMODE取得当问方式位，在于这五个标志<br>进行对比。</p>
</blockquote>
<p><strong>代码示例说明</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> test;</div><div class="line">  <span class="comment">//返回结果：test = 10，返回大于等于第三个参数可用的fd(10)。</span></div><div class="line">  test = fcntl(STDIN_FILENO, F_DUPFD, <span class="number">10</span>);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"result of fcntl(STDIN_FILENO, F_DUPFD, 10) is:%d\n"</span>, test);</div><div class="line"></div><div class="line">  <span class="comment">//返回结果：test=11,与上一个函数功能相同</span></div><div class="line">  <span class="comment">//不同之处在于其设置了close_on_exec,当执行exec时关闭响应的文件描述符</span></div><div class="line">  <span class="comment">//注意有一些版本的系统上没有定义这个宏</span></div><div class="line">  <span class="comment">//test = fcntl(STDIN_FILENO, F_DUPFD_CLOEXEC, 10);</span></div><div class="line"></div><div class="line">  <span class="comment">//返回结果 test = 0. 标准输入的文件描述符标志(即关闭标志)为0，</span></div><div class="line">  <span class="comment">//意思是执行exec时关联的文件描述符不关闭</span></div><div class="line">  test = fcntl(STDIN_FILENO, F_GETFD);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"the result of fcntl(STDIN_FILENO, F_GETFD) is:%d\n"</span>, test);</div><div class="line"></div><div class="line">  <span class="comment">//将文件描述符标志设置为0</span></div><div class="line">  fcntl(STDIN_FILENO, F_SETFD, <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="comment">//返回结果 test = 32270</span></div><div class="line">  test = fcntl(STDIN_FILENO, F_GETFL);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"the result of fcntl(STDIN_FILENO, F_GETFL) is:%d\n"</span>, test);</div><div class="line"></div><div class="line">  <span class="comment">//给STDIN_FILENO对应的IO添加非阻塞权限</span></div><div class="line">  test |= O_NONBLOCK;</div><div class="line">  fcntl(STDIN_FILENO, F_SETFL, test);</div><div class="line"></div><div class="line">  test = fcntl(STDIN_FILENO, F_GETFL);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"the result of fcntl(STDIN_FILENO, F_GETFL) is:%d\n"</span>, test);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="STDIN-FILENO，STDOUT-FILENO以及STDERR-FILENO"><a href="#STDIN-FILENO，STDOUT-FILENO以及STDERR-FILENO" class="headerlink" title="STDIN_FILENO，STDOUT_FILENO以及STDERR_FILENO"></a>STDIN_FILENO，STDOUT_FILENO以及STDERR_FILENO</h2><p>STDIN_FILENO等是系统API接口库中<unistd.h>的宏定义，它是一个int类型的值，是打开文件的句柄，<br>对应的主要函数有open,read,write和close等。<br>STDIN_FILENO的含义是标准输入（键盘）的文件描述符，STDOUT_FILENO是标准输出流的文件描述符，STDERR_FILENO<br>是标准错误流的文件描述符。</unistd.h></p>
<h3 id="STDIN-FILENO与stdin的区别"><a href="#STDIN-FILENO与stdin的区别" class="headerlink" title="STDIN_FILENO与stdin的区别"></a>STDIN_FILENO与stdin的区别</h3><ul>
<li>数据类型不同 stdin的数据类型为FILE*，STDIN_NO的数据类型为int</li>
<li>可用的函数不同 stdin主要用的函数有fread,fwrite,fclose，STDIN_FILENO可用的函数为write，read和close</li>
<li>stdin属于标准IO，高级的输入输出函数，在stdio.h中定义;STDIN_FILENO是文件描述符，一般定义为0,1,2,属于没有buffer的IO,直接调用系统调用，定义在unistd.h中</li>
<li>层次不同，stdin属于标注库处理的输入流，其声明为FILE*型，对应的函数前面都有f开头；而STDIN_FILENO属于系统API接口，对用的函数是一些系统级的调用</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2017/05/01/Linux用于IO的数据结构及fcntl函数详解/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        <li class="pagination-prev">
            
                <a class="btn btn--default btn--small" href="/ ">
            
                <i class="fa fa-angle-left text-base icon-mr"></i>
                    <span>NEWER POSTS</span>
            </a>
        </li>
        
        
        <li class="pagination-number">page 2 of 2</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 魏传柳(langzi989). All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avar.jpg"/>
        
            <h4 id="about-card-name">魏传柳(langzi989)</h4>
        
            <h5 id="about-card-bio"><p>author.bio</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Guangzhou,China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script-i4qo6jx6jji9fg0dftpya6ivemizsbow4fhow76d8dwpm7m1wbvi378ssumx.min.js"></script>
<!--SCRIPTS END-->



</html>
